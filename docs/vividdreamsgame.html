<!DOCTYPE HTML>
<html>

<!-- HEADER -->

<!-- Borksy 4.4 -->
<!-- Bitsy 7.2 -->
<head>

<meta charset="UTF-8">

<title>Vivid Dreams</title>

<script type="text/bitsyGameData" id="exportedGameData">
"""
Lucid Dreams
(follower "j")
"""

# BITSY VERSION 7.2

! ROOM_FORMAT 1

PAL 1
73,20,102
146,70,186
255,255,255
121,37,176
65,182,229

PAL 2
110,53,19
111,30,155
255,255,255

PAL 3
NAME bedroom
0,0,0
3,6,208
67,125,255

PAL 4
NAME invisi avatar
0,0,0
3,6,208
0,0,0

PAL 5
NAME phone
0,0,0
255,255,255
137,128,134

PAL 6
0,0,0
255,255,255
255,255,255

PAL 7
NAME maze
71,58,50
13,134,23
4,234,35

PAL 8
0,0,0
255,132,19
255,132,19
255,5,31
255,132,19
252,255,14
7,151,1
5,1,255

PAL 9
255,132,19
255,132,19
255,132,19
255,5,31
255,132,19
252,255,14
7,151,1
5,1,255

PAL a
NAME red
0,0,0
255,5,31
255,5,31
255,5,31
255,132,19
252,255,14
7,151,1
5,1,255

PAL b
255,5,31
255,5,31
255,5,31
255,5,31
255,132,19
252,255,14
7,151,1
5,1,255

PAL c
NAME blue
0,0,0
5,1,255
5,1,255
255,5,31
255,132,19
252,255,14
7,151,1
5,1,255

PAL d
5,1,255
5,1,255
5,1,255
255,5,31
255,132,19
252,255,14
7,151,1
5,1,255

PAL e
NAME yellow
0,0,0
252,255,14
252,255,14
255,5,31
255,132,19
252,255,14
7,151,1
5,1,255

PAL f
252,255,14
252,255,14
252,255,14
255,5,31
255,132,19
252,255,14
7,151,1
5,1,255

PAL g
NAME green
0,0,0
7,151,1
7,151,1
255,5,31
255,132,19
252,255,14
7,151,1
5,1,255

PAL h
7,151,1
7,151,1
7,151,1
255,5,31
255,132,19
252,255,14
7,151,1
5,1,255

PAL i
NAME escape killer
2,4,144
0,0,0
67,125,255

ROOM 1
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m
0,0,0,0,0,0,0,0,0,0,0,9,b,1,c,d
0,0,0,0,0,0,0,0,0,0,0,e,f,2,3,4
0,0,0,0,0,0,0,0,0,0,0,g,h,5,6,7
0,0,0,0,0,0,0,0,0,0,0,i,j,8,k,l
m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME starting position
ITM 2 2,11
ITM 2 2,10
ITM 2 2,12
ITM 2 2,13
EXT 15,11 2 1,11
EXT 15,12 2 1,11
PAL 1

ROOM 2
0,0,n,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,n,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,n,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,n,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,n,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,n,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,n,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,n,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,n,0,0,0,0,0,0,0,0,0,0,0,0,0
0,o,n,m,m,m,m,m,m,m,m,m,m,m,m,m
0,p,q,r,s,t,u,v,w,x,y,z,10,11,12,13
m,14,15,16,17,18,19,1a,1b,1c,1d,1e,1f,1g,1h,1i
1j,1k,1l,1m,1n,1o,1p,1q,1r,1s,1t,1u,1v,1w,1x,1y
1z,20,20,21,20,20,22,20,20,23,20,20,24,20,20,25
m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME hallway
EXT 15,10 3 0,10
EXT 15,11 3 0,11
EXT 15,12 3 0,12
EXT 15,13 3 0,13
PAL 1

ROOM 3
0,0,0,0,0,a,0,0,0,0,0,4s,0,0,0,0
0,0,0,0,0,a,0,0,0,0,0,4s,m,m,m,m
0,0,0,0,0,a,0,0,0,0,2d,2e,2f,2g,2h,1i
0,0,0,0,0,a,0,0,0,m,2i,2j,2k,2l,2m,2n
0,0,0,0,0,a,0,0,m,2o,2p,2q,2r,2s,2t,2u
0,0,0,0,0,a,0,m,2v,2w,r,2x,2y,16,2z,1i
0,0,0,0,0,a,0,30,31,32,33,34,35,36,37,1i
0,0,0,0,0,a,m,38,1p,x,39,3a,3b,3c,28,3d
0,0,0,0,0,a,3e,3f,3g,3h,3i,1u,3j,3k,20,3l
m,m,m,m,m,a,3m,3n,3o,3p,20,3q,3r,3s,3t,3u
3v,3w,3x,3y,3z,40,u,v,41,3w,1x,42,43,44,45,13
46,47,48,49,4a,18,19,4b,1b,1c,4c,1e,1f,4d,1h,1i
4e,4f,s,4g,4h,16,4i,4j,1r,4k,4l,1u,4m,4n,1x,1y
4o,20,20,24,20,20,4p,20,20,4q,20,20,4r,20,20,25
m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME hallway ends
EXT 6,10 4 0,10
EXT 6,11 4 0,11
EXT 6,12 4 0,12
EXT 5,13 4 0,13
PAL 1

ROOM 4
0,0,0,0,0,4s,0,0,0,0,0,0,0,0,0,4t
0,0,0,0,0,4s,m,m,m,m,m,m,m,m,4u,4v
0,0,0,0,2d,2e,2f,2g,2h,4w,4x,4y,2f,4z,50,51
0,0,0,m,2i,2j,2k,2l,2m,52,53,2j,2k,54,55,64
0,0,m,2o,2p,2q,2r,2s,2t,56,2p,2q,2r,57,58,59
0,0,2v,2w,r,2x,2y,16,2z,1o,y,5a,5b,1i,5c,5d
0,30,31,32,33,34,35,36,37,1i,33,5e,m,5f,5g,m
m,38,1p,x,39,3a,3b,3c,28,3d,5h,5i,51,51,51,5j
3e,3f,3g,3h,3i,1u,3j,3k,20,3l,3i,5k,64,1i,5l,0
3m,3n,3o,3p,20,3q,3r,3s,3t,3u,20,3q,3r,5m,5n,0
u,v,41,3w,1x,42,43,44,45,13,1x,42,43,5o,5p,5q
19,4b,1b,1c,4c,1e,1f,4d,1h,1i,5r,5s,5t,0,5u,5v
4i,4j,1r,4k,4l,1u,4m,4n,1x,1y,4l,5w,5x,0,5y,5z
4p,20,20,4q,20,20,4r,20,20,25,20,60,0,61,62,63
m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME almost kitchen
EXT 15,4 5 4,4
EXT 15,5 5 4,4
PAL 1

ROOM 5
0,0,0,0,4t,4t,4t,4t,4t,4t,4t,67,4t,4t,4t,4t
m,m,m,4u,4v,0,0,0,0,0,68,69,6a,6b,0,0
4y,2f,4z,50,51,6c,51,6d,51,6e,6f,6g,6f,6h,6d,51
2j,2k,54,55,64,6i,64,6j,64,6k,64,6l,64,64,6j,64
2q,2r,57,58,59,20,6m,6n,1i,1i,6o,1i,1i,6o,1i,1i
5a,5b,1i,5c,5d,64,6p,5b,1i,6p,5b,1i,6p,5b,1i,6p
5e,m,5f,5g,m,0,m,6q,2n,6r,1i,2n,6r,1i,2n,6r
5i,51,51,51,5j,0,6s,6t,6u,1i,1i,6u,1i,5o,m,m
5k,64,64,5l,0,0,6v,6w,6x,1i,6y,6x,6z,0,0,7o
3q,3r,5m,5n,0,70,71,72,1i,73,74,75,5x,0,76,77
42,43,5o,65,5q,78,79,1i,1i,7a,1i,60,0,0,7b,7c
5s,5t,0,66,5v,7d,7e,1i,7f,7e,1i,7g,20,20,20,20
5w,5x,0,5y,7h,7i,1i,7j,7k,1i,7j,7l,64,64,64,64
60,0,61,7n,7m,20,20,4r,20,20,4r,20,20,4r,20,20
0,0,0,0,m,m,m,m,m,m,m,m,m,m,m,m
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME finally kitchen
ITM 4 5,4
PAL 1

ROOM 6
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME i'm dreaming room
PAL 1

ROOM 7
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,m,0,0,0,0,0,0,0
0,0,0,0,0,0,0,m,0,m,0,0,0,0,0,0
0,0,0,0,0,0,0,0,m,0,30,4t,4t,7p,0,0
0,0,7q,51,7r,7s,7t,0,0,0,a,4t,7u,7v,0,0
0,0,a,20,7w,7x,7y,7z,80,81,82,4t,7u,7v,0,0
0,0,83,64,84,0,0,85,86,87,88,0,0,a,0,0
20,64,64,64,64,64,64,89,8a,8b,8c,20,20,20,8d,8e
20,8f,0,0,0,0,0,8g,8h,8i,20,2b,64,64,8j,8k
20,8l,8m,0,0,0,0,0,8n,20,20,8o,0,0,8p,8q
20,20,8r,0,0,0,0,0,0,8s,20,20,8t,20,20,8u
20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME bedroom
PAL 3

ROOM 8
0,0,8v,8w,20,8x,8y,8z,90,91,92,93,94,20,0,0
0,0,95,96,64,97,98,99,9a,9b,9c,9d,9e,64,0,0
0,0,20,20,20,20,20,20,20,20,20,20,20,20,0,0
0,0,20,9f,9g,9h,9i,9j,9k,9l,9m,9n,9o,20,0,0
0,0,20,9p,9q,9r,9s,9t,9u,9v,9w,9x,9y,20,0,0
0,0,20,9z,a0,a1,a2,a3,a4,a5,a6,a7,a8,20,0,0
0,0,20,a9,aa,ab,ac,ad,ae,af,ag,ah,ai,20,0,0
0,0,20,aj,ak,al,am,an,ao,ap,aq,ar,as,20,0,0
0,0,20,at,au,av,aw,ax,ay,az,b0,b1,b2,20,0,0
0,0,20,20,20,20,20,20,20,cb,cb,cb,cb,20,0,0
0,0,20,b3,b4,b5,b6,b7,20,cb,20,20,cb,20,0,0
0,0,20,b8,b9,ba,bb,bc,bd,be,bf,bg,bh,20,0,0
0,0,20,bi,bj,az,bk,bl,bm,bn,bo,bp,bq,20,0,0
0,0,20,al,br,bs,al,bt,bu,bv,a1,bw,bx,20,0,0
0,0,20,by,bz,c0,al,c1,c2,c3,c4,c5,c6,20,0,0
0,0,20,20,20,20,20,20,20,c7,c8,c9,ca,20,0,0
NAME phone page 1
EXT 11,10 9 10,11
PAL 5

ROOM 9
0,0,8v,8w,20,8x,8y,8z,90,91,92,93,94,20,0,0
0,0,95,96,64,97,98,99,9a,9b,9c,9d,9e,64,0,0
0,0,20,20,20,20,20,20,20,20,20,20,20,20,0,0
0,0,20,cc,cd,ce,cf,cg,ch,ci,cj,ck,cl,20,0,0
0,0,20,20,20,20,20,20,20,20,20,20,20,20,0,0
0,0,20,cm,cn,co,cp,20,20,20,20,20,20,20,0,0
0,0,20,cq,cr,cs,ct,cu,a7,cv,cw,cx,cy,20,0,0
0,0,20,cz,d0,a1,d1,d2,d3,d4,d5,d6,d7,20,0,0
0,0,20,d8,d9,da,db,dc,dd,de,df,a0,dg,20,0,0
0,0,20,dh,di,a6,dj,dk,dl,dm,dn,ce,do,20,0,0
0,0,20,20,20,20,20,20,20,cb,cb,cb,20,20,0,0
0,0,20,dp,dq,co,cp,20,20,cb,20,20,cb,20,0,0
0,0,20,bi,bj,az,bk,bl,bm,bn,bo,bp,bq,20,0,0
0,0,20,al,br,bs,al,bt,bu,bv,a1,bw,bx,20,0,0
0,0,20,by,bz,c0,al,c1,c2,c3,c4,c5,c6,20,0,0
0,0,20,dr,ds,dt,du,dv,a6,dw,dx,dy,dz,20,0,0
NAME phone page 2
PAL 5

ROOM 10
cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb
cb,0,0,0,0,0,0,0,0,0,0,cb,0,0,0,0
cb,0,cb,cb,cb,cb,cb,cb,cb,cb,0,cb,0,cb,0,cb
cb,0,cb,0,0,0,0,0,0,cb,0,cb,0,cb,0,cb
cb,0,cb,0,cb,0,cb,cb,cb,cb,0,cb,0,cb,0,cb
cb,0,cb,0,cb,0,0,0,0,cb,0,cb,0,cb,0,cb
0,0,0,0,cb,0,cb,cb,0,cb,0,cb,0,cb,0,cb
cb,cb,cb,cb,cb,0,cb,cb,0,cb,0,cb,0,cb,0,cb
cb,0,0,0,0,0,cb,0,0,cb,0,0,0,cb,0,cb
cb,0,cb,cb,cb,cb,cb,0,cb,cb,cb,cb,cb,cb,0,cb
cb,0,0,0,0,0,cb,0,cb,0,0,0,cb,0,0,cb
cb,0,cb,cb,cb,cb,cb,0,cb,0,cb,cb,cb,cb,cb,cb
cb,0,cb,0,0,0,0,0,cb,0,0,0,0,0,0,cb
cb,0,cb,cb,cb,cb,cb,cb,cb,0,cb,cb,cb,cb,0,cb
cb,0,0,0,0,0,0,0,0,0,cb,0,0,0,0,cb
cb,cb,cb,cb,cb,0,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb
NAME maze entrance
EXT 5,15 11 5,0
EXT 15,1 12 0,1
PAL 7

ROOM 11
cb,cb,cb,cb,cb,0,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb
cb,0,0,0,0,0,0,0,0,0,0,0,0,0,0,cb
cb,0,cb,0,cb,cb,cb,cb,cb,cb,cb,cb,0,cb,0,cb
cb,0,cb,0,cb,0,cb,0,0,0,0,0,0,cb,0,cb
cb,0,cb,0,cb,0,cb,0,cb,cb,cb,cb,0,cb,0,cb
cb,0,cb,0,0,0,cb,0,cb,0,0,0,0,cb,0,cb
cb,0,cb,cb,cb,0,cb,0,cb,0,cb,cb,0,cb,0,cb
cb,0,cb,0,cb,0,cb,0,cb,0,0,cb,0,cb,0,cb
cb,0,cb,0,cb,0,cb,0,cb,cb,0,cb,0,cb,0,cb
cb,0,0,0,cb,0,cb,cb,0,cb,0,cb,cb,cb,0,cb
cb,cb,cb,0,0,0,cb,0,0,cb,0,0,0,cb,0,cb
0,0,cb,cb,0,cb,cb,0,cb,cb,cb,cb,cb,cb,0,cb
cb,0,0,0,0,cb,0,0,cb,0,0,0,0,0,0,cb
cb,cb,cb,cb,0,cb,0,cb,cb,0,cb,cb,cb,cb,0,cb
cb,0,0,0,0,cb,0,0,0,0,cb,0,0,0,0,cb
cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,0,cb,cb,cb,cb
NAME maze down
ITM 5 0,11
ITM 6 11,15
PAL 7

ROOM 12
cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,0,cb,cb,cb
0,0,0,0,0,0,0,cb,0,0,0,cb,0,0,0,cb
cb,cb,cb,0,cb,cb,0,cb,0,cb,0,cb,cb,cb,0,cb
cb,0,0,0,0,cb,0,cb,0,cb,0,0,0,cb,0,cb
cb,0,cb,cb,0,cb,0,0,0,cb,0,cb,0,cb,0,cb
cb,0,cb,cb,0,cb,cb,cb,cb,cb,0,cb,0,0,0,cb
cb,0,cb,cb,0,0,0,0,0,cb,0,cb,cb,cb,cb,cb
cb,0,0,0,cb,cb,cb,cb,cb,cb,0,0,0,0,0,cb
cb,0,cb,0,0,0,0,0,0,cb,0,cb,cb,cb,0,cb
cb,0,cb,cb,cb,cb,cb,cb,0,cb,0,cb,0,cb,0,cb
cb,0,0,0,0,0,0,0,cb,0,0,cb,0,cb,0,cb
cb,0,cb,cb,cb,cb,cb,cb,cb,0,cb,0,0,0,0,cb
cb,0,cb,0,0,0,0,0,0,0,0,0,cb,cb,0,cb
cb,0,cb,cb,cb,cb,cb,cb,cb,cb,cb,0,cb,cb,0,cb
cb,0,cb,0,0,0,0,0,0,0,0,0,0,0,0,cb
cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,cb,0,cb
NAME maze right
ITM 7 14,15
ITM 8 12,0
PAL 7

ROOM 13
0,0,0,e0,20,e1,20,20,20,20,20,20,e2,0,0,0
0,0,0,e0,20,e3,e4,20,20,20,e5,e6,e2,0,0,0
0,0,0,e0,e7,20,20,e8,20,e9,20,20,e2,0,0,0
0,0,0,e0,ea,eb,20,ec,ed,20,ee,ef,e2,0,0,0
0,0,0,e0,eg,eh,20,20,20,ei,20,20,e2,0,0,0
0,0,0,e0,ej,ek,el,20,em,en,eo,20,e2,0,0,0
0,0,0,e0,20,20,ep,eb,20,eq,er,20,e2,0,0,0
0,0,0,e0,es,et,20,eu,ev,ej,ew,eu,e2,0,0,0
0,0,0,e0,20,20,20,ex,ey,20,20,ez,e2,0,0,0
0,0,0,f0,f1,f1,f1,f1,f1,f1,f1,f1,f2,0,0,0
f3,f4,f5,f6,20,f7,20,f8,f9,20,20,20,fa,fb,fc,fd
fe,ff,20,20,fg,fh,fi,20,20,20,20,fj,fk,20,fl,8e
1z,fm,fn,20,20,20,20,20,20,20,20,fo,fp,20,20,fq
m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m
m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME memory game
PAL 3

ROOM 14
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,hp,hp,ht,ht,hr,hr,0,0
0,0,0,0,0,0,0,0,hp,hp,ht,ht,hr,hr,0,0
0,0,0,0,hs,hs,0,0,0,0,0,0,0,0,0,0
0,0,0,0,hs,hs,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,hq,hq,0,0,0,0,0,0
0,0,0,0,0,0,0,0,hq,hq,0,0,0,0,0,0
0,0,0,0,hs,hs,0,0,ht,ht,hp,hp,0,0,0,0
0,0,0,0,hs,hs,0,0,ht,ht,hp,hp,0,0,0,0
0,0,0,0,0,0,0,0,0,0,hr,hr,0,0,0,0
0,0,0,0,0,0,0,0,0,0,hr,hr,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,hq,hq
0,0,0,0,0,0,0,0,0,0,0,0,0,0,hq,hq
NAME wire game
ITM 9 14,13
ITM a 14,12
ITM b 14,11
ITM c 14,10
ITM d 14,9
ITM f 12,9
ITM g 11,9
ITM h 10,9
ITM i 9,9
ITM e 13,9
ITM 2z 11,8
ITM 2z 10,8
ITM 2z 12,8
ITM 2z 13,8
ITM 2z 14,8
ITM 2z 15,8
ITM 2z 15,9
ITM 2z 15,10
ITM 2z 15,11
ITM 2z 15,12
ITM 2z 15,13
ITM 2z 15,15
ITM 2z 15,14
ITM 2z 13,15
ITM 2z 13,14
ITM 2z 13,12
ITM 2z 13,13
ITM 2z 13,11
ITM 2z 13,10
ITM 2z 12,10
ITM 2z 11,10
ITM 2z 10,10
PAL 8

ROOM 15
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,fr
20,20,20,20,20,20,fs,20,20,20,20,20,20,ft,20,20
20,20,fu,64,64,fv,8u,20,20,2b,64,64,3v,fw,20,cb
64,64,fx,hu,hu,fy,6l,64,64,fz,hu,hu,g0,g1,64,1i
20,8c,g2,g3,g4,g5,g6,20,20,g7,g3,g3,g8,g9,20,20
m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,ga
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,m
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME etk beginning
EXT 15,8 16 0,9
EXT 15,10 17 0,9
PAL 3

ROOM 16
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,fr
20,20,20,20,20,gb,gc,gd,ge,gf,gg,20,20,20,20,20
20,20,20,20,20,gh,20,gi,fw,gj,20,20,20,20,20,cb
64,64,64,64,64,gk,gl,gm,g1,gn,64,64,64,64,64,1i
20,20,20,20,20,go,gp,gq,gr,gs,20,20,20,20,20,20
m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,ga
0,0,0,0,0,0,0,0,0,0,0,0,0,0,m,m
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME etk 1st up
EXT 15,10 18 0,9
EXT 15,8 19 0,9
PAL 3

ROOM 17
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,fr
20,20,20,gj,gt,g3,g3,g3,g3,gu,gv,20,20,20,20,20
20,20,20,gj,20,gw,gx,gy,20,gj,gh,20,20,20,20,cb
64,64,64,gn,cb,hw,gz,h0,cb,hv,h1,64,64,64,64,1i
20,20,20,gs,gc,h2,h3,h4,gc,h5,h6,20,20,20,20,20
m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,ga
0,0,0,0,0,0,0,0,0,0,0,0,0,0,m,m
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME etk 1st down
EXT 15,10 18 0,9
EXT 15,8 18 0,9
PAL 3

ROOM 18
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
20,20,20,20,20,20,h7,20,20,20,20,20,20,20,20,20
20,20,20,20,20,20,gh,20,20,20,h8,h9,ha,hb,h9,ha
64,64,64,64,64,64,6k,64,64,64,hc,hd,he,hf,hd,he
20,20,20,20,20,20,hg,20,20,20,hh,hi,hj,hk,hi,hj
m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME dead end
PAL 3

ROOM 19
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
20,20,20,gj,gt,g3,g3,g3,g3,g3,g3,g3,g3,hl,20,20
20,20,20,gj,20,gw,gx,gy,20,20,20,20,20,hm,20,20
64,64,64,gn,cb,hw,gz,h0,cb,cb,cb,cb,cb,hn,64,64
20,20,20,gs,gc,h2,h3,h4,gc,gc,gc,gc,gc,ho,20,20
m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME police station
ITM 30 14,9
PAL 3

ROOM 20
hx,hy,hz,i0,i1,0,i2,i3,i4,i5,i6,i7,0,0,0,0
i8,20,20,20,i9,ia,ib,20,20,ic,id,ie,if,ig,ih,ii
ij,ik,il,im,in,io,ip,iq,ir,is,it,20,20,20,20,iu
iv,ek,20,20,20,iw,20,ix,0,iy,iz,j0,20,20,20,e8
20,20,20,20,20,j1,j2,l,j3,j4,j5,j6,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,m,0,0,0,0,0,0,0,0,0,8e
0,0,0,0,m,0,m,0,0,0,0,j7,j8,j8,j9,8k
0,0,0,0,0,m,0,0,0,0,0,ja,0,0,8p,jb
0,0,0,0,0,0,0,0,0,0,0,jc,jd,je,je,jf
hx,hy,hz,i0,i1,0,i2,i3,i4,i5,i6,jg,jh,0,0,ji
i8,20,20,20,i9,ia,ib,20,20,ic,id,ie,if,ig,ih,ii
ij,ik,il,im,in,io,ip,iq,ir,is,it,20,20,20,20,iu
iv,ek,20,20,20,iw,20,ix,0,iy,iz,j0,20,20,20,e8
20,20,20,20,20,j1,j2,l,j3,j4,j5,j6,0,0,0,0
NAME lucid
PAL 0

ROOM 1a
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,hp,hp,ht,ht,hr,hr,0,0
0,0,0,0,0,0,0,0,hp,hp,ht,ht,hr,hr,0,0
0,0,0,0,hs,hs,0,0,0,0,0,0,0,0,0,0
0,0,0,0,hs,hs,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,hq,hq,hq,hq,hq,hq,hq,hq
0,0,0,0,0,0,0,0,hq,hq,hq,hq,hq,hq,hq,hq
0,0,0,0,hs,hs,0,0,ht,ht,hp,hp,0,0,hq,hq
0,0,0,0,hs,hs,0,0,ht,ht,hp,hp,0,0,hq,hq
0,0,0,0,0,0,0,0,0,0,hr,hr,0,0,hq,hq
0,0,0,0,0,0,0,0,0,0,hr,hr,0,0,hq,hq
0,0,0,0,0,0,0,0,0,0,0,0,0,0,hq,hq
0,0,0,0,0,0,0,0,0,0,0,0,0,0,hq,hq
NAME red flow
ITM j 12,11
ITM k 12,12
ITM l 12,13
ITM m 12,14
ITM n 11,14
ITM o 10,14
ITM p 9,14
ITM q 8,14
ITM r 7,14
ITM s 6,14
ITM t 5,14
ITM u 4,14
ITM v 3,14
ITM w 2,14
ITM x 1,14
ITM y 1,13
ITM z 1,12
ITM 10 1,11
ITM 11 1,10
ITM 12 1,9
ITM 13 1,8
ITM 14 1,7
ITM 15 1,6
ITM 16 1,5
ITM 17 1,4
ITM 18 1,3
ITM 19 1,2
ITM 1a 1,1
ITM 1b 2,1
ITM 1c 3,1
ITM 1d 4,1
ITM 1e 5,1
ITM 1f 6,1
ITM 1g 7,1
ITM 1h 8,1
ITM 21 8,2
ITM 2z 13,15
ITM 2z 11,15
ITM 2z 12,15
ITM 2z 10,15
ITM 2z 9,15
ITM 2z 8,15
ITM 2z 7,15
ITM 2z 6,15
ITM 2z 5,15
ITM 2z 4,15
ITM 2z 3,15
ITM 2z 2,15
ITM 2z 1,15
ITM 2z 0,15
ITM 2z 0,14
ITM 2z 0,13
ITM 2z 0,12
ITM 2z 0,11
ITM 2z 0,10
ITM 2z 0,9
ITM 2z 0,8
ITM 2z 0,7
ITM 2z 0,6
ITM 2z 0,5
ITM 2z 0,4
ITM 2z 0,3
ITM 2z 0,1
ITM 2z 0,2
ITM 2z 0,0
ITM 2z 1,0
ITM 2z 2,0
ITM 2z 3,0
ITM 2z 4,0
ITM 2z 5,0
ITM 2z 6,0
ITM 2z 7,0
ITM 2z 8,0
ITM 2z 9,0
ITM 2z 9,1
ITM 2z 7,2
ITM 2z 6,2
ITM 2z 5,2
ITM 2z 4,2
ITM 2z 2,2
ITM 2z 3,2
ITM 2z 2,3
ITM 2z 2,4
ITM 2z 2,5
ITM 2z 2,6
ITM 2z 2,7
ITM 2z 2,8
ITM 2z 2,9
ITM 2z 2,10
ITM 2z 2,11
ITM 2z 2,12
ITM 2z 2,13
ITM 2z 3,13
ITM 2z 4,13
ITM 2z 5,13
ITM 2z 6,13
ITM 2z 7,13
ITM 2z 8,13
ITM 2z 9,13
ITM 2z 10,13
ITM 2z 11,13
ITM 2z 11,12
ITM 2z 11,10
ITM 2z 12,10
ITM 2z 13,10
ITM 2z 13,11
ITM 2z 13,12
ITM 2z 13,13
ITM 2z 13,14
ITM 2z 10,10
ITM 2z 10,11
PAL a

ROOM 1b
hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,0,0,0,0,0,0
hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,0,0,0,0,0,0
hp,hp,0,0,0,0,0,0,hp,hp,ht,ht,hr,hr,0,0
hp,hp,0,0,0,0,0,0,hp,hp,ht,ht,hr,hr,0,0
hp,hp,0,0,hs,hs,0,0,0,0,0,0,0,0,0,0
hp,hp,0,0,hs,hs,0,0,0,0,0,0,0,0,0,0
hp,hp,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hp,hp,0,0,0,0,0,0,0,0,0,0,0,0,0,0
hp,hp,0,0,0,0,0,0,hq,hq,hq,hq,hq,hq,hq,hq
hp,hp,0,0,0,0,0,0,hq,hq,hq,hq,hq,hq,hq,hq
hp,hp,0,0,hs,hs,0,0,ht,ht,hp,hp,hp,hp,hq,hq
hp,hp,0,0,hs,hs,0,0,ht,ht,hp,hp,hp,hp,hq,hq
hp,hp,0,0,0,0,0,0,0,0,hr,hr,hp,hp,hq,hq
hp,hp,0,0,0,0,0,0,0,0,hr,hr,hp,hp,hq,hq
hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hq,hq
hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hq,hq
NAME blue flow
ITM 1i 11,1
ITM 1j 12,1
ITM 1k 13,1
ITM 1l 14,1
ITM 1m 14,2
ITM 1n 14,3
ITM 1o 14,4
ITM 1p 14,5
ITM 1q 14,6
ITM 1r 13,6
ITM 1s 12,6
ITM 1t 11,6
ITM 1u 10,6
ITM 1v 9,6
ITM 1w 8,6
ITM 1x 7,6
ITM 1y 7,8
ITM 1z 7,9
ITM 20 7,10
ITM 22 8,10
ITM 2z 10,1
ITM 2z 10,0
ITM 2z 11,0
ITM 2z 12,0
ITM 2z 13,0
ITM 2z 14,0
ITM 2z 15,0
ITM 2z 15,1
ITM 2z 15,2
ITM 2z 15,3
ITM 2z 15,4
ITM 2z 15,5
ITM 2z 15,6
ITM 2z 15,7
ITM 2z 14,7
ITM 2z 13,7
ITM 2z 12,7
ITM 2z 11,7
ITM 2z 10,7
ITM 2z 9,7
ITM 2z 8,7
ITM 2z 8,8
ITM 2z 8,9
ITM 2z 12,2
ITM 2z 13,2
ITM 2z 10,2
ITM 2z 10,3
ITM 2z 11,3
ITM 2z 13,3
ITM 2z 13,4
ITM 2z 13,5
ITM 2z 12,5
ITM 2z 11,5
ITM 2z 10,5
ITM 2z 9,5
ITM 2z 8,5
ITM 2z 7,5
ITM 2z 6,5
ITM 2z 6,6
ITM 2z 6,7
ITM 2z 6,8
ITM 2z 6,9
ITM 2z 6,10
ITM 2z 6,11
ITM 2z 7,11
ITM 2z 8,11
PAL c

ROOM 1c
hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,ht,ht,ht,ht,ht,ht
hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,ht,ht,ht,ht,ht,ht
hp,hp,0,0,0,0,0,0,hp,hp,ht,ht,hr,hr,ht,ht
hp,hp,0,0,0,0,0,0,hp,hp,ht,ht,hr,hr,ht,ht
hp,hp,0,0,hs,hs,0,0,0,0,0,0,0,0,ht,ht
hp,hp,0,0,hs,hs,0,0,0,0,0,0,0,0,ht,ht
hp,hp,0,0,0,0,ht,ht,ht,ht,ht,ht,ht,ht,ht,ht
hp,hp,0,0,0,0,ht,ht,ht,ht,ht,ht,ht,ht,ht,ht
hp,hp,0,0,0,0,ht,ht,hq,hq,hq,hq,hq,hq,hq,hq
hp,hp,0,0,0,0,ht,ht,hq,hq,hq,hq,hq,hq,hq,hq
hp,hp,0,0,hs,hs,ht,ht,ht,ht,hp,hp,hp,hp,hq,hq
hp,hp,0,0,hs,hs,ht,ht,ht,ht,hp,hp,hp,hp,hq,hq
hp,hp,0,0,0,0,0,0,0,0,hr,hr,hp,hp,hq,hq
hp,hp,0,0,0,0,0,0,0,0,hr,hr,hp,hp,hq,hq
hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hq,hq
hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hq,hq
NAME yellow flow
ITM 23 9,12
ITM 24 8,12
ITM 25 7,12
ITM 26 6,12
ITM 27 5,12
ITM 28 4,12
ITM 29 3,12
ITM 2a 3,11
ITM 2b 3,10
ITM 2c 3,9
ITM 2d 3,8
ITM 2e 3,7
ITM 2f 3,6
ITM 2g 3,5
ITM 2h 3,4
ITM 2i 3,3
ITM 2j 4,3
ITM 2k 5,3
ITM 2l 6,3
ITM 2m 6,4
ITM 2n 8,4
ITM 2o 9,4
ITM 2p 10,4
ITM 2q 11,4
ITM 2r 12,4
ITM 2s 12,3
ITM 2z 9,13
ITM 2z 8,13
ITM 2z 7,13
ITM 2z 6,13
ITM 2z 5,13
ITM 2z 4,13
ITM 2z 3,13
ITM 2z 2,13
ITM 2z 2,12
ITM 2z 2,11
ITM 2z 2,10
ITM 2z 2,9
ITM 2z 2,8
ITM 2z 2,7
ITM 2z 2,6
ITM 2z 2,5
ITM 2z 2,4
ITM 2z 2,3
ITM 2z 2,2
ITM 2z 3,2
ITM 2z 4,2
ITM 2z 5,2
ITM 2z 6,2
ITM 2z 7,2
ITM 2z 7,3
ITM 2z 6,5
ITM 2z 7,5
ITM 2z 8,5
ITM 2z 8,3
ITM 2z 9,3
ITM 2z 10,3
ITM 2z 11,3
ITM 2z 9,5
ITM 2z 10,5
ITM 2z 11,5
ITM 2z 12,5
ITM 2z 13,5
ITM 2z 13,4
ITM 2z 13,3
ITM 2z 5,5
ITM 2z 5,4
ITM 2z 4,4
ITM 2z 4,5
ITM 2z 4,6
ITM 2z 4,7
ITM 2z 4,8
ITM 2z 4,9
ITM 2z 4,10
ITM 2z 4,11
ITM 2z 5,11
ITM 2z 6,11
ITM 2z 7,11
ITM 2z 8,11
ITM 2z 9,11
ITM 2z 10,11
ITM 2z 11,11
ITM 2z 11,12
ITM 2z 11,13
ITM 2z 10,13
PAL e

ROOM 1d
hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,ht,ht,ht,ht,ht,ht
hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,ht,ht,ht,ht,ht,ht
hp,hp,hr,hr,hr,hr,hr,hr,hp,hp,ht,ht,hr,hr,ht,ht
hp,hp,hr,hr,hr,hr,hr,hr,hp,hp,ht,ht,hr,hr,ht,ht
hp,hp,hr,hr,hs,hs,hr,hr,hr,hr,hr,hr,hr,hr,ht,ht
hp,hp,hr,hr,hs,hs,hr,hr,hr,hr,hr,hr,hr,hr,ht,ht
hp,hp,hr,hr,0,0,ht,ht,ht,ht,ht,ht,ht,ht,ht,ht
hp,hp,hr,hr,0,0,ht,ht,ht,ht,ht,ht,ht,ht,ht,ht
hp,hp,hr,hr,0,0,ht,ht,hq,hq,hq,hq,hq,hq,hq,hq
hp,hp,hr,hr,0,0,ht,ht,hq,hq,hq,hq,hq,hq,hq,hq
hp,hp,hr,hr,hs,hs,ht,ht,ht,ht,hp,hp,hp,hp,hq,hq
hp,hp,hr,hr,hs,hs,ht,ht,ht,ht,hp,hp,hp,hp,hq,hq
hp,hp,hr,hr,hr,hr,hr,hr,hr,hr,hr,hr,hp,hp,hq,hq
hp,hp,hr,hr,hr,hr,hr,hr,hr,hr,hr,hr,hp,hp,hq,hq
hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hq,hq
hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hp,hq,hq
NAME green flow
ITM 2t 5,6
ITM 2u 5,7
ITM 2v 5,8
ITM 2w 5,9
ITM 2x 5,10
ITM 2z 6,5
ITM 2z 6,6
ITM 2z 6,7
ITM 2z 6,8
ITM 2z 6,10
ITM 2z 6,9
ITM 2z 4,10
ITM 2z 4,8
ITM 2z 4,9
ITM 2z 4,7
ITM 2z 4,6
ITM 2z 4,5
ITM 2z 4,4
ITM 2z 5,4
ITM 2z 6,4
PAL g

TIL 1
00000000
00000000
00000000
01110000
00011111
00110011
00000001
11110101
NAME  1

TIL 2
01000000
00101011
01101000
00010011
01001011
00000001
00000101
00111101
NAME  2

TIL 3
01100111
11111111
01010111
00011001
01000011
00011011
01011111
01011111
NAME  3

TIL 4
01111111
10111111
11110111
01110111
11101111
11111111
00011111
11011111
NAME  4

TIL 5
00000000
01001011
01110011
01001010
00101011
00001000
00001010
01110101
NAME  5

TIL 6
01000101
00100111
00110011
00011101
01010011
01001111
01011011
00111111
NAME  6

TIL 7
01110111
11101111
00111111
01111111
01110011
00011111
01111111
11111111
NAME  7

TIL 8
00000001
01010111
01011101
11010010
00110000
00000000
00000000
00000000
NAME  8

TIL 9
00000000
00000000
00010010
00000000
00000110
00001000
00000000
01100001
NAME  9

TIL 10
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10010011
NAME hallway 14

TIL 11
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000001
NAME hallway 15

TIL 12
11111011
11110011
11110111
11101111
11011111
11111111
11111111
00000000
NAME hallway 16

TIL 13
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00100000
NAME hallway 17

TIL 14
11111111
11111110
11111101
11111101
11111011
11110111
11110111
11100000
NAME hallway 18

TIL 15
01111111
11111111
11111111
11111111
11111111
11111111
11111111
10010001
NAME hallway 19

TIL 16
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000111
NAME hallway 20

TIL 17
11111111
11111110
11111111
11111001
11111011
11110111
11111111
10000001
NAME hallway 21

TIL 18
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11110000
NAME hallway 22

TIL 19
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01100001
NAME hallway 23

TIL 20
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME hallway 50

TIL 21
11111011
11110111
11111111
11111111
11011111
10111111
00111111
01111111
NAME hallway 51

TIL 22
11111111
11111111
11101111
11111111
11011111
10111111
00111111
01111111
NAME hallway 52

TIL 23
11111011
11110111
11101111
11011111
11111111
11111111
00111111
01111111
NAME hallway 53

TIL 24
11111011
11110111
11101111
11001111
11111111
10111111
00111111
01111111
NAME hallway 54

TIL 25
11111011
11110111
11101111
11111111
11111111
11111111
00111111
01111111
NAME hallway 55

TIL 26
00000111
00000111
00001111
00011111
00011111
00111111
01111111
00000000
NAME hallway ends 2

TIL 27
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10000100
NAME hallway ends 3

TIL 28
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01000000
NAME hallway ends 4

TIL 29
11110111
11100111
11101111
11011111
10011111
10111111
01111111
00100010
NAME hallway ends 5

TIL 30
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME hallway ends 32
WAL true

TIL 31
00001111
00001111
00011111
00111111
01111111
01111111
11111111
00000010
NAME hallway ends 33

TIL 32
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00011000
NAME hallway ends 34

TIL 33
11111111
11111111
11111111
11111111
11111111
11111111
11111110
10000000
NAME hallway ends 35

TIL 34
11101111
11111111
11111111
10111111
01111111
01111111
11111111
00011100
NAME hallway ends 36

TIL 35
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01100000
NAME hallway ends 37

TIL 36
11111111
11111111
11111111
11111111
11111111
11111111
11111110
00100000
NAME hallway ends 38

TIL 37
11111111
11101111
11111111
10111111
01111111
01111111
11111111
01010011
NAME hallway ends 39

TIL 38
00000001
00000011
00000111
00000111
00001111
00011111
00011111
00000000
NAME hallway ends 40

TIL 39
11111101
11111011
11110111
11101111
11111111
11111111
10111111
01110000
NAME hallway ends 41

TIL 40
11111011
11110011
11110111
11101111
11001111
11011111
10111111
01111000
NAME hallway ends 68

TIL 41
11111011
11111011
11110111
11101111
11001111
11011111
11111111
00101111
NAME hallway ends 69

TIL 42
11111011
11110011
11110111
11101111
11001111
11011111
11111111
11111000
NAME hallway ends 70

TIL 43
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10011111
NAME hallway ends 71

TIL 44
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00010001
NAME hallway ends 72

TIL 45
11111011
11110011
11110111
11111111
11011111
11011111
10111111
00010000
NAME hallway ends 73

TIL 46
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10101001
NAME hallway ends 74

TIL 47
11111111
11111110
11111101
11111001
11111011
11111111
11110111
01100001
NAME hallway ends 75

TIL 48
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11000001
NAME hallway ends 76

TIL 49
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11110100
NAME hallway ends 77

TIL 50
11000000
10000000
00000000
11110111
11110111
11110111
11110111
00000111
NAME almost kitchen 8
WAL true

TIL 51
00000000
00000000
00000000
11111111
11111111
11111111
11111111
11111111
NAME almost kitchen 9

TIL 52
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01000011
NAME almost kitchen 10

TIL 53
11100111
11101111
11111111
10111111
00111111
01111111
11111111
00011000
NAME almost kitchen 11

TIL 54
11111111
11101111
11001111
10111111
11111111
11111111
01111111
11011100
NAME almost kitchen 12

TIL 55
11110111
11110111
11110111
11110111
11110111
11110111
11110111
10010000
NAME almost kitchen 13
WAL true

TIL 56
11111111
11111001
11111011
11110111
11100111
11101111
11111111
00100000
NAME almost kitchen 14

TIL 57
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10011100
NAME almost kitchen 15

TIL 58
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11101000
NAME almost kitchen 16

TIL 59
11111110
11111100
11111111
11111111
11111111
11101111
11011111
01111000
NAME almost kitchen 17

TIL 60
11111000
11110000
11100000
11000000
11000000
10000000
00000000
00000000
NAME almost kitchen 44
WAL true

TIL 61
00000000
00000000
00000001
00000011
00000011
00000111
00001111
00001111
NAME almost kitchen 45

TIL 62
01110111
11110111
11110111
11110110
11110110
11110101
11110001
11110011
NAME almost kitchen 46
WAL false

TIL 63
11011111
10110111
01101111
01111111
11011111
10111111
10111111
11111111
NAME almost kitchen 47

TIL 64
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME random wall ignore
WAL true

TIL 65
00000000
00000000
00011000
00011000
00100100
01000010
01000010
00100100
NAME finally kitchen 1

TIL 66
00011000
00000000
00000000
00000000
00000000
00000000
00000001
00000001
NAME finally kitchen 2

TIL 67
00000000
00000000
00000000
00000000
00000111
00000101
00000001
11111111
NAME finally kitchen 3

TIL 68
00000000
00001111
00010000
00110000
00100000
01000000
11000000
10000000
NAME finally kitchen 4

TIL 69
00000001
11111111
00000001
00000011
00000010
00000100
00001100
00011000
NAME finally kitchen 5

TIL 70
00000000
00000010
00000110
00001110
00001110
00011110
00111110
00111110
NAME finally kitchen 32
WAL false

TIL 71
11111101
11111100
11111100
11111101
11111001
11110010
11100100
11001100
NAME finally kitchen 33
WAL true

TIL 72
01101111
11011111
10111111
00111111
01111111
11111111
11111111
00000000
NAME finally kitchen 34

TIL 73
11111111
11111111
11111111
11111111
11111111
11111110
11111100
00000000
NAME finally kitchen 35

TIL 74
11101111
11011111
10111111
00111111
01111111
11111111
11111111
00000000
NAME finally kitchen 36

TIL 75
11111111
11111111
11111111
11111111
11111110
11111110
11111100
00000000
NAME finally kitchen 37
WAL false

TIL 76
00000000
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME finally kitchen 38
WAL false

TIL 77
00000000
11111111
00010001
00100000
11100000
01111011
00011111
00000000
NAME finally kitchen 39

TIL 78
01111110
01111110
01111110
01111110
01111110
01111110
01111100
01111001
NAME finally kitchen 40
WAL true

TIL 79
11011011
10010011
10110111
00101111
01011111
11011111
10111111
00000000
NAME finally kitchen 41
WAL false

TIL 80
00000000
11100000
10100000
10100001
00011110
00011110
11111110
11111110
NAME bedroom 12

TIL 81
00000000
00000000
00000000
11111000
11110111
11110111
00000111
01110011
NAME bedroom 13

TIL 82
00000001
00000001
00000001
00000001
11110001
11110001
11111001
11111001
NAME bedroom 14

TIL 83
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000000
NAME bedroom 15

TIL 84
11100000
11100000
11100000
11100000
11100000
11100000
11100000
00000000
NAME bedroom 16

TIL 85
00001001
00001000
00001000
00001000
00001000
00001000
00001000
00001000
NAME bedroom 17

TIL 86
11111111
11111111
11111111
01111111
01000000
01000000
01000000
01000000
NAME bedroom 18

TIL 87
00000011
11111111
11111111
11111111
00000000
01111110
01000010
01000010
NAME bedroom 19

TIL 88
11111100
11111110
11111111
11111111
00010001
00010001
00010001
00010001
NAME bedroom 20

TIL 89
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000011
NAME bedroom 21

TIL 90
11111111
11111111
10110000
10110110
00110110
10110110
10110000
11111111
NAME phone page 1 6

TIL 91
11111111
11111111
11000111
11010011
11011011
11010011
11000111
11111111
NAME phone page 1 7

TIL 92
11111111
11111111
00011111
01111111
00011111
11011111
00011111
11111111
NAME phone page 1 8

TIL 93
11111111
11111111
01111111
01011111
00011111
11011111
11011111
11111111
NAME phone page 1 9

TIL 94
11111111
11111111
11111111
11111111
11111111
11011111
10101111
01110111
NAME phone page 1 10

TIL 95
11111111
11111100
11111111
11111111
11111111
11111111
11111111
00000000
NAME phone page 1 11

TIL 96
11111111
00000011
11111111
11111111
11111111
11111111
11111111
00000000
NAME phone page 1 12

TIL 97
01111101
01111101
01111101
01111101
00001100
11111111
11111111
00000000
NAME phone page 1 13

TIL 98
10110000
10110111
10110111
10110111
00110000
11111111
11111111
00000000
NAME phone page 1 14

TIL 99
11011000
11011010
11011011
11011010
11011000
11111111
11111111
00000000
NAME phone page 1 15

TIL b
00000000
00000000
01100000
00000101
10010010
00001010
00000001
00010001
NAME  10

TIL c
00000000
00000000
00000000
00000000
00000000
00110000
10001011
01100111
NAME  11

TIL d
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01110000
NAME  12

TIL e
00000000
00010001
00000001
00000000
00001011
00000000
01000001
01100010
NAME  13

TIL f
00000000
00100001
00010011
00000000
00000100
00001011
00000101
00100010
NAME  14

TIL g
00000000
00001001
00000001
00100000
00000000
00001000
00000001
00001000
NAME  15

TIL h
00000000
00100111
00010010
00000000
00000000
00100000
01000100
00000111
NAME  16

TIL i
00000000
00001101
00000000
00000101
00010001
01001000
00001011
00000000
NAME  17

TIL j
00000001
00000001
01001100
00000100
01000011
00000000
00000000
00000000
NAME  18

TIL k
00110001
00111111
01110000
00000000
00000000
00000000
00000000
00000000
NAME  19

TIL l
11110000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME  20

TIL m
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME black wall
WAL true

TIL n
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME hallway 1
WAL true

TIL o
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000110
NAME hallway 2

TIL p
00001111
00111111
00111111
11111111
11111111
11111111
11111111
11111111
NAME hallway 3
WAL true

TIL q
00000011
00000011
00000111
00001111
00001111
00011111
00111111
00000010
NAME hallway 4

TIL r
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00001000
NAME hallway 5

TIL s
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10000001
NAME hallway 6

TIL t
11111011
11110011
11110111
11101111
11001111
11011111
11111111
01000000
NAME hallway 7

TIL u
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00011100
NAME hallway 8

TIL v
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00101000
NAME hallway 9

TIL w
11111111
11110111
11110111
11101111
11001111
11011111
11111111
10101100
NAME hallway 10

TIL x
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00010000
NAME hallway 11

TIL y
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10001000
NAME hallway 12

TIL z
11111011
11110011
11110111
11101111
11101111
11111111
10111111
00010000
NAME hallway 13

TIL 1a
11111111
11111111
11111101
11111001
11111111
11110111
11101111
01111010
NAME hallway 24

TIL 1b
01111111
11111111
11111111
11111111
11111111
11111111
11111111
01111110
NAME hallway 25

TIL 1c
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01001100
NAME hallway 26

TIL 1d
11111111
11111111
11111101
11111001
11111011
11111111
11111111
01111111
NAME hallway 27

TIL 1e
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11111110
NAME hallway 28

TIL 1f
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00110000
NAME hallway 29

TIL 1g
11111111
11111110
11111111
11111111
11111011
11111111
11101111
00001010
NAME hallway 30

TIL 1h
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11111010
NAME hallway 31

TIL 1i
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME hallway 32
WAL false

TIL 1j
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000000
NAME hallway 33
WAL true

TIL 1k
11011111
10011111
10111111
01111111
11111111
11111111
11111111
00000111
NAME hallway 34

TIL 1l
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11100011
NAME hallway 35

TIL 1m
11111111
11111111
11111111
11111111
11111110
11111111
11111101
00000010
NAME hallway 36

TIL 1n
11011111
11111111
11111111
11111111
11111111
11111111
11111111
00011111
NAME hallway 37

TIL 1o
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000100
NAME hallway 38

TIL 1p
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10000010
NAME hallway 39

TIL 1q
11111111
10111111
10111111
01111111
11111111
11111111
11111111
00011010
NAME hallway 40

TIL 1r
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00010111
NAME hallway 41

TIL 1s
11111111
11111111
11111111
11111111
11111111
11111110
11111111
11110001
NAME hallway 42

TIL 1t
11011111
11111111
10111111
11111111
11111111
11111111
11111111
10000100
NAME hallway 43

TIL 1u
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00001111
NAME hallway 44

TIL 1v
11111111
11111111
11111111
11111111
11111110
11111111
11111101
11000000
NAME hallway 45

TIL 1w
11011111
10011111
10111111
01111111
11111111
11111111
11111111
00000011
NAME hallway 46

TIL 1x
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01001111
NAME hallway 47

TIL 1y
11111111
11111111
11111111
11111111
11111110
11111110
11111101
11000000
NAME hallway 48

TIL 1z
00000011
00000111
00001111
00001111
00011111
00111111
00111111
01111111
NAME hallway 49

TIL a
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME hallway ends 1
WAL true

TIL 2a
00000000
00000001
00000011
00000011
00000111
00001111
00001111
00000000
NAME hallway ends 6

TIL 2b
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11100000
NAME hallway ends 7

TIL 2c
11111110
11111101
11111111
11111111
11111111
11101111
11001111
10010000
NAME hallway ends 8

TIL 2d
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000000
NAME hallway ends 9
WAL true

TIL 2e
00111111
00111111
01111111
11111111
11111111
11111111
11111111
00000101
NAME hallway ends 10

TIL 2f
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00110011
NAME hallway ends 11

TIL 2g
11111111
11111111
11111111
11111111
11111110
11111101
11111111
01010111
NAME hallway ends 12

TIL 2h
10111111
11111111
11111111
11111111
11111111
11111111
11111111
11111010
NAME hallway ends 13

TIL 2i
00000111
00001111
00011111
00011111
00111111
01111111
01111111
00000000
NAME hallway ends 14

TIL 2j
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01101000
NAME hallway ends 15

TIL 2k
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00110111
NAME hallway ends 16

TIL 2l
11111111
11111111
11111111
10111111
11111111
11111111
01111111
11000100
NAME hallway ends 17

TIL 2m
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01100100
NAME hallway ends 18

TIL 2n
11111111
11111111
11111111
11111111
11111111
11111111
11111110
00000000
NAME hallway ends 19

TIL 2o
00000001
00000001
00000011
00000111
00001111
00001111
00011111
00000100
NAME hallway ends 20

TIL 2p
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00011110
NAME hallway ends 21

TIL 2q
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10100100
NAME hallway ends 22

TIL 2r
11111101
11111001
11111011
11110111
11101111
11111111
11111111
00011001
NAME hallway ends 23

TIL 2s
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10010100
NAME hallway ends 24

TIL 2t
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000110
NAME hallway ends 25

TIL 2u
11111101
11111001
11111011
11110111
11100111
11101111
11011111
00000000
NAME hallway ends 26

TIL 2v
00000000
00000000
00000000
00000000
00000001
00000011
00000011
00000000
NAME hallway ends 27
WAL true

TIL 2w
00111111
01111111
11111111
11111111
11111111
11111111
11111111
00111000
NAME hallway ends 28

TIL 2x
11111111
11111111
11111110
11111100
11111111
11111011
11110011
00100000
NAME hallway ends 29

TIL 2y
10111111
01111111
11111111
11111111
11111111
11111111
11111111
00001000
NAME hallway ends 30

TIL 2z
11111111
11111111
11111111
11111111
11111101
11111111
11111111
00011101
NAME hallway ends 31

TIL 3a
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01101001
NAME hallway ends 42

TIL 3b
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01000100
NAME hallway ends 43

TIL 3c
11111101
11111011
11110111
11110111
11101111
11111111
10111111
00100010
NAME hallway ends 44

TIL 3d
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10000000
NAME hallway ends 45

TIL 3e
00000000
00000000
00000000
00000001
00000011
00000011
00000111
00001000
NAME hallway ends 46
WAL true

TIL 3f
01111111
01111111
11111111
11111111
11111111
11111111
11111111
00100001
NAME hallway ends 47

TIL 3g
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10001111
NAME hallway ends 48

TIL 3h
11111111
11111111
11111110
11111101
11111011
11111011
11110111
11000001
NAME hallway ends 49

TIL 3i
11111111
01111111
11111111
11111111
11111111
11111111
11111111
10000110
NAME hallway ends 50

TIL 3j
11111111
11111111
11111110
11111111
11111001
11111011
11110111
11000111
NAME hallway ends 51

TIL 3k
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00010101
NAME hallway ends 52

TIL 3l
11111111
11111110
11111110
11111101
11111011
11111011
11110111
11100000
NAME hallway ends 53

TIL 3m
00001111
00011111
00111111
00111111
01111111
11111111
11111111
00000000
NAME hallway ends 54

TIL 3n
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01000101
NAME hallway ends 55

TIL 3o
11111111
11111111
11111111
11111111
11111111
11111110
11111100
00010000
NAME hallway ends 56

TIL 3p
11111111
11011111
11111111
00111111
11111111
11111111
11111111
00000011
NAME hallway ends 57

TIL 3q
11111111
11111111
11111111
11111111
11111111
11111111
11111110
10010001
NAME hallway ends 58

TIL 3r
11111111
11111111
10111111
00111111
01111111
11111111
11111111
00010000
NAME hallway ends 59

TIL 3s
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00111100
NAME hallway ends 60

TIL 3t
11111111
11111111
11111111
11111111
11111111
11111111
11111101
11110101
NAME hallway ends 61

TIL 3u
11101111
11011111
10111111
10111111
01111111
11111111
11111111
00001000
NAME hallway ends 62

TIL 3v
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00011111
NAME hallway ends 63

TIL 3w
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00001100
NAME hallway ends 64

TIL 3x
11111011
11110011
11110111
11101111
11001111
11011111
11111111
00011100
NAME hallway ends 65

TIL 3y
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00101011
NAME hallway ends 66

TIL 3z
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00001101
NAME hallway ends 67

TIL 4a
11111111
11111110
11111101
11111001
11111011
11110111
11110111
10010101
NAME hallway ends 78

TIL 4b
11111111
11111110
11111101
11111001
11111011
11110111
11111111
01101010
NAME hallway ends 79

TIL 4c
11111111
11111110
11111101
11111001
11111011
11110111
11100111
01111111
NAME hallway ends 80

TIL 4d
11111111
11111110
11111101
11111001
11111011
11110111
11111111
00011010
NAME hallway ends 81

TIL 4e
11111111
11111111
11111111
11111111
11111110
11111110
11111101
00000100
NAME hallway ends 82

TIL 4f
11111111
11111111
10111111
01111111
11111111
11111111
11111111
01011001
NAME hallway ends 83

TIL 4g
11111111
11111111
11111111
11111111
11111110
11111111
11111111
01111110
NAME hallway ends 84

TIL 4h
11011111
10111111
11111111
11111111
11111111
11111111
11111111
00011111
NAME hallway ends 85

TIL 4i
11111111
11111111
11111111
11111111
11111110
11111110
11111101
10000010
NAME hallway ends 86

TIL 4j
11011111
11011111
10111111
01111111
11111111
11111111
11111111
00111010
NAME hallway ends 87

TIL 4k
11111111
11111111
11111111
11111111
11111110
11111111
11111101
11110011
NAME hallway ends 88

TIL 4l
11111111
10011111
10111111
01111111
11111111
11111111
11111111
10000100
NAME hallway ends 89

TIL 4m
11111111
11111111
11111111
11111111
11111110
11111110
11111101
11000111
NAME hallway ends 90

TIL 4n
11111111
11011111
10111111
01111111
11111111
11111111
11111111
00000011
NAME hallway ends 91

TIL 4o
11111011
11110111
11111111
11001111
11011111
10111111
11111111
01111111
NAME hallway ends 92

TIL 4p
11111011
11110111
11101111
11111111
11111111
10111111
00111111
01111111
NAME hallway ends 93
WAL false

TIL 4q
11111011
11110111
11101111
11001111
11011111
11111111
00111111
01111111
NAME hallway ends 94

TIL 4r
11111011
11110111
11101111
11001111
11011111
10111111
00111111
01111111
NAME hallway ends 95

TIL 4s
00100000
00100000
00100000
00100000
00100000
00100000
00100000
00100000
NAME hallway ends 96
WAL true

TIL 4t
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME almost kitchen 1

TIL 4u
00000000
00000001
00000010
00000110
00000100
00001000
00011000
00010000
NAME almost kitchen 2

TIL 4v
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME almost kitchen 3

TIL 4w
11111111
11111111
11111111
11111111
11111111
11101111
11111111
00000100
NAME almost kitchen 4

TIL 4x
11111111
11111111
11111111
11111111
11111100
11111101
11111011
00100000
NAME almost kitchen 5

TIL 4y
11111111
11111111
01111111
11111111
11111111
11111111
11111111
00000101
NAME almost kitchen 6

TIL 4z
11111111
11111111
11111111
11111111
11111110
11111111
11111101
01010011
NAME almost kitchen 7

TIL 5a
11111111
11111111
11111110
11111100
11111111
11111011
11110111
00100000
NAME almost kitchen 18
WAL false

TIL 5b
10111111
01111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME almost kitchen 19

TIL 5c
11111111
11111111
11111111
11111110
11111100
11111111
11111111
00000000
NAME almost kitchen 20
WAL false

TIL 5d
11111111
01111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME almost kitchen 21
WAL false

TIL 5e
11100000
11000000
11000000
10000000
00000000
00000000
00000000
00000000
NAME almost kitchen 22
WAL true

TIL 5f
00000000
00000000
00011111
01111111
00011111
11100000
01111111
00011111
NAME almost kitchen 23
WAL true
COL 3

TIL 5g
00000000
00000000
00000000
11000000
00100000
11100000
11000000
00000000
NAME almost kitchen 24
WAL true
COL 3

TIL 5h
11111100
11111000
11110000
11101111
11111111
11111111
10111111
01110000
NAME almost kitchen 25
WAL true

TIL 5i
00000000
00000000
00000000
01111111
01111111
01111111
01111111
01111111
NAME almost kitchen 26

TIL 5j
00000000
00000000
00000000
11110000
11100000
11000000
10000000
10000000
NAME almost kitchen 27
WAL false

TIL 5k
01111111
01111111
01111111
01111111
01111111
01111111
01111111
00000000
NAME almost kitchen 28
WAL true

TIL 5l
11111111
11111110
11111110
11111100
11111000
11111000
11110000
00000000
NAME almost kitchen 29
WAL false

TIL 5m
11111111
11111111
11111111
11111111
11111111
11111110
11111100
00111100
NAME almost kitchen 30
WAL true

TIL 5n
11100000
11000000
10000000
10000000
00000000
00000000
00000000
00000000
NAME almost kitchen 31
WAL true

TIL 5o
11111000
11110000
11110000
11100000
11000000
11000000
10000000
00000000
NAME almost kitchen 32
WAL true

TIL 5p
00000000
00000000
00011000
00011000
00110100
01111010
01111110
00111100
NAME almost kitchen 33
COL 4

TIL 5q
00000000
00000000
00000000
00000001
00000011
00000011
00000111
00001111
NAME almost kitchen 34
WAL false

TIL 5r
11111111
11111110
11111101
11111001
11111011
11110111
11100111
01111100
NAME almost kitchen 35

TIL 5s
01111111
11111111
11111111
11111111
11111111
11111111
11111111
00000110
NAME almost kitchen 36

TIL 5t
11111111
11111110
11111100
11111000
11111000
11110000
11100000
00100000
NAME almost kitchen 37
WAL true

TIL 5u
00011000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME almost kitchen 38
WAL false
COL 4

TIL 5v
00001111
00011111
00011111
01011111
01011111
11011111
11011111
11011111
NAME almost kitchen 39

TIL 5w
11111111
11111111
11111111
11111111
11111110
11111110
11111100
00001000
NAME almost kitchen 40
WAL true

TIL 5x
11000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME almost kitchen 41
WAL true

TIL 5y
00000011
00000111
00000111
00000111
00010111
00010111
00110111
01110111
NAME almost kitchen 42

TIL 5z
11011110
11011100
11011101
11011011
11010110
11010110
11001111
11011100
NAME almost kitchen 43
WAL false

TIL 6a
00000000
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME finally kitchen 6

TIL 6b
00000000
11111000
00001000
00110000
00100000
01000000
11000000
10000000
NAME finally kitchen 7

TIL 6c
00000000
00000000
00000000
11101111
11101111
11101111
11101111
11101111
NAME finally kitchen 8

TIL 6d
00000000
00000000
00000000
11011111
11011111
11011111
11011111
11011111
NAME finally kitchen 9

TIL 6e
00000001
00000000
00000000
10111111
10111111
10111111
10111111
10111111
NAME finally kitchen 10

TIL 6f
11111111
00000000
00000000
11111111
11111111
11111111
11111111
11111111
NAME finally kitchen 11

TIL 6g
11111111
00000000
00000000
11111011
11111011
11111011
11111011
11111011
NAME finally kitchen 12

TIL 6h
10000000
00000000
00000000
11111111
11111111
11111111
11111111
11111111
NAME finally kitchen 13

TIL 6i
11101111
11101111
11101111
11101111
11101111
11101111
11101111
00000000
NAME finally kitchen 14
WAL true

TIL 6j
11011111
11011111
11011111
11011111
11011111
11011111
11011111
00000000
NAME finally kitchen 15
WAL true

TIL 6k
10111111
10111111
10111111
10111111
10111111
10111111
10111111
00000000
NAME finally kitchen 16
WAL true

TIL 6l
11111011
11111011
11111011
11111011
11111011
11111011
11111011
00000000
NAME finally kitchen 17
WAL true

TIL 6m
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00011001
NAME finally kitchen 18

TIL 6n
11111101
11111001
11111011
11110111
11101111
11101111
11011111
10000000
NAME finally kitchen 19

TIL 6o
11111101
11111001
11111011
11110111
11101111
11101111
11011111
00000000
NAME finally kitchen 20

TIL 6p
11111111
11111111
11111110
11111100
11111101
11111011
11110011
00000000
NAME finally kitchen 21

TIL 6q
00000001
00000011
00000111
00000111
00000111
00010111
00010111
00110000
NAME finally kitchen 22
WAL true

TIL 6r
11101111
11001111
11011111
10111111
01111111
01111111
11111111
00000000
NAME finally kitchen 23

TIL 6s
00000000
00000000
00000000
00000001
00000001
00000001
00000101
00000101
NAME finally kitchen 24
WAL false

TIL 6t
01110111
01110111
11110111
11110111
11110111
11110111
11110111
11110000
NAME finally kitchen 25
WAL true

TIL 6u
11111101
11111011
11110111
11100111
11101111
11011111
10011111
00000000
NAME finally kitchen 26

TIL 6v
00001101
00011101
00111101
00111101
01111101
11111101
11111101
11111101
NAME finally kitchen 27
WAL false

TIL 6w
11110111
11110110
11110110
11100101
11001011
11011011
10110111
00100000
NAME finally kitchen 28
WAL true

TIL 6x
01111111
01111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME finally kitchen 29
WAL false

TIL 6y
11111111
11111110
11111110
11111101
11111011
11111011
11110111
00000000
NAME finally kitchen 30

TIL 6z
11111111
11111110
11111100
11111000
11111000
11110000
11100000
00000000
NAME finally kitchen 31
WAL true

TIL 7a
11111011
11110011
11110111
11101111
11011111
11011111
10111111
00000000
NAME finally kitchen 42

TIL 7b
00000000
00000000
00000011
00001111
00000111
00000001
00000000
00000000
NAME finally kitchen 43

TIL 7c
00000000
11100000
10111000
00011110
10111100
11110000
00000000
00000000
NAME finally kitchen 44

TIL 7d
01111011
01110010
01100101
01001001
01011011
00110111
00100111
01100000
NAME finally kitchen 45
WAL true

TIL 7e
01111111
11111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME finally kitchen 46
WAL false

TIL 7f
11111111
11111110
11111101
11111001
11111011
11110111
11100111
00000000
NAME finally kitchen 47
WAL false

TIL 7g
11110111
11110111
11110111
11110111
11110111
11110111
11100111
00000111
NAME finally kitchen 48
WAL true

TIL 7h
11011110
11011100
11011101
11011011
11010110
11010110
11001101
11011000
NAME finally kitchen 49
WAL true

TIL 7i
01011111
10011111
10111111
01111111
11111111
11111111
11111111
00000000
NAME finally kitchen 50
WAL false

TIL 7j
11111111
11111111
11111111
11111111
11111110
11111110
11111101
00000000
NAME finally kitchen 51

TIL 7k
11011111
10011111
10111111
01111111
11111111
11111111
11111111
00000000
NAME finally kitchen 52

TIL 7l
11010111
10010111
10110111
01110111
11110111
11110111
11110111
00000000
NAME finally kitchen 53
WAL true

TIL 7m
11011011
10110111
01101111
01001111
11011111
10111111
00111111
01111111
NAME finally kitchen 54

TIL 7n
01110111
11110111
11110111
11110110
11110110
11110101
11110001
11110011
WAL true

TIL 7o
00100000
01010000
00100100
00001010
00100100
01010000
00100000
00000000
>
00000100
00001010
00100100
01010000
00100100
00001010
00000100
00000000

TIL 7p
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11100000
NAME bedroom 1

TIL 7q
00000000
00000000
00000000
00000001
00000001
00000001
00000001
00000001
NAME bedroom 2

TIL 7r
00000000
00000000
00000000
11100000
11100000
11100000
11100000
11100000
NAME bedroom 3

TIL 7s
00000000
00000000
00001111
00001000
00001011
00001010
00001010
00001010
NAME bedroom 4

TIL 7t
00000000
00000000
11111000
00001000
11101000
00101000
10101000
10101000
NAME bedroom 5

TIL 7u
01000000
01000000
01000000
01000000
01000000
01000000
01000000
11111111
NAME bedroom 6

TIL 7v
00100001
00100001
00100001
00100001
00100001
00100001
00100001
11100001
NAME bedroom 7

TIL 7w
11100000
11100000
11100000
11100000
11100000
00100000
11100000
11100000
NAME bedroom 8

TIL 7x
00001010
00001010
00001010
00001011
00001000
00001111
00000000
00000000
NAME bedroom 9

TIL 7y
10101000
10101000
00101000
11101000
00001000
11111000
00000000
00000000
NAME bedroom 10

TIL 7z
00000000
00000000
00000000
00000000
00001111
00001111
00001011
00001011
NAME bedroom 11

TIL 8a
10111111
10111111
10111110
10111110
10111110
10111110
10111110
11111111
NAME bedroom 22

TIL 8b
10111101
10111101
00111101
00111101
00111101
10000001
10110101
10111101
NAME bedroom 23

TIL 8c
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111111
NAME bedroom 24

TIL 8d
00000000
10000000
11000000
11000000
11100000
11110000
11110000
11111000
NAME bedroom 25

TIL 8e
00000000
00000000
00000000
00000000
00000000
00000000
10000000
11000000
NAME bedroom 26

TIL 8f
00000000
00000000
10000000
11000000
11000000
11100000
11110000
11111000
NAME bedroom 27

TIL 8g
00000011
00000001
00000001
00000000
00000000
00000000
00000000
00000000
NAME bedroom 28

TIL 8h
11111111
11111111
11111111
11111111
01111111
01111111
00111111
00011111
NAME bedroom 29

TIL 8i
10111101
10111101
11111111
11111111
11111111
11111111
11111111
11111111
NAME bedroom 30

TIL 8j
11111100
11111100
11111110
11111111
11111111
11111111
11111111
00000000
NAME bedroom 31

TIL 8k
10100000
10100000
10010000
10001000
10001100
10000100
00000100
00000100
NAME bedroom 32

TIL 8l
11111000
11111100
11111110
11111110
11111111
11111111
11111111
11111111
NAME bedroom 33

TIL 8m
00000000
00000000
00000000
00000000
00000000
10000000
10000000
11000000
NAME bedroom 34

TIL 8n
00011111
00001111
00000111
00000111
00000011
00000001
00000000
00000000
NAME bedroom 35

TIL 8o
11100000
11100000
11101000
11101000
11101100
11101110
11101110
11101111
NAME bedroom 36

TIL 8p
00011111
00001111
00000111
00000011
00000011
00000001
00000001
00000000
NAME bedroom 37

TIL 8q
00000100
10000100
11000100
11000100
11100100
11110010
11110010
00000011
NAME bedroom 38

TIL 8r
11100000
11100000
11110000
11111000
11111000
11111100
11111110
11111111
NAME bedroom 39

TIL 8s
01111111
00111111
00111111
00011111
00001111
00001111
00000111
00000011
NAME bedroom 40

TIL 8t
01111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME bedroom 41

TIL 8u
11111011
11111011
11111011
11111011
11111011
11111011
11111011
11111011
NAME bedroom 42

TIL 8v
11111111
11111111
11111111
11111111
11111111
11111100
11111111
11111100
NAME phone page 1 1

TIL 8w
11111111
11111111
11111111
11111111
11111111
00000011
11111111
00000011
NAME phone page 1 2

TIL 8x
11111111
11111111
00000001
01101101
01101101
01111101
01111101
11111111
NAME phone page 1 3

TIL 8y
11111111
11111111
10000110
10111111
10001111
10111111
10000111
11111111
NAME phone page 1 4

TIL 8z
11111111
11111111
00001101
10111101
10111100
10111101
10111101
11111111
NAME phone page 1 5

TIL 9a
11101100
01101111
01101111
01101111
11101111
11111111
11111111
00000000
NAME phone page 1 16

TIL 9b
00011011
01111011
01111000
01111111
01111000
11111111
11111111
00000000
NAME phone page 1 17

TIL 9c
01101110
01101110
01101111
01111101
01101110
11111111
11111111
00000000
NAME phone page 1 18

TIL 9d
11011111
11011111
11111111
11101111
00011111
11111111
11111111
00000000
NAME phone page 1 19

TIL 9e
10101111
11010111
11111011
11111101
11111111
11111111
11111111
00000000
NAME phone page 1 20

TIL 9f
11111111
01111100
01111101
01111101
01111100
01111100
01111101
01011101
NAME phone page 1 21

TIL 9g
11111111
00100001
10101111
10101111
00100011
11101111
01101111
10100001
NAME phone page 1 22

TIL 9h
11111111
00001011
01101011
01101011
00001011
01101011
01101011
01101000
NAME phone page 1 23

TIL 9i
11111111
11010000
11011101
11011101
11011101
11011101
11011101
01011101
NAME phone page 1 24

TIL 9j
11111111
01011011
11011011
11011011
11000011
11111011
11111011
11000011
NAME phone page 1 25

TIL 9k
11111111
11100001
11101111
11101111
11101111
11101111
11101111
11100001
NAME phone page 1 26

TIL 9l
11111111
01101000
01101011
01101011
00001000
01101011
01101011
01101000
NAME phone page 1 27

TIL 9m
11111111
01000010
11011110
11011110
11011110
11011110
11011110
01000010
NAME phone page 1 28

TIL 9n
11111111
11101000
11011011
10111011
01111000
10111111
11011111
11101000
NAME phone page 1 29

TIL 9o
11111111
01111111
11111111
11111111
01111111
01111111
01111111
01111111
NAME phone page 1 30

TIL 9p
11111111
11111111
11111111
11111111
11111111
11111111
10000000
11111111
NAME phone page 1 31

TIL 9q
11111111
11111111
11111111
11111111
11111111
10000001
00100100
11111111
NAME phone page 1 32

TIL 9r
11111111
11111111
11111111
11011111
10000011
00111001
11111100
11111110
NAME phone page 1 33

TIL 9s
11111111
11111111
11111111
11111111
11111111
11100011
10011001
01111100
NAME phone page 1 34

TIL 9t
11111111
11111111
11111111
11111111
11111111
11111111
11111001
00000100
NAME phone page 1 35

TIL 9u
11111111
11111111
11111111
11111111
11111111
11100001
11011100
00111110
NAME phone page 1 36

TIL 9v
11111111
11111111
11111111
11111111
11111111
11000111
00111011
11111100
NAME phone page 1 37

TIL 9w
11111111
11111111
11111111
11111000
11110111
11101111
10011111
01111111
NAME phone page 1 38

TIL 9x
11111111
11111111
11111111
00111111
10001111
11101111
11110110
11111001
NAME phone page 1 39

TIL 9y
11111111
11111111
11111111
11111111
10000111
01111011
11111010
11111100
NAME phone page 1 40

TIL 9z
11111111
11111111
11111111
11111111
11111100
11110000
10001111
11111111
NAME phone page 1 41

TIL a0
11111111
11111111
11111111
11111111
11111111
00001111
11100000
11111111
NAME phone page 1 42

TIL a1
11111111
11111111
11111111
11111111
11111111
11111111
00011111
11100000
NAME phone page 1 43

TIL a2
11111111
11111111
11111111
11111111
11111111
11111111
11111000
00000011
NAME phone page 1 44

TIL a3
11111111
11111111
11111111
11111111
11111111
11111000
00000111
11111111
NAME phone page 1 45

TIL a4
11111111
11111111
11111111
11111111
10001111
01100000
11111111
11111111
NAME phone page 1 46

TIL a5
11111111
11111111
11111111
11111111
11111111
01110000
00001111
11111111
NAME phone page 1 47

TIL a6
11111111
11111111
11111111
11111111
11111111
00000000
11111111
11111111
NAME phone page 1 48

TIL a7
11111111
11111111
11111111
11111111
11111111
00000111
11110000
11111111
NAME phone page 1 49

TIL a8
11111111
11111111
11111111
11111111
11111111
11111111
00000011
11111111
NAME phone page 1 50

TIL a9
11111111
11111111
11111111
11111111
11111111
11000000
10111111
11111111
NAME phone page 1 51

TIL aa
11111111
11111111
11111111
11111111
11100011
00011000
11111110
11111111
NAME phone page 1 52

TIL ab
11111111
11111111
11111111
11111111
11111111
11111111
00001100
11100011
NAME phone page 1 53

TIL ac
11111111
11111111
11111111
11100011
10011000
01111111
11111111
11111111
NAME phone page 1 54

TIL ad
11111111
11111111
11111111
11111111
01111111
00111111
10000111
11111000
NAME phone page 1 55

TIL ae
11111111
11111111
11111111
11111111
11111100
11110011
11101111
00011111
NAME phone page 1 56

TIL af
11111111
11111111
11111111
11100011
00011100
01111100
11111111
11111111
NAME phone page 1 57

TIL ag
11111111
11111111
11111111
00011111
01000011
11111000
11111111
11111111
NAME phone page 1 58

TIL ah
11111111
11111111
11111111
11111111
11111111
00000100
11111000
11111111
NAME phone page 1 59

TIL ai
11111111
11111111
11111111
11111111
11111111
11100001
00001000
11111111
NAME phone page 1 60

TIL aj
11111111
11111111
11111111
11111111
11111111
11000111
10011011
11111000
NAME phone page 1 61

TIL ak
11111111
11111111
11111111
11111111
11000011
10111000
01111110
11111111
NAME phone page 1 62

TIL al
11111111
11111111
11111111
11111111
11111111
11111111
00000000
11111111
NAME phone page 1 63

TIL am
11111111
11111111
11111111
11111111
11111111
10000001
01111110
11111111
NAME phone page 1 64

TIL an
11111111
11111111
11111111
11111111
11111111
11110000
00001110
11111111
NAME phone page 1 65

TIL ao
11111111
11111111
11111111
11111111
11100001
11001110
00111111
11111111
NAME phone page 1 66

TIL ap
11111111
11111111
11111111
11111111
11111111
00011111
11000000
11111111
NAME phone page 1 67

TIL aq
11111111
11111111
11111111
11111111
11110011
11110000
00001110
11111111
NAME phone page 1 68

TIL ar
11111111
11111111
11111111
11111111
11111111
00100000
00011111
11111111
NAME phone page 1 69

TIL as
11111111
11111111
11111111
11111111
11111111
00000011
11111000
11111111
NAME phone page 1 70

TIL at
11111111
11111111
11111111
11111111
10000001
01111100
11111111
11111111
NAME phone page 1 71

TIL au
11111111
11111111
11111111
11111111
11011111
00001100
11110001
11111111
NAME phone page 1 72

TIL av
11111111
11111111
11111111
11111111
01111111
00111111
11010000
11001111
NAME phone page 1 73

TIL aw
11111111
11111111
11111111
11111111
11111111
00000110
11110001
11111011
NAME phone page 1 74

TIL ax
11111111
11111111
11111111
11000011
10100000
01111111
11111111
11111111
NAME phone page 1 75

TIL ay
11111111
11111111
11111111
11111111
00011111
11011110
11100001
11111111
NAME phone page 1 76

TIL az
11111111
11111111
11111111
11111111
11111111
00111100
11010011
11001111
NAME phone page 1 77

TIL b0
11111111
11111111
11111111
11011111
10001111
01110011
11111100
11111111
NAME phone page 1 78

TIL b1
11111111
11111111
11111111
11111110
11111101
11100011
00011011
11111111
NAME phone page 1 79

TIL b2
11111111
11111111
00111111
10000111
11100011
11111000
11111111
11111111
NAME phone page 1 80

TIL b3
11111111
00000111
11110111
11110111
00000111
01111111
01111111
00000101
NAME phone page 1 81

TIL b4
11111111
11011111
11011111
11011111
11011011
11011011
11011011
11000000
NAME phone page 1 82

TIL b5
11111111
01000001
01011101
01011101
01000001
01011101
01011101
01000001
NAME phone page 1 83

TIL b6
11111111
00000100
11011101
11011101
11011100
11011101
11011101
11011100
NAME phone page 1 84

TIL b7
11111111
00011111
11011111
11011111
00011111
11011111
11011111
00011111
NAME phone page 1 85

TIL b8
11111111
11111111
11111111
11111111
11111111
10001000
01100010
11111111
NAME phone page 1 86

TIL b9
11111111
11111111
11111111
11111111
11101111
00000010
11111001
11111111
NAME phone page 1 87

TIL ba
11111111
11111111
11111101
11111000
11100110
00011111
11111111
11111111
NAME phone page 1 88

TIL bb
11111111
11111111
11111111
00001111
01110000
11111111
11111111
11111111
NAME phone page 1 89

TIL bc
11111111
11111111
11111111
11111111
11111111
00111111
11000011
11111100
NAME phone page 1 90

TIL bd
11111111
11111111
11111111
11111111
11111110
11110001
11000111
00111111
NAME phone page 1 91

TIL be
11111111
11111111
11111111
11111111
00111111
11000011
11111100
11111111
NAME phone page 1 92

TIL bf
11111111
11111111
11111111
11111111
11111110
11110000
11100111
00011111
NAME phone page 1 93
WAL true

TIL bg
11111111
11111111
11111111
10011111
01100001
11111110
11111111
11111111
NAME phone page 1 94
WAL true

TIL bh
11111111
11111111
11111111
11111111
11111001
11100000
01011111
10111111
NAME phone page 1 95

TIL bi
11111111
11111111
11111111
11111111
11111111
11110000
00001011
11111111
NAME phone page 1 96

TIL bj
11111111
11111111
11111111
11111111
11100000
00000011
11111111
11111111
NAME phone page 1 97

TIL bk
11111111
11111111
11111111
11111101
11111000
00000011
11101111
11111111
NAME phone page 1 98

TIL bl
11111111
11111111
11111111
11111111
11111111
01111110
10011100
11000011
NAME phone page 1 99

TIL bm
11111111
11111111
11111111
11111111
11111111
00011000
11100011
11111111
NAME phone page 1 100

TIL bn
11111111
11111111
11111111
11111111
11111111
11111111
01110000
10000100
NAME phone page 1 101

TIL bo
11111111
11111111
11111111
11111111
11111111
11111111
10000000
01111110
NAME phone page 1 102
WAL true

TIL bp
11111111
11111111
11111111
11111111
11111111
11111111
11111100
00000010
NAME phone page 1 103
WAL true

TIL bq
11111111
11111111
11111111
11111111
11111111
11111111
10000000
00111001
NAME phone page 1 104

TIL br
11111111
11111111
11111111
11111111
11111111
11111111
00000111
11110000
NAME phone page 1 105

TIL bs
11111111
11111111
11111111
11111111
11111111
11000011
00011000
11111111
NAME phone page 1 106

TIL bt
11111111
11111111
11111111
11111111
11111111
00001000
01110111
11111111
NAME phone page 1 107

TIL bu
11111111
11111111
11111111
11111111
11111110
00000000
11111111
11111111
NAME phone page 1 108

TIL bv
11111111
11111111
11111111
10001111
00100000
11111110
11111111
11111111
NAME phone page 1 109

TIL bw
11111111
11111111
11111111
11111111
11111111
10000010
00111001
11111111
NAME phone page 1 110

TIL bx
11111111
11111111
11111111
11111111
11111000
00000010
11111111
11111111
NAME phone page 1 111

TIL by
11111111
11111111
11111111
11111000
11000111
00111111
11111111
11111111
NAME phone page 1 112

TIL bz
11111111
11111111
00000011
11111100
11111111
11111111
11111111
11111111
NAME phone page 1 113

TIL c0
11111111
11111111
11111111
01111111
10011111
11100011
11111100
11111111
NAME phone page 1 114

TIL c1
11111111
11111111
11111111
11111111
11111111
11111001
00000000
11111111
NAME phone page 1 115

TIL c2
11111111
11111111
11111111
11111111
11111111
11100100
00011011
11111111
NAME phone page 1 116

TIL c3
11111111
11111111
11111111
11111111
00000100
11110011
11111111
11111111
NAME phone page 1 117

TIL c4
11111111
11111111
11111111
11111100
01111001
10000111
11111111
11111111
NAME phone page 1 118

TIL c5
11111111
11111111
11111111
00000111
10010011
11111100
11111111
11111111
NAME phone page 1 119

TIL c6
11111111
11111111
11111111
11001111
10000111
01110000
11111111
11111111
NAME phone page 1 120

TIL c7
11111111
10110100
10110101
10010100
10010100
10100101
10100100
11111111
NAME phone page 1 121

TIL c8
11111111
00101111
11110110
01111001
01111001
11110110
00101111
11111111
NAME phone page 1 122

TIL c9
11111111
01000001
11110111
11110111
11110111
11110111
01110111
11111111
NAME phone page 1 123

TIL ca
11111111
10111111
10011111
10001111
10001111
10011111
10111111
11111111
NAME phone page 1 124

TIL cb
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME white wall
WAL true

TIL cc
11111111
11111111
11111111
11111111
10000000
10111111
11111111
11111111
NAME phone page 2 1

TIL cd
11111111
11111111
11111111
00011111
11100111
11110001
11111110
11111111
NAME phone page 2 2

TIL ce
11111111
11111111
11111111
11111111
11111111
11111110
00000001
11111111
NAME phone page 2 3

TIL cf
11111111
11111111
11111111
11111111
00011111
11100111
11110000
11111111
NAME phone page 2 4

TIL cg
11111111
11111111
11111111
11111111
11111111
10001100
01110011
11111111
NAME phone page 2 5

TIL ch
11111111
11111111
11111111
11111111
10001111
00110111
11111010
11111100
NAME phone page 2 6

TIL ci
11111111
11111110
11111100
11111011
11100111
00001111
01111111
11111111
NAME phone page 2 7

TIL cj
11111111
11111111
00111111
10011111
11011111
11101110
11101100
11110001
NAME phone page 2 8

TIL ck
11111111
11111111
11111111
11111111
00111111
00000000
11110101
11111111
NAME phone page 2 9

TIL cl
11111111
11111111
11001111
10100111
01110011
11111100
11111111
11111111
NAME phone page 2 10

TIL cm
11111111
00001111
11101111
11101111
10001111
11101111
11101111
00001011
NAME phone page 2 11

TIL cn
11111111
00000001
01101101
01101101
01111101
01111101
01111101
01111101
NAME phone page 2 12

TIL co
11111111
01011110
01011110
01011110
01011110
01011110
01011110
01000010
NAME phone page 2 13

TIL cp
11111111
00111111
10011111
11011111
11011111
11011111
10011111
00111111
NAME phone page 2 14

TIL cq
11111111
11111111
11111111
11110011
00001100
01111110
11111111
11111111
NAME phone page 2 15

TIL cr
11111111
11111111
11111111
11111111
10111111
00001110
11100000
11111111
NAME phone page 2 16

TIL cs
11111111
11111111
11111111
11111111
11111111
00000111
11111001
11111100
NAME phone page 2 17

TIL ct
11111111
11111111
11111111
11111111
11111001
11110000
11100111
00011111
NAME phone page 2 18

TIL cu
11111111
11111111
11111111
11111111
10011000
00000010
11111111
11111111
NAME phone page 2 19

TIL cv
11111111
11111111
11111111
11111111
11111111
01100001
00011110
11111111
NAME phone page 2 20

TIL cw
11111111
11111111
11111111
11111111
11111111
11111110
01000100
00010001
NAME phone page 2 21

TIL cx
11111111
11111111
11111111
11111111
00111111
01000000
11111111
11111111
NAME phone page 2 22

TIL cy
11111111
11111111
11111111
11111111
11111111
00000000
11001111
11111111
NAME phone page 2 23

TIL cz
11111111
11111111
11111111
11111111
11000111
00111001
11111100
11111111
NAME phone page 2 24

TIL d0
11111111
11111111
11111111
11111111
11111111
11111111
11111000
00000111
NAME phone page 2 25

TIL d1
11111111
11111111
11111111
11111111
11111111
11111100
11110001
00000111
NAME phone page 2 26

TIL d2
11111111
11111111
11111111
11111111
11111111
00111110
11001100
11110011
NAME phone page 2 27

TIL d3
11111111
11111111
11111111
11111111
11111111
00000111
11111000
11111111
NAME phone page 2 28

TIL d4
11111111
11111111
11111111
11111111
11111100
11000011
00111111
11111111
NAME phone page 2 29

TIL d5
11111111
11111111
11111111
00011100
11100000
11111111
11111111
11111111
NAME phone page 2 30

TIL d6
11111111
11111111
11111111
11111111
00111111
10011111
11100000
11111111
NAME phone page 2 31

TIL d7
11111111
11111111
11111111
11111111
10011111
00001111
11100001
11111100
NAME phone page 2 32

TIL d8
11111111
11111111
11111111
11111111
11111111
10000000
01111111
11111111
NAME phone page 2 33

TIL d9
11111111
11111111
11111111
11111111
11111111
00011110
11101100
11100011
NAME phone page 2 34

TIL da
11111111
11111111
11111111
11111111
10011111
01100111
11111001
11111100
NAME phone page 2 35

TIL db
11111111
11111111
11111111
11111111
11111111
11110000
11001110
00111111
NAME phone page 2 36

TIL dc
11111111
11111111
11111111
11111111
11111110
11111101
01110011
10001111
NAME phone page 2 37

TIL dd
11111111
11111111
11111111
11111111
00111111
10011111
11000000
11111111
NAME phone page 2 38

TIL de
11111111
11111111
11111111
11111111
11111111
11100000
00001001
11111111
NAME phone page 2 39

TIL df
11111111
11111111
11111111
11111111
11111111
00111111
10000000
11110011
NAME phone page 2 40

TIL dg
11111111
11111111
11111111
11111111
11111111
11111111
00000011
11111000
NAME phone page 2 41

TIL dh
11111111
11111111
11111111
11111111
11000011
00111001
01111100
11111111
NAME phone page 2 42

TIL di
11111111
11111111
11100011
11001001
11011110
10111111
01111111
11111111
NAME phone page 2 43

TIL dj
11111111
11111111
11111111
11111111
11111100
00000000
11111111
11111111
NAME phone page 2 44

TIL dk
11111111
11111111
11111111
11111111
11111111
00011100
11000001
11111111
NAME phone page 2 45

TIL dl
11111111
11111111
11111111
11111111
11111111
01100000
10000111
11111111
NAME phone page 2 46

TIL dm
11111111
11111111
11111111
11111111
00001111
01100000
11111111
11111111
NAME phone page 2 47

TIL dn
11111111
11111111
11111111
11111111
11111001
00100100
10011110
11111111
NAME phone page 2 48

TIL do
11111111
11111111
11111111
11111111
11111111
01111011
10000000
11111111
NAME phone page 2 49

TIL dp
11111111
01101111
01101111
01101111
00001111
11101111
11101111
11101011
NAME phone page 2 50

TIL dq
11111111
01111101
01111101
01111101
01111101
01101101
01101101
00000001
NAME phone page 2 51

TIL dr
11111111
11111111
11111111
11111111
11000111
00110111
11111000
11111111
NAME phone page 2 52

TIL ds
11111111
11111111
11111111
11111111
11100001
10001100
01111111
11111111
NAME phone page 2 53

TIL dt
11111111
11111111
11111111
11111111
11111111
01111111
10001111
11110000
NAME phone page 2 54

TIL du
11111111
11111111
11111111
11111111
11111111
11000111
00110000
01111111
NAME phone page 2 55

TIL dv
11111111
11111111
11111111
11111111
11011111
00001000
11110011
11111111
NAME phone page 2 56

TIL dw
11111111
11111111
11111111
11110001
10000110
01111111
11111111
11111111
NAME phone page 2 57

TIL dx
11111111
11111111
11111111
11111111
00110010
11000001
11111111
11111111
NAME phone page 2 58

TIL dy
11111111
11111111
11111111
10110011
00001101
11111110
11111111
11111111
NAME phone page 2 59

TIL dz
11111111
11111111
11111111
11111111
11000100
10010000
00111011
11111111
NAME phone page 2 60

TIL e0
00001111
00001111
00001111
00001111
00001111
00001111
00001111
00001111
NAME memory game 1

TIL e1
11111111
11111111
11111111
11111111
11111111
11111111
11111100
11111100
NAME memory game 2

TIL e2
11110000
11110000
11110000
11110000
11110000
11110000
11110000
11110000
NAME memory game 3

TIL e3
11111000
11110000
11110000
11100000
11100000
11000000
11111111
11111111
NAME memory game 4

TIL e4
01111111
00111111
00111111
00011111
00011111
00001111
11111111
11111111
NAME memory game 5

TIL e5
11111111
11111001
11111001
11110000
11100000
11111111
11111111
11111111
NAME memory game 6

TIL e6
11111111
11111111
11111111
11111111
01111111
11111111
11111111
11111111
NAME memory game 7

TIL e7
11111111
11111111
11111111
11111111
11111111
11111111
11111101
11111101
NAME memory game 8

TIL e8
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111100
NAME memory game 9

TIL e9
11111111
11111111
11000011
11000011
11000011
11000011
11111111
11111111
NAME memory game 10

TIL ea
11111000
11110000
11110000
11111111
11111111
11111111
11111111
11111111
NAME memory game 11

TIL eb
11111111
01111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME memory game 12

TIL ec
11111100
11111000
11110000
11110000
11100000
11100000
11111111
11111111
NAME memory game 13

TIL ed
11111111
01111111
00111111
00111111
00011111
00011111
11111111
11111111
NAME memory game 14

TIL ee
11111111
11111100
11111100
11111000
11110000
11110000
11111111
11111111
NAME memory game 15

TIL ef
11111111
11111111
11111111
01111111
00111111
00111111
11111111
11111111
NAME memory game 16

TIL eg
11111100
11110000
11110000
11100000
11100000
11100000
11110000
11110000
NAME memory game 17

TIL eh
01111111
00011111
00011111
00001111
00001111
00001111
00011111
00011111
NAME memory game 18

TIL ei
11111111
11111111
11111111
11111111
11111111
11111000
11111110
11111110
NAME memory game 19

TIL ej
11111100
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME memory game 20

TIL ek
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME memory game 21

TIL el
11111111
11111111
11111111
11111111
11111011
11111011
11110001
11100000
NAME memory game 22

TIL em
11111111
11111111
11111111
11111111
11111111
11111110
11111100
11111110
NAME memory game 23

TIL en
11111110
11111000
11110000
11110000
10000001
00000000
01100110
00000000
NAME memory game 24

TIL eo
11111111
11111111
11111111
11111111
00011111
00000011
01100111
00000111
NAME memory game 25

TIL ep
11100000
11000000
11000000
11111111
11111111
11111111
11111111
11111111
NAME memory game 26

TIL eq
00000000
11100000
11111111
11111111
11111111
11111111
11111110
11111100
NAME memory game 27

TIL er
00000011
11111111
11111111
11111111
00111111
00111111
00011111
00001111
NAME memory game 28

TIL es
11111111
11111100
11111100
11111000
11110000
11110000
11100000
11111111
NAME memory game 29

TIL et
11111111
11111111
11111111
01111111
00111111
00111111
00011111
11111111
NAME memory game 30

TIL eu
11111111
11111111
11111111
11111111
11000000
11000000
11000000
11000000
NAME memory game 31

TIL ev
11111111
11111111
11111111
11111111
01111111
01111111
01111111
01111111
NAME memory game 32

TIL ew
00001111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME memory game 33

TIL ex
11000000
11000000
11000000
11111111
11111111
11111111
11111111
11111111
NAME memory game 34

TIL ey
01111111
01111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME memory game 35

TIL ez
11000000
11000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME memory game 36

TIL f0
00000000
00001111
00001111
00001111
00001111
00001111
00001111
00001111
NAME memory game 37

TIL f1
00000000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME memory game 38

TIL f2
00000000
11110000
11110000
11110000
11110000
11110000
11110000
11110000
NAME memory game 39

TIL f3
00000000
00000000
00000000
00000000
00000000
10000110
01001001
00110000
NAME memory game 40

TIL f4
00000000
00000000
00000000
00000000
00000000
00011000
00100000
11001100
NAME memory game 41

TIL f5
00000000
00000000
00000000
00000000
00000000
00000000
01100001
11110011
NAME memory game 42

TIL f6
00001111
00001111
00001111
00001111
00001111
00001111
10001111
11001111
NAME memory game 43

TIL f7
11111111
11111111
11111111
10001111
11101111
11101111
11101111
10001111
NAME memory game 44

TIL f8
11111000
11111000
11111000
11111000
11111000
11111000
11111000
11111111
NAME memory game 45

TIL f9
00001111
00001111
00001111
00001111
00001111
00001111
00001111
11111111
NAME memory game 46

TIL fa
11110000
11110000
11110000
11110000
11110000
11110000
11110001
11110011
NAME memory game 47

TIL fb
00000000
00000000
00000000
00000000
00000000
00000000
10000110
11001111
NAME memory game 48

TIL fc
00000000
00000000
00000000
00000000
00000000
00011000
00000100
00110011
NAME memory game 49

TIL fd
00000000
00000000
00000000
00000000
00000000
01100001
10010010
00001100
NAME memory game 50

TIL fe
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000011
NAME memory game 51

TIL ff
00011111
00011111
00111111
01111111
11111111
11111111
11111111
11111111
NAME memory game 52

TIL fg
11111111
11111111
11111000
11100000
11000110
11100000
11110000
11111110
NAME memory game 53

TIL fh
00001111
00001111
00010001
00000000
01100110
00000000
00000000
00001111
NAME memory game 54

TIL fi
11111111
11111111
11111111
00111111
01111111
01111111
00111111
11111111
NAME memory game 55

TIL fj
11111111
11111111
11111111
11111111
11111111
11111110
11111100
11111000
NAME memory game 56

TIL fk
11111111
11111111
11111111
11111111
11111111
00111111
00011111
00001111
NAME memory game 57

TIL fl
11111000
11111000
11111100
11111110
11111110
11111111
11111111
11111111
NAME memory game 58

TIL fm
11111000
11110000
11100000
11100000
11100000
11110000
11111000
11111111
NAME memory game 59

TIL fn
11111111
01111111
00111111
00111111
00111111
01111111
11111111
11111111
NAME memory game 60

TIL fo
11111000
11111000
11111100
11111110
11111111
11111111
11111111
11111111
NAME memory game 61

TIL fp
00001111
00001111
00011111
00111111
11111111
11111111
11111111
11111111
NAME memory game 62

TIL fq
11000000
11100000
11110000
11110000
11111000
11111100
11111100
11111110
NAME memory game 63

TIL fr
00000000
00000000
00000000
00000000
00011000
00111100
01111110
00000000
NAME etk beginning 1

TIL fs
11111111
11111111
11111111
11111111
11111111
11110001
11110001
11110001
NAME etk beginning 2

TIL ft
11111111
11111111
11111111
11111111
11111111
11111000
11111000
11111000
NAME etk beginning 3

TIL fu
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11000000
NAME etk beginning 4

TIL fv
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00111111
NAME etk beginning 5

TIL fw
11111101
11111101
11111101
11111101
11111101
11111101
11111101
11111101
NAME etk beginning 6

TIL fx
11011111
11011111
11011111
11011111
11011111
10000000
10111111
01111111
NAME etk beginning 7
WAL true

TIL fy
10111111
10111111
10111111
10111111
10111111
00111111
10111111
00000000
NAME etk beginning 8
WAL true

TIL fz
11101111
11101111
11101111
11101111
11101111
11000000
11011111
00111111
NAME etk beginning 9
WAL true

TIL g0
11011111
11011111
11011111
11011111
11011111
00011111
11011111
10000000
NAME etk beginning 10
WAL true

TIL g1
11111101
11111101
11111101
11111101
11111101
11111101
11111101
00000000
NAME etk beginning 11
WAL true

TIL g2
01111111
00000000
11011111
11011111
11111111
11111111
11111111
11111111
NAME etk beginning 12
WAL false

TIL g3
11111111
00000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME etk beginning 13
WAL false

TIL g4
11111110
00000000
11111110
11111110
11111110
11111110
11111110
11111111
NAME etk beginning 14

TIL g5
00111111
10111111
10111111
10111111
11111111
11111111
11111111
11111111
NAME etk beginning 15

TIL g6
11111011
11111011
11111011
11111011
11111111
11111111
11111111
11111111
NAME etk beginning 16

TIL g7
00111111
00000000
01101111
01101111
01111111
01111111
01111111
11111111
NAME etk beginning 17

TIL g8
00011111
01011111
01011111
01011111
01111111
01111111
01111111
11111111
NAME etk beginning 18

TIL g9
11111101
11111101
11111101
11111101
11111111
11111111
11111111
11111111
NAME etk beginning 19

TIL ga
00000000
01111110
00111100
00011000
00000000
00000000
00000000
00000000
NAME etk beginning 20

TIL gb
11111111
11111111
11111111
10000000
10111111
10111111
10111111
10111111
NAME etk 1st up 1

TIL gc
11111111
11111111
11111111
00000000
11111111
11111111
11111111
11111111
NAME etk 1st up 2
WAL false

TIL gd
11111111
11111111
11111111
00000000
11011111
11011111
11011111
11011111
NAME etk 1st up 3

TIL ge
11111111
11111111
11111111
00000001
11111101
11111101
11111101
11111101
NAME etk 1st up 4

TIL gf
11111111
11111111
11111111
11111111
11111111
11111100
11111100
11111100
NAME etk 1st up 5

TIL gg
11111111
11111111
11111111
11111111
11111111
01111111
01111111
01111111
NAME etk 1st up 6

TIL gh
10111111
10111111
10111111
10111111
10111111
10111111
10111111
10111111
NAME etk 1st up 7
WAL false

TIL gi
11011111
11011111
11011111
11011111
11011111
11011111
11011111
11011111
NAME etk 1st up 8
WAL false

TIL gj
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME etk 1st up 9
WAL false

TIL gk
10111111
10100000
10101111
10101111
10101111
10101111
10100000
00001111
NAME etk 1st up 10
WAL true

TIL gl
11111111
00000000
11111111
11111111
11111111
11111111
00000000
11111110
NAME etk 1st up 11
WAL true

TIL gm
11011111
01011111
01011111
01011111
01011111
01011111
01011111
00000000
NAME etk 1st up 12
WAL true

TIL gn
11111110
11111110
11111110
11111110
11111110
11111110
11111110
00000000
NAME etk 1st up 13
WAL true

TIL go
10011111
10000000
10101111
10111111
10111111
11111111
11111111
11111111
NAME etk 1st up 14

TIL gp
11111110
00000000
11111110
11111110
11111110
11111111
11111111
11111111
NAME etk 1st up 15

TIL gq
01011111
01011111
01011111
11011111
11011111
11111111
11111111
11111111
NAME etk 1st up 16

TIL gr
11111101
11111101
11111101
11111101
11111101
11111111
11111111
11111111
NAME etk 1st up 17

TIL gs
11111110
11111110
11111110
11111110
11111111
11111111
11111111
11111111
NAME etk 1st up 18

TIL gt
01111111
00000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME etk 1st down 1

TIL gu
11111110
00000000
11111110
11111110
11111110
11111110
11111110
11111110
NAME etk 1st down 2

TIL gv
00111111
10111111
10111111
10111111
10111111
10111111
10111111
10111111
NAME etk 1st down 3
WAL false

TIL gw
11111111
11111111
11111111
11111111
11111111
11111111
11111000
11111011
NAME etk 1st down 4

TIL gx
11111111
11111111
11111111
11111111
11111111
11111111
00000000
11110111
NAME etk 1st down 5

TIL gy
11111111
11111111
11111111
11111111
11111111
11111111
00001111
11101111
NAME etk 1st down 6

TIL gz
11110111
11110111
11110111
11110111
11110111
11110111
11110111
11110111
NAME etk 1st down 7
WAL true

TIL h0
11101111
11101111
11101111
11101111
11101111
11101111
11101111
11101111
NAME etk 1st down 8
WAL true

TIL h1
10111111
10111111
10111111
10111111
10111111
10111111
10111111
10000000
NAME etk 1st down 9
WAL true

TIL h2
11111011
11111011
11111011
00000000
11111111
11111111
11111111
11111111
NAME etk 1st down 10

TIL h3
11110111
11110111
11110111
00000000
11111111
11111111
11111111
11111111
NAME etk 1st down 11

TIL h4
11101111
11101111
11101111
00000000
11111111
11111111
11111111
11111111
NAME etk 1st down 12

TIL h5
11111110
11111110
11111110
00000000
11111111
11111111
11111111
11111111
NAME etk 1st down 13

TIL h6
10111111
01111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME etk 1st down 14

TIL h7
11111111
11111111
11111111
11111111
11111111
00011111
00011111
00011111
NAME dead end 1

TIL h8
11111000
11111011
11110111
11100000
11101111
11101111
11100000
11101111
NAME dead end 2

TIL h9
00000000
11011111
10011110
00000000
10111110
10111110
00000000
10111110
NAME dead end 3

TIL ha
00000000
01111101
01111001
00000000
11111011
11111011
00000000
11111011
NAME dead end 4

TIL hb
00000000
11110111
11100111
00000000
11101111
11101111
00000000
11101111
NAME dead end 5

TIL hc
11101111
11100000
11101111
11101111
11100000
11101111
11101111
00000000
NAME dead end 6
WAL true

TIL hd
10111110
00000000
10111110
10111110
00000000
10111110
10111110
00000000
NAME dead end 7
WAL true

TIL he
11111011
00000000
11111011
11111011
00000000
11111011
11111011
00000000
NAME dead end 8
WAL true

TIL hf
11101111
00000000
11101111
11101111
00000000
11101111
11101111
00000000
NAME dead end 9
WAL true

TIL hg
10111111
10111111
10111111
11111111
11111111
11111111
11111111
11111111
NAME dead end 10

TIL hh
11101111
11101111
11100000
11111111
11111111
11111111
11111111
11111111
NAME dead end 11

TIL hi
10111110
10111110
00000000
11111111
11111111
11111111
11111111
11111111
NAME dead end 12

TIL hj
11111011
11111011
00000000
11111111
11111111
11111111
11111111
11111111
NAME dead end 13

TIL hk
11101111
11101111
00000000
11111111
11111111
11111111
11111111
11111111
NAME dead end 14

TIL hl
00011111
01011111
01011111
01011111
01011111
01011111
01011111
01011111
NAME police station 1

TIL hm
01011111
01011111
01011111
01011111
01011111
01011111
01011111
01011111
NAME police station 2
WAL false

TIL hn
01011111
01011111
01011111
01011111
01011111
01011111
01011111
01000000
NAME police station 3
WAL true

TIL ho
01011111
00111111
00111111
01111111
11111111
11111111
11111111
11111111
NAME police station 4

TIL hp
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME red flow
COL 3

TIL hq
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME orange flow
COL 4

TIL hr
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME yellow flow
COL 5

TIL hs
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME green flow
COL 6

TIL ht
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME blue flow
COL 7

TIL hu
11111111
11111111
11111111
11111111
11111111
00000000
11111111
11111111
WAL true

TIL hv
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110
WAL true

TIL hw
11111011
11111011
11111011
11111011
11111011
11111011
11111011
11111011
WAL true

TIL hx
00000000
00000000
00000000
00000000
00000000
00000110
00111111
00111111
NAME lucid 1

TIL hy
00001110
00111111
01111111
01111111
11111111
11111111
11111111
11111111
NAME lucid 2

TIL hz
00000111
10111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME lucid 3

TIL i0
11000000
11111000
11111100
11111111
11111111
11111111
11111111
11111111
NAME lucid 4

TIL i1
00000000
00000000
00000000
10000000
11100000
11110000
11110000
11111000
NAME lucid 5

TIL i2
00000000
00000111
00011111
00111111
01111111
01111111
11111111
11111111
NAME lucid 6

TIL i3
00000000
00000011
11011111
11111111
11111111
11111111
11111111
11111111
NAME lucid 7

TIL i4
00000000
00000000
11100001
11111011
11111011
11111100
11111111
11111111
NAME lucid 8

TIL i5
00000000
00011110
11111111
11111111
11111111
01111111
10011111
11101111
NAME lucid 9

TIL i6
00000000
00000000
11100000
11100000
11110000
11111000
11111100
11111111
NAME lucid 10

TIL i7
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME lucid 11

TIL i8
01111111
01111111
00111111
00111111
00111111
01111111
01111111
00111111
NAME lucid 12

TIL i9
11110000
11111000
11111101
11111110
11111111
11111111
11111111
11111111
NAME lucid 13

TIL ia
00001111
01111111
11111111
11111111
01111111
01111111
01000000
00111111
NAME lucid 14

TIL ib
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111
NAME lucid 15

TIL ic
11100111
11110111
11111011
11111011
11111011
11111000
11111000
11110000
NAME lucid 16

TIL id
11111111
11111111
11111111
11111111
11111111
01111110
00000000
00000000
NAME lucid 17

TIL ie
11100000
11110111
11101111
11011111
10111111
01111111
11111111
11111111
NAME lucid 18

TIL if
00000000
11100011
11111111
11111111
11111111
11111111
11111111
11111111
NAME lucid 19

TIL ig
01111110
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME lucid 20

TIL ih
00000000
11000000
11100000
11110000
11111000
11111111
11111111
11111111
NAME lucid 21

TIL ii
00000000
00000000
00000000
00000000
00000000
11100000
11111000
11111100
NAME lucid 22

TIL ij
00111111
00011111
00000111
00000000
00000000
00000000
00000000
00000000
NAME lucid 23

TIL ik
11111111
11111111
11111111
00001111
00000000
00000110
00111111
01111111
NAME lucid 24

TIL il
11111111
11110000
11101111
11011111
00111111
01111111
11111111
11111111
NAME lucid 25

TIL im
11111111
00111111
11010001
11100000
11110000
11111000
11111111
11111111
NAME lucid 26

TIL in
11111110
11111101
11100001
00000011
00000111
11110001
11111100
11111111
NAME lucid 27

TIL io
11111111
11111111
11111111
11111111
11111111
11111111
00111111
10011111
NAME lucid 28

TIL ip
10111111
11011111
11100011
11111101
11111110
11111111
11111111
11111111
NAME lucid 29

TIL iq
11111111
11111111
11111111
00111111
00000000
00000000
10000000
11110000
NAME lucid 30

TIL ir
11111111
11111111
11111111
11111100
00000000
00000000
00000000
00000000
NAME lucid 31

TIL is
11100000
11100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME lucid 32

TIL it
00000000
00000111
00011111
00111111
01111111
01111111
11111111
10001111
NAME lucid 33

TIL iu
11111110
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME lucid 34

TIL iv
00000000
00000000
00000000
00011000
11111111
11111111
11111111
11111111
NAME lucid 35

TIL iw
11001111
11101111
11101111
11100111
11110011
11111001
11111101
11111100
NAME lucid 36

TIL ix
11111100
11111110
11111110
11111111
11111111
11111110
11111110
11111100
NAME lucid 37

TIL iy
00000000
00000000
00000111
00011111
00111111
00111111
01111111
01111111
NAME lucid 38

TIL iz
01100011
11111001
11111101
11111100
11111110
11111111
11111111
11111111
NAME lucid 39

TIL j0
11111111
11111111
11111111
11111111
00111111
10000111
11111011
11111101
NAME lucid 40

TIL j1
11111110
11111110
11111110
11111110
11111110
11111100
11111000
11100000
NAME lucid 41

TIL j2
11111111
11110000
00000000
00000000
00000000
00000000
00000000
00000000
NAME lucid 42

TIL j3
00000001
00000011
00000011
00000000
00000000
00000000
00000000
00000000
NAME lucid 43

TIL j4
11111111
11111111
11111111
00011111
00000000
00000000
00000000
00000000
NAME lucid 44

TIL j5
11111111
11111111
11111111
10000000
00000000
00000000
00000000
00000000
NAME lucid 45

TIL j6
11111100
11111000
11000000
00000000
00000000
00000000
00000000
00000000
NAME lucid 46

TIL j7
00000000
00000000
00000000
00000000
00000000
00000000
00111111
00100000
NAME lucid 47

TIL j8
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000000
NAME lucid 48

TIL j9
00000000
00000000
00000000
00000000
00000000
00000001
11111111
00000000
NAME lucid 49

TIL ja
00100000
00100000
00101000
00101000
00101100
00101110
00101010
00101011
NAME lucid 50

TIL jb
00000100
10000100
11000100
11000100
11100100
11110010
11110010
00000010
NAME lucid 51

TIL jc
00111001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME lucid 52

TIL jd
01111111
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME lucid 53

TIL je
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME lucid 54

TIL jf
11111010
00001010
00001010
00001010
00001010
00001010
00001010
00001010
NAME lucid 55

TIL jg
00000001
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME lucid 56

TIL jh
11000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME lucid 57

TIL ji
00001110
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME lucid 58

SPR A
00000000
00011000
00011000
00111100
01011010
00111100
00100100
00100100
>
00011000
00011000
00111100
01011010
00011000
00100100
00100100
00100100
POS 1 1,11

SPR b
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

SPR c
00000000
00011000
00011000
00111100
00111100
00011000
00100100
00100100
>
00000000
00011000
00011000
00111100
00111100
00011000
00100100
00100100
NAME mom
DLG 9
POS 4 10,10

SPR d
00000000
00011000
00011000
00111100
00111100
00011000
00100100
00100100
>
00000000
00011000
00011000
00111100
00111100
00011000
00100100
00100100
NAME sister
DLG 8
POS 5 11,13

SPR e
00000000
00000000
00000111
00000011
00000000
00000000
00000000
00000000
NAME avatar in bed
POS 7 14,9

SPR f
11000000
11000000
11000000
11000000
00000000
00000000
00000000
00000000
NAME avatar in bed 2
POS 7 15,9

SPR g
00000000
00000000
11100000
11100000
11100000
11100000
11000000
11000000
NAME avatar in bed 3
POS 7 15,8

SPR h
00000000
00000000
00000001
00000001
00000001
00000001
00000000
00000000
NAME avatar in bed 4
POS 7 14,8

SPR i
00000000
00011000
00011000
00111100
01011010
00011000
00100100
00100100
>
00000000
00000000
00011000
00011000
00111100
01011010
00111100
00100100
NAME host 
DLG j
POS 13 14,15

SPR j
00000000
00011001
00011001
00111111
01011001
00011000
00100100
00100100
>
00000000
00000000
00011001
00011001
00111111
01011001
00111100
00100100
NAME my follower
DLG 3k
POS 15 0,9

SPR k
00000000
00000000
00000111
00000011
00000000
00000000
00000000
00000000
POS 20 14,9

SPR l
11000000
11000000
11000000
11000000
00000000
00000000
00000000
00000000
POS 20 15,9

SPR m
00000000
00000000
11100000
11100000
11100000
11100000
11000000
11000000
POS 20 15,8

SPR n
00000000
00000000
00000001
00000001
00000001
00000001
00000000
00000000
POS 20 14,8

ITM 2
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME beginning text
DLG 3

ITM 3
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11101110

ITM 4
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME kitchen text
DLG 7

ITM 5
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME wrong path 1
DLG d

ITM 6
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME wrong path 2
DLG f

ITM 7
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME wrong path 3
DLG g

ITM 8
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME right path
DLG h

ITM 9
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 orange
DLG q

ITM 10
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 18 red
DLG 1h

ITM 11
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 19 red
DLG 1i

ITM 12
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 20 red
DLG 1j

ITM 13
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 21 red
DLG 1k

ITM 14
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 22 red
DLG 1l

ITM 15
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 23 red
DLG 1m

ITM 16
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 24 red
DLG 1n

ITM 17
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 25 red
DLG 1o

ITM 18
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 26 red
DLG 1p

ITM 19
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 27 red
DLG 1q

ITM 20
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 19 blue
DLG 2h

ITM 21
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME finshed red
DLG 2i

ITM 22
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME finished blue
DLG 2j

ITM 23
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 yellow
DLG 2k

ITM 24
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 2 yellow
DLG 2l

ITM 25
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 3 yellow
DLG 2m

ITM 26
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 4 yellow
DLG 2n

ITM 27
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 yellow
DLG 2o

ITM 28
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 6 yellow
DLG 2p

ITM 29
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 7 yellow
DLG 2q

ITM 30
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME police station
DLG 3i

ITM 31
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME follow
DLG 3l

ITM a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 2 orange
DLG r

ITM b
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 3 orange
DLG s

ITM c
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 4 orange
DLG t

ITM d
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 orange
DLG u

ITM e
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 6 orange
DLG v

ITM f
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 7 orange
DLG w

ITM g
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 8 orange
DLG x

ITM h
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 9 orange
DLG y

ITM i
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME finished orange
DLG z

ITM j
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 red
DLG 10

ITM k
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 2 red
DLG 11

ITM l
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 3 red
DLG 12

ITM m
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 4 red
DLG 13

ITM n
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 red
DLG 14

ITM o
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 6 red
DLG 15

ITM p
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 7 red
DLG 16

ITM q
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 8 red
DLG 17

ITM r
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 9 red
DLG 18

ITM s
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 10 red
DLG 19

ITM t
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 11 red
DLG 1a

ITM u
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 12 red
DLG 1b

ITM v
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 13 red
DLG 1c

ITM w
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 14 red
DLG 1d

ITM x
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 15 red
DLG 1e

ITM y
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 16 red
DLG 1f

ITM z
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 17 red
DLG 1g

ITM 1a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 28 red
DLG 1r

ITM 1b
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 29 red
DLG 1s

ITM 1c
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 30 red
DLG 1t

ITM 1d
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 31 red
DLG 1u

ITM 1e
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 32 red
DLG 1v

ITM 1f
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 33 red
DLG 1w

ITM 1g
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 34 red
DLG 1x

ITM 1h
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 35 red
DLG 1y

ITM 1i
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 blue
DLG 1z

ITM 1j
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 2 blue
DLG 20

ITM 1k
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 3 blue
DLG 21

ITM 1l
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 4 blue
DLG 22

ITM 1m
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 5 blue
DLG 23

ITM 1n
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 6 blue
DLG 24

ITM 1o
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 7 blue
DLG 25

ITM 1p
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 8 blue
DLG 26

ITM 1q
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 9 blue
DLG 27

ITM 1r
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 10 blue
DLG 28

ITM 1s
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 11 blue
DLG 29

ITM 1t
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 12 blue
DLG 2a

ITM 1u
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 13 blue
DLG 2b

ITM 1v
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 14 blue
DLG 2c

ITM 1w
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 15 blue
DLG 2d

ITM 1x
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 16 blue
DLG 2e

ITM 1y
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 17 blue
DLG 2f

ITM 1z
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 18 blue
DLG 2g

ITM 2a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 8 yellow
DLG 2r

ITM 2b
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 9 yellow
DLG 2s

ITM 2c
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 10 yellow
DLG 2t

ITM 2d
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 11 yellow
DLG 2u

ITM 2e
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 12 yellow
DLG 2v

ITM 2f
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 13 yellow
DLG 2w

ITM 2g
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 14 yellow
DLG 2x

ITM 2h
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 15 yellow
DLG 2y

ITM 2i
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 16 yellow
DLG 2z

ITM 2j
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 17 yellow
DLG 30

ITM 2k
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 18 yellow
DLG 31

ITM 2l
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 19 yellow
DLG 32

ITM 2m
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 20 yellow
DLG 33

ITM 2n
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 21 yellow
DLG 34

ITM 2o
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 22 yellow
DLG 35

ITM 2p
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 23 yellow
DLG 36

ITM 2q
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 24 yellow
DLG 37

ITM 2r
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 25 yellow
DLG 38

ITM 2s
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME finished yellow
DLG 39

ITM 2t
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 1 green
DLG 3a

ITM 2u
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 2 green
DLG 3b

ITM 2v
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 3 green
DLG 3c

ITM 2w
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 4 green
DLG 3d

ITM 2x
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME finished green
DLG 3e

ITM 2z
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME failed wires
DLG 3f

DLG 3
"""
{
  - {item "2"} >= 1 ?

  - else ?
    where am i?
    {item "2" {{item "2"} + 1}}
}
"""
NAME beginning text dialog

DLG 6
"""
is this our house?
{pg}
yes...why are you acting like you've never been here before? 
{pg}
 i don't know where i am... 
{pg}
 WHOA IS THAT OUR KITCKEN?!? 
{pg}
 ...go get some sleep you sound crazy right now.
"""
NAME is this our house? dialog

DLG 7
"""
wow this kitchen is so beautiful!
{tilePalette "4,8,2,7"}
{tilePalette "4,9,2,7"}
{tilePalette "4,10,2,7"}
{pg}
i want my future home to have this kitchen...
{tilePalette "6,10,10,8"}{tilePalette "6,10,11,9"}
{pg}
maybe i should take a picture of this...
{pg}
so i don't forget what it looks like when i wake up
{pg}
*click*
{pg}
this probably won't show up in my camera roll...
"""
NAME kitchen text dialog

DLG 8
"""
what are you doing?
{pg}
taking a picture so i can remember when i wake up!
{pg}
what...?
{pg}
wait a minute...
{exit "6" 10 13}
{pg}
IM DREAMING
{exit "7" 8 2}
{pg}
*GASP*
{pg}
what the hell was that?!?
{pg}
was i almost...lucid?
{pg}
ugh but why did i jolt awake?
{pg}
let me look at some methods so i can actually be lucid
{exit "8" 10 10 "slide_u"}
{pg}
hmmm...reality checks?
{pg}
set an alarm on my phone for every hour that i'm awake...
{pg}
do the reality check method?
{choice - yes (jump "b")
 - no 
(jump "c")}
"""
NAME sister dialog

DLG 9
"""
ask about the house or size?
{choice - house (jump "6")
  - size
    (jump "a")}

"""
NAME mom dialog

DLG 10
{tilePalette "b,12,11,1a"}{tilePalette "b,12,10,1a"}{tilePalette "b,13,11,1a"}{tilePalette "b,13,10,1a"}
NAME 1 red dialog

DLG 11
{tilePalette "b,13,12,1a"}{tilePalette "b,12,12,1a"}
NAME 2 red dialog

DLG 12
{tilePalette "b,13,13,1a"}{tilePalette "b,12,13,1a"}
NAME 3 red dialog

DLG 13
{tilePalette "b,13,14,1a"}{tilePalette "b,12,14,1a"}{tilePalette "b,13,15,1a"}{tilePalette "b,12,15,1a"}
NAME 4 red dialog

DLG 14
{tilePalette "b,11,14,1a"}{tilePalette "b,11,15,1a"}
NAME 5 red dialog

DLG 15
{tilePalette "b,10,14,1a"}{tilePalette "b,10,15,1a"}
NAME 6 red dialog

DLG 16
{tilePalette "b,9,14,1a"}{tilePalette "b,9,15,1a"}
NAME 7 red dialog

DLG 17
{tilePalette "b,8,14,1a"}{tilePalette "b,8,15,1a"}
NAME 8 red dialog

DLG 18
{tilePalette "b,7,14,1a"}{tilePalette "b,7,15,1a"}
NAME 9 red dialog

DLG 19
{tilePalette "b,6,14,1a"}{tilePalette "b,6,15,1a"}
NAME 10 red dialog

DLG 20
{tilePalette "d,12,0,1b"}{tilePalette "d,12,1,1b"}
NAME 2 blue dialog

DLG 21
{tilePalette "d,13,0,1b"}{tilePalette "d,13,1,1b"}
NAME item 1k dialog

DLG 22
{tilePalette "d,14,0,1b"}{tilePalette "d,14,1,1b"}{tilePalette "d,15,0,1b"}{tilePalette "d,15,1,1b"}
NAME item 1l dialog

DLG 23
{tilePalette "d,14,2,1b"}{tilePalette "d,15,2,1b"}
NAME 5 blue dialog

DLG 24
{tilePalette "d,14,3,1b"}{tilePalette "d,15,3,1b"}
NAME 6 blue dialog

DLG 25
{tilePalette "d,14,4,1b"}{tilePalette "d,15,4,1b"}
NAME item 1o dialog

DLG 26
{tilePalette "d,14,5,1b"}{tilePalette "d,15,5,1b"}
NAME 8 blue dialog

DLG 27
{tilePalette "d,14,6,1b"}{tilePalette "d,15,6,1b"}{tilePalette "d,14,7,1b"}{tilePalette "d,15,7,1b"}
NAME item 1q dialog

DLG 28
{tilePalette "d,13,6,1b"}{tilePalette "d,13,7,1b"}
NAME 10 blue dialog

DLG 29
{tilePalette "d,12,6,1b"}{tilePalette "d,12,7,1b"}
NAME item 1s dialog

DLG 30
{tilePalette "f,4,2,1c"}{tilePalette "f,4,3,1c"}
NAME item 2j dialog

DLG 31
{tilePalette "f,5,2,1c"}{tilePalette "f,5,3,1c"}
NAME item 2k dialog

DLG 32
{tilePalette "f,6,2,1c"}{tilePalette "f,6,3,1c"}{tilePalette "f,7,2,1c"}{tilePalette "f,7,3,1c"}
NAME item 2l dialog

DLG 33
"""
{tilePalette "f,6,4,1c"}{tilePalette "f,7,4,1c"}{tilePalette "f,6,5,1c"}{tilePalette "f,7,5,1c"}
{exit "1c" 7 4}
"""
NAME item 2m dialog

DLG 34
{tilePalette "f,8,4,1c"}{tilePalette "f,8,5,1c"}
NAME item 2n dialog

DLG 35
{tilePalette "f,9,4,1c"}{tilePalette "f,9,5,1c"}
NAME 22 yellow dialog

DLG 36
{tilePalette "f,10,4,1c"}{tilePalette "f,10,5,1c"}
NAME item 2p dialog

DLG 37
{tilePalette "f,11,4,1c"}{tilePalette "f,11,5,1c"}
NAME item 2q dialog

DLG 38
{tilePalette "f,12,4,1c"}{tilePalette "f,12,5,1c"}{tilePalette "f,13,4,1c"}{tilePalette "f,13,5,1c"}
NAME item 2r dialog

DLG 39
"""
and finally...onto green
{exit "1d" 5 5}
{pg}
starting at the top
"""
NAME finished yellow dialog

DLG a
"""
 why is everything so big?
{pg}
what do you mean? everything is sized normally...
{pg}
this is normal to you?!?
{pg}
...stop acting clueless
"""
NAME size dialog

DLG b
"""
i'll give this one a try
{pg}
*later that night*
{exit "10" 0 6 "tunnel"}
{pg}
there are multiple paths in this maze...
{pg}
but only one is correct
{pg}
take the correct path and you'll succeessfully become lucid
{pg}
take the wrong path and you'll have to try another night
"""
NAME reality check method 

DLG c
"""
hmmm...the wake back to bed method
{pg}
i have to wake up 4-6 hours after my bedtime?
{pg}
then i have to stay up another 30 minutes...
{pg}
do the WBTB method?
{choice - yes (jump "i")
  - no
    (jump "n")}
"""
NAME WBTB method

DLG d
"""
{exit "7" 8 2}
damn so close...
{pg}
maybe i did the method wrong
{pg}
let me check
{exit "8" 10 10}
{pg}
set my phone every hour...check me hands...
{pg}
i did all of this! what am i doing wrong?
{pg}
try the reality check method again?
{choice - yes (jump "e")
  - no
    (jump "c")}
"""
NAME wrong path 1 dialog

DLG e
"""
i guess i'll give it a try again...
{exit "10" 0 6 "tunnel"}
"""
NAME reality check again

DLG f
"""
{exit "7" 8 2}
ugh not again!
{pg}
what am i doing wrong?
{pg}
let me check
{exit "8" 10 10}
{pg}
it seems like i'm doing everything right...
{pg}
try the reality check method again?
{choice - yes (jump "e")
  - no
    (jump "c")}
"""
NAME wrong path 2 dialog

DLG g
"""
{exit "7" 8 2}
why is this so hard for me?
{pg}
what am i doing wrong?
{pg}
there's gotta be a way i can do this
{exit "8" 10 10}
{pg}
i'm doing everything it says...
{pg}
try the reality check method again?
{choice - yes (jump "e")
  - no
    (jump "c")}
"""
NAME wrong path 3 dialog

DLG h
"""
{exit "20" 5 8}
{pg}
*GASP*
{pg}
i...i did it?
{pg}
am i actually...
{pg}
DID MY FINGER JUST GO THROUGH MY HAND?!?
{pg}
i don't even know where to start...
{exit "7" 8 2}
{pg}
what...
{pg}
i got too excited...
{pg}
but i finally found a method that works for me!
{pg}
i can't wait to get better at this and have the best dreams
{end}
"""
NAME right path dialog

DLG i
"""
i'll give this method a try
{pg}
*later that night*
{exit "13" 0 15 "tunnel"}
{pg}
in order to successfully become lucid with this method
{pg}
you must correctly answer the question i ask you
{pg}
answer it wrong and you'll have to try another night
{pg}
take a a few seconds to carefully look at the stage
{pg}
then when you're ready...come over to me for the question
"""
NAME WBTB method

DLG j
"""
how many squares were there? 
{choice - 4 (jump "m")
  - 5
    (jump "a")}
"""
NAME host dialog

DLG k
"""
ooo so clsoe! maybe next time
{exit "7" 8 2}
why didn't that work?!?
{pg}
maybe i read the instructions wrong
{exit "8" 10 10}
{pg}
nope...i'm doing exactly what it says...
{pg}
try the WBTB method again?
{choice - yes (jump "l")
  - no
    (jump "n")}
"""
NAME incorrect in memory

DLG l
"""
i guess i'll give it a try again...
{exit "13" 0 15 "tunnel"}
"""
NAME try memory again

DLG m
"""
CORRECT!
{exit "20" 5 8}
{pg}
*GASP*
{pg}
i...i did it?
{pg}
am i actually...
{pg}
DID MY FINGER JUST GO THROUGH MY HAND?!?
{pg}
i don't even know where to start...
{exit "7" 8 2}
{pg}
what...
{pg}
i got too excited...
{pg}
but i finally found a method that works for me!
{pg}
i can't wait to get better at this and have the best dreams
{end}
"""
NAME right memory

DLG n
"""
maybe i'll try a different method...
{exit "9" 10 11}
{pg}
the MILD method...
{pg}
i have to think about a recent dream? hmmm
{pg}
try the MILD method?
{choice - yes (jump "o")
  - no
    (jump "3h")}
"""
NAME no to WBTB 

DLG o
"""
let me give this a try...
{pg}
*later that night*
{exit "14" 14 14 "tunnel"}
{pg}
to become lucid you must connect these wires
{pg}
however...they cannot overlap
{pg}
all moves are final
{pg}
that being said...think before you move
{pg}
one wrong move and you'll fail
{pg}
however...your progress will be saved
{pg}
keep in mind that although your progress is visible...
{pg}
you'll still have to "reconnect" those wires
{pg}
follow the same path as you previously did before failing
{pg}
once you reach the other end of the wire...
{pg}
make sure you connect it
{pg}
ex. if you move to the right and it looks connected...
{pg}
but the other end of the wire is up
{pg}
make sure you go up to successfully connect it
{pg}
starting with orange in the bottom right corner
"""
NAME MILD method

DLG q
{tilePalette "9,14,13,14"}{tilePalette "9,15,13,14"}
NAME test dialog

DLG r
{tilePalette "9,14,12,14"}{tilePalette "9,15,12,14"}
NAME 2 orange dialog

DLG s
{tilePalette "9,14,11,14"}{tilePalette "9,15,11,14"}
NAME 3 orange dialog

DLG t
{tilePalette "9,14,10,14"}{tilePalette "9,15,10,14"}
NAME 4 orange dialog

DLG u
{tilePalette "9,14,9,14"}{tilePalette "9,15,9,14"}{tilePalette "9,14,8,14"}{tilePalette "9,15,8,14"}
NAME 5 orange dialog

DLG v
{tilePalette "9,13,8,14"}{tilePalette "9,13,9,14"}
NAME 6 orange dialog

DLG w
{tilePalette "9,12,8,14"}{tilePalette "9,12,9,14"}
NAME 7 orange dialog

DLG x
{tilePalette "9,11,8,14"}{tilePalette "9,11,9,14"}
NAME 8 orange dialog

DLG y
{tilePalette "9,10,8,14"}{tilePalette "9,10,9,14"}
NAME 9 orange dialog

DLG z
"""
now onto red
{exit "1a" 11 11}
{pg}
starting at the red at the bottom
"""
NAME finished orange dialog

DLG 1a
{tilePalette "b,5,14,1a"}{tilePalette "b,5,15,1a"}
NAME 11 red dialog

DLG 1b
{tilePalette "b,4,14,1a"}{tilePalette "b,4,15,1a"}
NAME 12 red dialog

DLG 1c
{tilePalette "b,3,14,1a"}{tilePalette "b,3,15,1a"}
NAME 13 red dialog

DLG 1d
{tilePalette "b,2,14,1a"}{tilePalette "b,2,15,1a"}
NAME 14 red dialog

DLG 1e
{tilePalette "b,1,14,1a"}{tilePalette "b,1,15,1a"}{tilePalette "b,0,14,1a"}{tilePalette "b,0,15,1a"}
NAME item x dialog

DLG 1f
{tilePalette "b,0,13,1a"}{tilePalette "b,1,13,1a"}
NAME 16 red dialog

DLG 1g
{tilePalette "b,0,12,1a"}{tilePalette "b,1,12,1a"}
NAME 17 red dialog

DLG 1h
{tilePalette "b,0,11,1a"}{tilePalette "b,1,11,1a"}
NAME 18 red dialog

DLG 1i
{tilePalette "b,0,10,1a"}{tilePalette "b,1,10,1a"}
NAME 19 red dialog

DLG 1j
{tilePalette "b,0,9,1a"}{tilePalette "b,1,9,1a"}
NAME 20 red dialog

DLG 1k
{tilePalette "b,0,8,1a"}{tilePalette "b,1,8,1a"}
NAME 21 red dialog

DLG 1l
{tilePalette "b,0,7,1a"}{tilePalette "b,1,7,1a"}
NAME 22 red dialog

DLG 1m
{tilePalette "b,0,6,1a"}{tilePalette "b,1,6,1a"}
NAME item 15 dialog

DLG 1n
{tilePalette "b,0,5,1a"}{tilePalette "b,1,5,1a"}
NAME item 16 dialog

DLG 1o
{tilePalette "b,0,4,1a"}{tilePalette "b,1,4,1a"}
NAME item 17 dialog

DLG 1p
{tilePalette "b,0,3,1a"}{tilePalette "b,1,3,1a"}
NAME item 18 dialog

DLG 1q
{tilePalette "b,0,2,1a"}{tilePalette "b,1,2,1a"}
NAME item 19 dialog

DLG 1r
{tilePalette "b,0,1,1a"}{tilePalette "b,1,1,1a"}{tilePalette "b,0,0,1a"}{tilePalette "b,1,0,1a"}
NAME item 1a dialog

DLG 1s
{tilePalette "b,2,0,1a"}{tilePalette "b,2,1,1a"}
NAME item 1b dialog

DLG 1t
{tilePalette "b,3,0,1a"}{tilePalette "b,3,1,1a"}
NAME item 1c dialog

DLG 1u
{tilePalette "b,4,0,1a"}{tilePalette "b,4,1,1a"}
NAME item 1d dialog

DLG 1v
{tilePalette "b,5,0,1a"}{tilePalette "b,5,1,1a"}
NAME item 1e dialog

DLG 1w
{tilePalette "b,6,0,1a"}{tilePalette "b,6,1,1a"}
NAME item 1f dialog

DLG 1x
{tilePalette "b,7,0,1a"}{tilePalette "b,7,1,1a"}
NAME item 1g dialog

DLG 1y
{tilePalette "b,8,0,1a"}{tilePalette "b,8,1,1a"}{tilePalette "b,9,0,1a"}{tilePalette "b,9,1,1a"}
NAME item 1h dialog

DLG 1z
{tilePalette "d,10,0,1b"}{tilePalette "d,10,1,1b"}{tilePalette "d,11,0,1b"}{tilePalette "d,11,1,1b"}
NAME 1 blue dialog

DLG 2a
{tilePalette "d,11,6,1b"}{tilePalette "d,11,7,1b"}
NAME item 1t dialog

DLG 2b
{tilePalette "d,10,6,1b"}{tilePalette "d,10,7,1b"}
NAME item 1u dialog

DLG 2c
{tilePalette "d,9,6,1b"}{tilePalette "d,9,7,1b"}
NAME item 1v dialog

DLG 2d
{tilePalette "d,8,6,1b"}{tilePalette "d,8,7,1b"}
NAME item 1w dialog

DLG 2e
"""
{tilePalette "d,7,6,1b"}{tilePalette "d,7,7,1b"}{tilePalette "d,6,6,1b"}{tilePalette "d,6,7,1b"}
{exit "1b" 7 7}
"""
NAME 16 blue dialog

DLG 2f
{tilePalette "d,6,8,1b"}{tilePalette "d,7,8,1b"}
NAME item 1y dialog

DLG 2g
{tilePalette "d,6,9,1b"}{tilePalette "d,7,9,1b"}
NAME item 1z dialog

DLG 2h
{tilePalette "d,6,10,1b"}{tilePalette "d,7,10,1b"}{tilePalette "d,6,11,1b"}{tilePalette "d,7,11,1b"}
NAME 19 blue dialog

DLG 2i
"""
now onto blue
{exit "1b" 11 2}
{pg}
starting at the top
"""
NAME finshed red dialog

DLG 2j
"""
now onto yellow
{exit "1c" 10 12}
{pg}
starting at the bottom
"""
NAME finished blue dialog

DLG 2k
{tilePalette "f,9,12,1c"}{tilePalette "f,9,13,1c"}
NAME 1 yellow dialog

DLG 2l
{tilePalette "f,8,12,1c"}{tilePalette "f,8,13,1c"}
NAME item 24 dialog

DLG 2m
{tilePalette "f,7,12,1c"}{tilePalette "f,7,13,1c"}
NAME 3 yellow dialog

DLG 2n
{tilePalette "f,6,12,1c"}{tilePalette "f,6,13,1c"}
NAME 4 dialog

DLG 2o
{tilePalette "f,5,12,1c"}{tilePalette "f,5,13,1c"}
NAME item 27 dialog

DLG 2p
{tilePalette "f,4,12,1c"}{tilePalette "f,4,13,1c"}
NAME item 28 dialog

DLG 2q
{tilePalette "f,3,12,1c"}{tilePalette "f,3,13,1c"}{tilePalette "f,2,12,1c"}{tilePalette "f,2,13,1c"}
NAME item 29 dialog

DLG 2r
{tilePalette "f,3,11,1c"}{tilePalette "f,2,11,1c"}
NAME item 2a dialog

DLG 2s
{tilePalette "f,3,10,1c"}{tilePalette "f,2,10,1c"}
NAME item 2b dialog

DLG 2t
{tilePalette "f,3,9,1c"}{tilePalette "f,2,9,1c"}
NAME item 2c dialog

DLG 2u
{tilePalette "f,3,8,1c"}{tilePalette "f,2,8,1c"}
NAME item 2d dialog

DLG 2v
{tilePalette "f,3,7,1c"}{tilePalette "f,2,7,1c"}
NAME item 2e dialog

DLG 2w
{tilePalette "f,3,6,1c"}{tilePalette "f,2,6,1c"}
NAME item 2f dialog

DLG 2x
{tilePalette "f,3,5,1c"}{tilePalette "f,2,5,1c"}
NAME item 2g dialog

DLG 2y
{tilePalette "f,3,4,1c"}{tilePalette "f,2,4,1c"}
NAME item 2h dialog

DLG 2z
{tilePalette "f,3,3,1c"}{tilePalette "f,2,3,1c"}{tilePalette "f,3,2,1c"}{tilePalette "f,2,2,1c"}
NAME item 2i dialog

DLG 3a
{tilePalette "h,5,6,1d"}{tilePalette "h,4,6,1d"}
NAME 1 green dialog

DLG 3b
{tilePalette "h,5,7,1d"}{tilePalette "h,4,7,1d"}
NAME 2 green dialog

DLG 3c
{tilePalette "h,5,8,1d"}{tilePalette "h,4,8,1d"}
NAME 3 green dialog

DLG 3d
{tilePalette "h,5,9,1d"}{tilePalette "h,4,9,1d"}
NAME 4 dialog 1

DLG 3e
"""
{exit "20" 5 8}
*GASP*
{pg}
i...i did it?
{pg}
am i actually...
{pg}
DID MY FINGER JUST GO THROUGH MY HAND?!?
{pg}
i don't even know where to start...
{exit "7" 8 2}
{pg}
what...
{pg}
i got too excited...
{pg}
but i finally found a method that works for me!
{pg}
i can't wait to get better at this and have the best dreams
{end}
"""
NAME finished green dialog

DLG 3f
"""
{exit "7" 8 2}
how do some have it so easy?
{pg}
let me see if i can try another method...
{pg}
or maybe try this one again
{exit "9" 10 11}
{pg}
try the MILD method again?
{choice - yes (jump "3g")
  - no
    (jump "3h")}
"""
NAME failed wires dialog

DLG 3g
"""
i'll give this another go...
{exit "14" 14 14}
"""
NAME wires again

DLG 3h
"""
the wild method huh...
{pg}
it's one of the harder ones to do...
{pg}
but i guess i'll give it a try
{exit "15" 1 9}
{pg}
ESCAPE FROM THE KILLER
{pg}
on your way home from work you find yourself being chased
{pg}
make all the right turns to reach the police station
{pg}
otherwise...you'll end up at a dead end
(follower "j")
"""
NAME WILD method

DLG 3i
"""
you found a police station!
{exit "20" 5 8}
{pg}
*GASP*
{pg}
i...i did it?
{pg}
am i actually...
{pg}
DID MY FINGER JUST GO THROUGH MY HAND?!?
{pg}
i don't even know where to start...
{exit "7" 8 2}
{pg}
what...
{pg}
i got too excited...
{pg}
but i finally found a method that works for me!
{pg}
i can't wait to get better at this and have the best dreams
{end}
"""
NAME police station dialog

DLG 3k
"""
(follower "j")
{exit "7" 8 2}
again?!?
{pg}
let me look at the other methods
{exit "8" 10 10}
{pg}
try the reality check method?
{choice - yes (jump "b")
  - no
    (jump "c")}
"""
NAME killer dialog

DLG 3l
"""
(follower "j")
(followerCollision "true")
"""
NAME follow dialog

VAR a
42


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#000;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
	touch-action: none; /* fixing touch-input errors in chrome */

	/* sharp pixel edges */
	/* https://caniuse.com/#search=image-render */
  	-ms-interpolation-mode: nearest-neighbor; /* IE */
  	image-rendering: -moz-crisp-edges; /* FF 6.0+ */
  	image-rendering: pixelated; /* Chrome, Safari */
}

</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	attachCanvas( document.getElementById("game") );
	load_game( document.getElementById("exportedGameData").text.slice(1) );
}
</script>

<script>
//hex-to-rgb method borrowed from stack overflow
function hexToRgb(hex) {
	// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
	var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	hex = hex.replace(shorthandRegex, function(m, r, g, b) {
		return r + r + g + g + b + b;
	});

	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return result ? {
		r: parseInt(result[1], 16),
		g: parseInt(result[2], 16),
		b: parseInt(result[3], 16)
	} : null;
}
function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
    return "#" + componentToHex(Math.floor(r)) + componentToHex(Math.floor(g)) + componentToHex(Math.floor(b));
}

function hslToHex(h,s,l) {
    var rgbArr = hslToRgb(h,s,l);
    return rgbToHex( Math.floor(rgbArr[0]), Math.floor(rgbArr[1]), Math.floor(rgbArr[2]) );
}

function hexToHsl(hex) {
    var rgb = hexToRgb(hex);
    return rgbToHsl(rgb.r, rgb.g, rgb.b);
}

// really just a vector distance
function colorDistance(a1,b1,c1,a2,b2,c2) {
    return Math.sqrt( Math.pow(a1 - a2, 2) + Math.pow(b1 - b2, 2) + Math.pow(c1 - c2, 2) );
}

function hexColorDistance(hex1,hex2) {
    var color1 = hexToRgb(hex1);
    var color2 = hexToRgb(hex2);
    return rgbColorDistance(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b);
}


// source : http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
/* accepts parameters
 * h  Object = {h:x, s:y, v:z}
 * OR 
 * h, s, v
*/
function HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    if (arguments.length === 1) {
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

/* accepts parameters
 * r  Object = {r:x, g:y, b:z}
 * OR 
 * r, g, b
*/
function RGBtoHSV(r, g, b) {
    if (arguments.length === 1) {
        g = r.g, b = r.b, r = r.r;
    }
    var max = Math.max(r, g, b), min = Math.min(r, g, b),
        d = max - min,
        h,
        s = (max === 0 ? 0 : d / max),
        v = max / 255;

    switch (max) {
        case min: h = 0; break;
        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
        case g: h = (b - r) + d * 2; h /= 6 * d; break;
        case b: h = (r - g) + d * 4; h /= 6 * d; break;
    }

    return {
        h: h,
        s: s,
        v: v
    };
}

// source : https://gist.github.com/mjackson/5311256
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [ Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255) ];
}

/**
 * From: http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
 *
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @param   {number}  r       The red color value
 * @param   {number}  g       The green color value
 * @param   {number}  b       The blue color value
 * @return  {Array}           The HSL representation
 */
function rgbToHsl(r, g, b){
    r /= 255, g /= 255, b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min){
        h = s = 0; // achromatic
    }else{
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}
</script>

<script>
var TransitionManager = function() {
	var transitionStart = null;
	var transitionEnd = null;
	var effectImage = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var frameRate = 8; // cap the FPS
	var prevStep = -1; // used to avoid running post-process effect constantly

	this.BeginTransition = function(startRoom,startX,startY,endRoom,endX,endY,effectName) {
		// console.log("--- START ROOM TRANSITION ---");

		curEffect = effectName;

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (transitionEffects[curEffect].showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			player().room = "_transition_none"; // kind of hacky!!
		}

		drawRoom(room[startRoom]);
		var startPalette = getPal( room[startRoom].pal );
		var startImage = new PostProcessImage( ctx.getImageData(0,0,canvas.width,canvas.height) ); // TODO : don't use global ctx?
		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);

		if (transitionEffects[curEffect].showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().room = "_transition_none";
		}

		drawRoom(room[endRoom]);
		var endPalette = getPal( room[endRoom].pal );
		var endImage = new PostProcessImage( ctx.getImageData(0,0,canvas.width,canvas.height) );
		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);

		effectImage = new PostProcessImage( ctx.createImageData(canvas.width,canvas.height) );

		isTransitioning = true;
		transitionTime = 0;
		prevStep = -1;

		player().room = tmpRoom;
		player().x = tmpX;
		player().y = tmpY;
	}

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		transitionTime += dt;

		var transitionDelta = transitionTime / transitionEffects[curEffect].duration;
		var maxStep = Math.floor(frameRate * (transitionEffects[curEffect].duration / 1000));
		var step = Math.floor(transitionDelta * maxStep);

		if (step != prevStep) {
			// console.log("step! " + step + " " + transitionDelta);
			for (var y = 0; y < effectImage.Height; y++) {
				for (var x = 0; x < effectImage.Width; x++) {
					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart,transitionEnd,x,y,(step / maxStep));
					effectImage.SetPixel(x,y,color);
				}
			}
		}
		prevStep = step;

		ctx.putImageData(effectImage.GetData(), 0, 0);

		if (transitionTime >= transitionEffects[curEffect].duration) {
			isTransitioning = false;
			transitionTime = 0;
			transitionStart = null;
			transitionEnd = null;
			effectImage = null;
			prevStep = -1;

			if (transitionCompleteCallback != null) {
				transitionCompleteCallback();
			}
			transitionCompleteCallback = null;
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	// todo : should this be part of the constructor?
	var transitionCompleteCallback = null;
	this.OnTransitionComplete = function(callback) {
		if (isTransitioning) { // TODO : safety check necessary?
			transitionCompleteCallback = callback;
		}
	}

	var transitionEffects = {};
	var curEffect = "none";
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	this.RegisterTransitionEffect("none", {
		showPlayerStart : false,
		showPlayerEnd : false,
		pixelEffectFunc : function() {},
	});

	this.RegisterTransitionEffect("fade_w", { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelColorA = delta < 0.5 ? start.Image.GetPixel(pixelX,pixelY) : {r:255,g:255,b:255,a:255};
			var pixelColorB = delta < 0.5 ? {r:255,g:255,b:255,a:255} : end.Image.GetPixel(pixelX,pixelY);

			delta = delta < 0.5 ? (delta / 0.5) : ((delta - 0.5) / 0.5); // hacky

			return PostProcessUtilities.LerpColor(pixelColorA, pixelColorB, delta);
		}
	});

	this.RegisterTransitionEffect("fade_b", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 750,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelColorA = delta < 0.5 ? start.Image.GetPixel(pixelX,pixelY) : {r:0,g:0,b:0,a:255};
			var pixelColorB = delta < 0.5 ? {r:0,g:0,b:0,a:255} : end.Image.GetPixel(pixelX,pixelY);

			delta = delta < 0.5 ? (delta / 0.5) : ((delta - 0.5) / 0.5); // hacky

			return PostProcessUtilities.LerpColor(pixelColorA, pixelColorB, delta);
		}
	});

	this.RegisterTransitionEffect("wave", {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Image.Width;
			}
			else if (pixelX >= start.Image.Width) {
				pixelX -= start.Image.Width;
			}

			var curImage = delta < 0.5 ? start.Image : end.Image;
			return curImage.GetPixel(pixelX,pixelY);
		}
	});

	this.RegisterTransitionEffect("tunnel", {
		showPlayerStart : true,
		showPlayerEnd : true,
		duration : 1500,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > start.Image.Width * tunnelDelta) {
					return {r:0,g:0,b:0,a:255};
				}
				else {
					return start.Image.GetPixel(pixelX,pixelY);
				}
			}
			else if (delta <= 0.6)
			{
				return {r:0,g:0,b:0,a:255};
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Image.Width * tunnelDelta) {
					return {r:0,g:0,b:0,a:255};
				}
				else {
					return end.Image.GetPixel(pixelX,pixelY);
				}
			}
		}
	});

	this.RegisterTransitionEffect("slide_u", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelY >= 0) {
				var colorA = start.Image.GetPixel(pixelX,slidePixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelY += start.Image.Height;
				var colorB = end.Image.GetPixel(pixelX,slidePixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_d", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelY < start.Image.Height) {
				var colorA = start.Image.GetPixel(pixelX,slidePixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelY -= start.Image.Height;
				var colorB = end.Image.GetPixel(pixelX,slidePixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_l", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelX >= 0) {
				var colorA = start.Image.GetPixel(slidePixelX,pixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelX += start.Image.Width;
				var colorB = end.Image.GetPixel(slidePixelX,pixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	this.RegisterTransitionEffect("slide_r", {
		showPlayerStart : false,
		showPlayerEnd : true,
		duration : 1000,
		pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
			var pixelOffset = Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			var colorDelta = clampLerp(delta, 0.4);

			if (slidePixelX < start.Image.Width) {
				var colorA = start.Image.GetPixel(slidePixelX,pixelY);
				var colorB = PostProcessUtilities.GetCorrespondingColorFromPal(colorA,start.Palette,end.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
			else {
				slidePixelX -= start.Image.Width;
				var colorB = end.Image.GetPixel(slidePixelX,pixelY);
				var colorA = PostProcessUtilities.GetCorrespondingColorFromPal(colorB,end.Palette,start.Palette);
				var colorLerped = PostProcessUtilities.LerpColor(colorA, colorB, colorDelta);
				return colorLerped;
			}
		}
	});

	function clampLerp(deltaIn, clampDuration) {
		var clampOffset = (1.0 - clampDuration) / 2;
		var deltaOut = Math.min(clampDuration, Math.max(0.0, deltaIn - clampOffset)) / clampDuration;
		return deltaOut;
	}

	// TODO : WIP
	// this.RegisterTransitionEffect("fuzz", {
	// 	showPlayerStart : true,
	// 	showPlayerEnd : true,
	// 	duration : 1500,
	// 	pixelEffectFunc : function(start,end,pixelX,pixelY,delta) {
	// 		var curImage = delta <= 0.5 ? start : end;
	// 		var sampleSize = delta <= 0.5 ? (2 + Math.floor(14 * (delta/0.5))) : (16 - Math.floor(14 * ((delta-0.5)/0.5)));

	// 		var palIndex = 0;

	// 		var sampleX = Math.floor(pixelX / sampleSize) * sampleSize;
	// 		var sampleY = Math.floor(pixelY / sampleSize) * sampleSize;

	// 		var frameState = transitionEffects["fuzz"].frameState;

	// 		if (frameState.time != delta) {
	// 			frameState.time = delta;
	// 			frameState.preCalcSampleValues = {};
	// 		}

	// 		if (frameState.preCalcSampleValues[[sampleX,sampleY]]) {
	// 			palIndex = frameState.preCalcSampleValues[[sampleX,sampleY]];
	// 		}
	// 		else {
	// 			var paletteCount = {};
	// 			var foregroundValue = 1.0;
	// 			var backgroundValue = 0.4;
	// 			for (var y = sampleY; y < sampleY + sampleSize; y++) {
	// 				for (var x = sampleX; x < sampleX + sampleSize; x++) {
	// 					var color = curImage.Image.GetPixel(x,y)
	// 					var palIndex = PostProcessUtilities.GetColorPalIndex(color,curImage.Palette);
	// 					if (palIndex != -1) {
	// 						if (paletteCount[palIndex]) {
	// 							paletteCount[palIndex] += (palIndex != 0) ? foregroundValue : backgroundValue;
	// 						}
	// 						else {
	// 							paletteCount[palIndex] = (palIndex != 0) ? foregroundValue : backgroundValue;
	// 						}
	// 					}
	// 				}
	// 			}

	// 			var maxCount = 0;
	// 			for (var i in paletteCount) {
	// 				if (paletteCount[i] > maxCount) {
	// 					palIndex = i;
	// 					maxCount = paletteCount[i];
	// 				}
	// 			}

	// 			frameState.preCalcSampleValues[[sampleX,sampleY]] = palIndex;
	// 		}

	// 		return PostProcessUtilities.GetPalColor(curImage.Palette,palIndex);
	// 	},
	// 	frameState : { // ok this is hacky but it's for performance ok
	// 		time : -1,
	// 		preCalcSampleValues : {}
	// 	}
	// });
}; // TransitionManager()


// TODO : extract the scale variable so it can be changed?
var PostProcessUtilities = {
	SamplePixelColor : function(image,x,y) {
		var pixelIndex = (y * scale * image.width * 4) + (x * scale * 4);
		var r = image.data[pixelIndex + 0];
		var g = image.data[pixelIndex + 1];
		var b = image.data[pixelIndex + 2];
		var a = image.data[pixelIndex + 3];
		return { r:r, g:g, b:b, a:a };
	},
	SetPixelColor : function(image,x,y,colorRgba) {
		for (var yDelta = 0; yDelta < scale; yDelta++) {
			for (var xDelta = 0; xDelta < scale; xDelta++) {
				var pixelIndex = (((y * scale) + yDelta) * image.width * 4) + (((x * scale) + xDelta) * 4);
				image.data[pixelIndex + 0] = colorRgba.r;
				image.data[pixelIndex + 1] = colorRgba.g;
				image.data[pixelIndex + 2] = colorRgba.b;
				image.data[pixelIndex + 3] = colorRgba.a;
			}
		}
	},
	LerpColor : function(colorA,colorB,t) {
		// TODO: move to color_util.js?
		return {
			r : colorA.r + ((colorB.r - colorA.r) * t),
			g : colorA.g + ((colorB.g - colorA.g) * t),
			b : colorA.b + ((colorB.b - colorA.b) * t),
			a : colorA.a + ((colorB.a - colorA.a) * t),
		};
	},
	GetColorPalIndex : function(colorIn,curPal) {
		var colorIndex = -1;

		for (var i = 0; i < curPal.length; i++) {
			if (colorIn.r == curPal[i][0] && colorIn.g == curPal[i][1] && colorIn.b == curPal[i][2]) {
				colorIndex = i;
			}
		}

		return colorIndex;
	},
	GetPalColor : function(palette,index) {
		return { r: palette[index][0], g: palette[index][1], b: palette[index][2], a: 255 }
	},
	GetCorrespondingColorFromPal : function(colorIn,curPal,otherPal) { // this is kind of hacky!
		var colorIndex = PostProcessUtilities.GetColorPalIndex(colorIn,curPal);

		if (colorIndex >= 0 && colorIndex <= otherPal.length) {
			return PostProcessUtilities.GetPalColor(otherPal,colorIndex);
		}
		else {
			return colorIn;
		}
	},
};

var PostProcessImage = function(imageData) {
	this.Width = imageData.width / scale;
	this.Height = imageData.height / scale;

	this.GetPixel = function(x,y) {
		return PostProcessUtilities.SamplePixelColor(imageData,x,y);
	};

	this.SetPixel = function(x,y,colorRgba) {
		PostProcessUtilities.SetPixelColor(imageData,x,y,colorRgba);
	};

	this.GetData = function() {
		return imageData;
	};
};

var TransitionInfo = function(image, palette, playerX, playerY) {
	this.Image = image;
	this.Palette = palette;
	this.PlayerTilePos = { x: playerX, y: playerY };
	this.PlayerCenter = { x: Math.floor((playerX * tilesize) + (tilesize / 2)), y: Math.floor((playerY * tilesize) + (tilesize / 2)) };
};
</script>

<script>
/*
TODO:
- can I simplify this more now that I've removed the external resources stuff?
*/

function FontManager(packagedFontNames) {

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data
var fontResources = {};

// load fonts from the editor
if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0
		&& Resources != undefined && Resources != null) {

	for (var i = 0; i < packagedFontNames.length; i++) {
		var filename = packagedFontNames[i];
		fontResources[filename] = Resources[filename];
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	fontResources[filename] = fontdata;
}

this.ContainsResource = function(filename) {
	return fontResources[filename] != null;
}

function GetData(fontName) {
	return fontResources[fontName + fontExtension];
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};

	// create invalid char data at default size in case the font is missing
	var invalidCharData = {};
	updateInvalidCharData();

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function createCharData() {
		return { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width,
			data: [],
		};
	}

	function updateInvalidCharData() {
		invalidCharData = createCharData();
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	function parseFont(fontData) {
		if (fontData == null) {
			return;
		}

		var lines = fontData.split("\n");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];

			if (line[0] === "#") {
				continue; // skip comment lines
			}

			if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = createCharData();
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= height) {
						isReadingChar = false;
					}
				}
			}
		}

		// re-init invalid character box at the actual font size once it's loaded
		updateInvalidCharData();
	}

	parseFont(fontData);
}

} // FontManager
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		// console.log("COMPILE");
		var script = parser.Parse(scriptStr, scriptName);
		env.SetScript(scriptName, script);
	}
	this.Run = function(scriptName, exitHandler, objectContext) { // Runs pre-compiled script
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = env.GetScript(scriptName);

		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.Interpret = function(scriptStr, exitHandler, objectContext) { // Compiles and runs code immediately
		// console.log("INTERPRET");
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = parser.Parse(scriptStr, "anonymous");
		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	this.Parse = function(scriptStr, rootId) { // parses a script but doesn't save it
		return parser.Parse(scriptStr, rootId);
	}

	// TODO : add back in if needed later...
	// this.CompatibilityParse = function(scriptStr, compatibilityFlags) {
	// 	env.compatibilityFlags = compatibilityFlags;

	// 	var result = parser.Parse(scriptStr);

	// 	delete env.compatibilityFlags;

	// 	return result;
	// }

	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally
		var localEnv = new LocalEnvironment(env); // TODO : does this need an object context?
		scriptTree.Eval(
			localEnv,
			function(result) {
				OnScriptReturn(result, exitHandler);
			});
	}

	function OnScriptReturn(result, exitHandler) {
		if (exitHandler != null) {
			exitHandler(result);
		}
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression(expStr);
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}

	function DebugVisualizeScriptTree(scriptTree) {
		var printVisitor = {
			Visit : function(node,depth) {
				console.log("-".repeat(depth) + "- " + node.ToString());
			},
		};

		scriptTree.VisitAll( printVisitor );
	}

	this.DebugVisualizeScriptTree = DebugVisualizeScriptTree;

	this.DebugVisualizeScript = function(scriptName) {
		DebugVisualizeScriptTree(env.GetScript(scriptName));
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if (doIndentFirstLine === undefined) {
			doIndentFirstLine = true;
		}

		var block = new DialogBlockNode(doIndentFirstLine);

		for (var i = 0; i < children.length; i++) {
			block.AddChild(children[i]);
		}
		return block;
	}

	this.CreateOptionBlock = function() {
		var block = new DialogBlockNode(false);
		block.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		return block;
	}

	this.CreateItemConditionPair = function() {
		var itemFunc = this.CreateFunctionBlock("item", ["0"]);
		var condition = new ExpNode("==", itemFunc, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateVariableConditionPair = function() {
		var varNode = this.CreateVariableNode("a");
		var condition = new ExpNode("==", varNode, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateDefaultConditionPair = function() {
		var condition = this.CreateElseNode();
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateEmptyPrintFunc = function() {
		return new FuncNode("print", [new LiteralNode("...")]);
	}

	this.CreateFunctionBlock = function(name, initParamValues) {
		var parameters = [];
		for (var i = 0; i < initParamValues.length; i++) {
			parameters.push(new LiteralNode(initParamValues[i]));
		}

		var node = new FuncNode(name, parameters);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	// TODO : rename ParseStringToLiteralNode?
	this.CreateLiteralNode = function(str) {
		if (str === "true") {
			return new LiteralNode(true);
		}
		else if (str === "false") {
			return new LiteralNode(false);
		}
		else if (!isNaN(parseFloat(str))) {
			return new LiteralNode(parseFloat(str));
		}
		else {
			return new LiteralNode(str);
		}
	}

	this.CreateVariableNode = function(variableName) {
		return new VarNode(variableName);
	}

	this.CreatePropertyNode = function(propertyName, literalValue) {
		var varNode = new VarNode(propertyName);
		var valNode = new LiteralNode(literalValue);
		var node = new FuncNode("property", [varNode, valNode]);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	this.CreateElseNode = function() {
		return new ElseNode();
	}

	this.CreateStringLiteralNode = function(str) {
		return new LiteralNode(str);
	}

	// TODO : need to split up code & dialog blocks :|
	this.CreateCodeBlock = function() {
		return new CodeBlockNode();
	}

	this.ChangeSequenceType = function(oldSequence, type) {
		if(type === "sequence") {
			return new SequenceNode(oldSequence.children);
		}
		else if(type === "cycle") {
			return new CycleNode(oldSequence.children);
		}
		else if(type === "shuffle") {
			return new ShuffleNode(oldSequence.children);
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateCycleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var sequence = new CycleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateShuffleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var sequence = new ShuffleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new CodeBlockNode();
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new DialogBlockNode();
		result1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var result2 = new DialogBlockNode();
		result2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new CodeBlockNode();
		block.AddChild( ifNode );
		return block;
	}

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
			i++;
		}
		return { script:scriptStr, index:i };
	}

	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript

	this.EnsureDialogBlockFormat = function(dialogStr) {
		// TODO -- what if it's already enclosed in dialog symbols??
		if(dialogStr.indexOf('\n') > -1) {
			dialogStr = Sym.DialogOpen + "\n" + dialogStr + "\n" + Sym.DialogClose;
		}
		return dialogStr;
	}

	this.RemoveDialogBlockFormat = function(source) {
		var sourceLines = source.split("\n");
		var dialogStr = "";
		if(sourceLines[0] === Sym.DialogOpen) {
			// multi line
			var i = 1;
			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {
				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\n' : '');
				i++;
			}
		}
		else {
			// single line
			dialogStr = source;
		}
		return dialogStr;
	}

	this.SerializeDialogNodeList = function(nodeList) {
		var tempBlock = new DialogBlockNode(false);
		 // set children directly to avoid breaking the parenting chain for this temp operation
		tempBlock.children = nodeList;
		return tempBlock.Serialize();
	}

	this.GetOperatorList = function() {
		return [Sym.Set].concat(Sym.Operators);
	}

	this.IsInlineCode = function(node) {
		return isInlineCode(node);
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	console.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

function printFunc(environment, parameters, onReturn) {
	if (parameters[0] != undefined && parameters[0] != null) {
		var textStr = "" + parameters[0];
		environment.GetDialogBuffer().AddText(textStr);
		environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment, parameters, onReturn) {
	// console.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function pagebreakFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddPagebreak(function() { onReturn(null); });
}

function printDrawingFunc(environment, parameters, onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing(drawingId);
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function printSpriteFunc(environment,parameters,onReturn) {
	var spriteId = parameters[0];
	if(names.sprite.has(spriteId)) spriteId = names.sprite.get(spriteId); // id is actually a name
	var drawingId = sprite[spriteId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printTileFunc(environment,parameters,onReturn) {
	var tileId = parameters[0];
	if(names.tile.has(tileId)) tileId = names.tile.get(tileId); // id is actually a name
	var drawingId = tile[tileId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printItemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
	var drawingId = item[itemId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get( fontName );
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	printFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];

	if (names.item.has(itemId)) {
		// id is actually a name
		itemId = names.item.get(itemId);
	}

	var curItemCount = player().inventory[itemId] ? player().inventory[itemId] : 0;

	if (parameters.length > 1) {
		// TODO : is it a good idea to force inventory to be >= 0?
		player().inventory[itemId] = Math.max(0, parseInt(parameters[1]));
		curItemCount = player().inventory[itemId];

		if (onInventoryChanged != null) {
			onInventoryChanged(itemId);
		}
	}

	onReturn(curItemCount);
}

function addOrRemoveTextEffect(environment,name) {
	if( environment.GetDialogBuffer().HasTextEffect(name) )
		environment.GetDialogBuffer().RemoveTextEffect(name);
	else
		environment.GetDialogBuffer().AddTextEffect(name);
}

function rainbowFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"rbw");
	onReturn(null);
}

// TODO : should the colors use a parameter instead of special names?
function color1Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr1");
	onReturn(null);
}

function color2Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr2");
	onReturn(null);
}

function color3Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr3");
	onReturn(null);
}

function wavyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"wvy");
	onReturn(null);
}

function shakyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"shk");
	onReturn(null);
}

function propertyFunc(environment, parameters, onReturn) {
	var outValue = null;

	if (parameters.length > 0 && parameters[0]) {
		var propertyName = parameters[0];

		if (environment.HasProperty(propertyName)) {
			// TODO : in a future update I can handle the case of initializing a new property
			// after which we can move this block outside the HasProperty check
			if (parameters.length > 1) {
				var inValue = parameters[1];
				environment.SetProperty(propertyName, inValue);
			}

			outValue = environment.GetProperty(propertyName);
		}
	}

	console.log("PROPERTY! " + propertyName + " " + outValue);

	onReturn(outValue);
}

function endFunc(environment,parameters,onReturn) {
	isEnding = true;
	isNarrating = true;
	dialogRenderer.SetCentered(true);
	onReturn(null);
}

function exitFunc(environment,parameters,onReturn) {
	var destRoom = parameters[0];

	if (names.room.has(destRoom)) {
		// it's a name, not an id! (note: these could cause trouble if people names things weird)
		destRoom = names.room.get(destRoom);
	}

	var destX = parseInt(parameters[1]);
	var destY = parseInt(parameters[2]);

	if (parameters.length >= 4) {
		var transitionEffect = parameters[3];

		transition.BeginTransition(
			player().room,
			player().x,
			player().y,
			destRoom,
			destX,
			destY,
			transitionEffect);
		transition.UpdateTransition(0);
	}

	player().room = destRoom;
	player().x = destX;
	player().y = destY;
	curRoom = destRoom;
	initRoom(curRoom);

	// TODO : this doesn't play nice with pagebreak because it thinks the dialog is finished!
	if (transition.IsTransitionActive()) {
		transition.OnTransitionComplete(function() { onReturn(null); });
	}
	else {
		onReturn(null);
	}
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// console.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// console.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// console.log("EVAL EQUAL");
	// console.log(left);
	// console.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = new Map();
	functionMap.set("print", printFunc);
	functionMap.set("say", printFunc);
	functionMap.set("br", linebreakFunc);
	functionMap.set("item", itemFunc);
	functionMap.set("rbw", rainbowFunc);
	functionMap.set("clr1", color1Func);
	functionMap.set("clr2", color2Func);
	functionMap.set("clr3", color3Func);
	functionMap.set("wvy", wavyFunc);
	functionMap.set("shk", shakyFunc);
	functionMap.set("printSprite", printSpriteFunc);
	functionMap.set("printTile", printTileFunc);
	functionMap.set("printItem", printItemFunc);
	functionMap.set("debugOnlyPrintFont", printFontFunc); // DEBUG ONLY
	functionMap.set("end", endFunc);
	functionMap.set("exit", exitFunc);
	functionMap.set("pg", pagebreakFunc);
	functionMap.set("property", propertyFunc);

	this.HasFunction = function(name) { return functionMap.has(name); };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		functionMap.get(name)(env, parameters, onReturn);
	}

	var variableMap = new Map();

	this.HasVariable = function(name) { return variableMap.has(name); };
	this.GetVariable = function(name) { return variableMap.get(name); };
	this.SetVariable = function(name,value,useHandler) {
		// console.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap.set(name, value);
		if(onVariableChangeHandler != null && useHandler){
			onVariableChangeHandler(name);
		}
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap.has(name)) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler) {
				onVariableChangeHandler(name);
			}
		}
	};

	var operatorMap = new Map();
	operatorMap.set("=", setExp);
	operatorMap.set("==", equalExp);
	operatorMap.set(">", greaterExp);
	operatorMap.set("<", lessExp);
	operatorMap.set(">=", greaterEqExp);
	operatorMap.set("<=", lessEqExp);
	operatorMap.set("*", multExp);
	operatorMap.set("/", divExp);
	operatorMap.set("+", addExp);
	operatorMap.set("-", subExp);

	this.HasOperator = function(sym) { return operatorMap.get(sym); };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap.get( sym )( this, left, right, onReturn );
	}

	var scriptMap = new Map();
	this.HasScript = function(name) { return scriptMap.has(name); };
	this.GetScript = function(name) { return scriptMap.get(name); };
	this.SetScript = function(name,script) { scriptMap.set(name, script); };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		return Array.from( variableMap.keys() );
	}
}

// Local environment for a single run of a script: knows local context
var LocalEnvironment = function(parentEnvironment) {
	// this.SetDialogBuffer // not allowed in local environment?
	this.GetDialogBuffer = function() { return parentEnvironment.GetDialogBuffer(); };

	this.HasFunction = function(name) { return parentEnvironment.HasFunction(name); };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalFunction(name,parameters,onReturn,env);
	}

	this.HasVariable = function(name) { return parentEnvironment.HasVariable(name); };
	this.GetVariable = function(name) { return parentEnvironment.GetVariable(name); };
	this.SetVariable = function(name,value,useHandler) { parentEnvironment.SetVariable(name,value,useHandler); };
	// this.DeleteVariable // not needed in local environment?

	this.HasOperator = function(sym) { return parentEnvironment.HasOperator(sym); };
	this.EvalOperator = function(sym,left,right,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalOperator(sym,left,right,onReturn,env);
	};

	// TODO : I don't *think* any of this is required by the local environment
	// this.HasScript
	// this.GetScript
	// this.SetScript

	// TODO : pretty sure these debug methods aren't required by the local environment either
	// this.SetOnVariableChangeHandler
	// this.GetVariableNames

	/* Here's where specific local context data goes:
	 * this includes access to the object running the script
	 * and any properties it may have (so far only "locked")
	 */

	// The local environment knows what object called it -- currently only used to access properties
	var curObject = null;
	this.HasObject = function() { return curObject != undefined && curObject != null; }
	this.SetObject = function(object) { curObject = object; }
	this.GetObject = function() { return curObject; }

	// accessors for properties of the object that's running the script
	this.HasProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return true;
		}
		else {
			return false;
		}
	};
	this.GetProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return curObject.property[name]; // TODO : should these be getters and setters instead?
		}
		else {
			return null;
		}
	};
	this.SetProperty = function(name, value) {
		// NOTE : for now, we need to gaurd against creating new properties
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			curObject.property[name] = value;
		}
	};
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// console.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];

	this.AddChild = function(node) {
		this.children.push(node);
		node.parent = this;
	};

	this.AddChildren = function(nodeList) {
		for (var i = 0; i < nodeList.length; i++) {
			this.AddChild(nodeList[i]);
		}
	};

	this.SetChildren = function(nodeList) {
		this.children = [];
		this.AddChildren(nodeList);
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.rootId = null; // for debugging
	this.GetId = function() {
		// console.log(this);
		if (this.rootId != null) {
			return this.rootId;
		}
		else if (this.parent != null) {
			var parentId = this.parent.GetId();
			if (parentId != null) {
				return parentId + "_" + this.parent.children.indexOf(this);
			}
		}
		else {
			return null;
		}
	}
}

var DialogBlockNode = function(doIndentFirstLine) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "dialog_block";

	this.Eval = function(environment, onReturn) {
		// console.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// console.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// console.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	if (doIndentFirstLine === undefined) {
		doIndentFirstLine = true; // This is just for serialization
	}

	this.Serialize = function(depth) {
		if (depth === undefined) {
			depth = 0;
		}

		var str = "";
		var lastNode = null;

		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			var curNodeIsNonInlineCode = curNode.type === "code_block" && !isInlineCode(curNode);
			var prevNodeIsNonInlineCode = lastNode && lastNode.type === "code_block" && !isInlineCode(lastNode);

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");
			var shouldIndentCodeBlock = i > 0 && curNodeIsNonInlineCode;
			var shouldIndentAfterCodeBlock = prevNodeIsNonInlineCode;

			// need to insert a newline before the first block of non-inline code that isn't 
			// preceded by a {br}, since those will create their own newline
			if (i > 0 && curNodeIsNonInlineCode && !prevNodeIsNonInlineCode && !shouldIndentAfterLinebreak) {
				str += "\n";
			}

			if (shouldIndentFirstLine || shouldIndentAfterLinebreak || shouldIndentCodeBlock || shouldIndentAfterCodeBlock) {
				str += leadingWhitespace(depth);
			}

			str += curNode.Serialize(depth);

			if (i < this.children.length-1 && curNodeIsNonInlineCode) {
				str += "\n";
			}

			lastNode = curNode;
		}

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

var CodeBlockNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = "code_block";

	this.Eval = function(environment, onReturn) {
		// console.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// console.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// console.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	this.Serialize = function(depth) {
		if(depth === undefined) {
			depth = 0;
		}

		// console.log("SERIALIZE BLOCK!!!");
		// console.log(depth);
		// console.log(doIndentFirstLine);

		var str = "{"; // todo: increase scope of Sym?

		// TODO : do code blocks ever have more than one child anymore????
		for (var i = 0; i < this.children.length; i++) {
			var curNode = this.children[i];
			str += curNode.Serialize(depth);
		}

		str += "}";

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function isInlineCode(node) {
	return isTextEffectBlock(node) || isUndefinedBlock(node) || isMultilineListBlock(node);
}

function isUndefinedBlock(node) {
	return node.type === "code_block" && node.children.length > 0 && node.children[0].type === "undefined";
}

var textEffectBlockNames = ["clr1", "clr2", "clr3", "wvy", "shk", "rbw", "printSprite", "printItem", "printTile", "print", "say", "br"];
function isTextEffectBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			return textEffectBlockNames.indexOf(func.name) != -1;
		}
	}
	return false;
}

var listBlockTypes = ["sequence", "cycle", "shuffle", "if"];
function isMultilineListBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0) {
			var child = node.children[0];
			return listBlockTypes.indexOf(child.type) != -1;
		}
	}
	return false;
}

// for round-tripping undefined code through the parser (useful for hacks!)
var UndefinedNode = function(sourceStr) {
	Object.assign(this, new TreeRelationship());
	this.type = "undefined";
	this.source = sourceStr;

	this.Eval = function(environment,onReturn) {
		addOrRemoveTextEffect(environment, "_debug_highlight");
		printFunc(environment, ["{" + sourceStr + "}"], function() {
			onReturn(null);
		});
		addOrRemoveTextEffect(environment, "_debug_highlight");
	}

	this.Serialize = function(depth) {
		return this.source;
	}

	this.ToString = function() {
		return "undefined" + " " + this.GetId();
	}
}

var FuncNode = function(name,args) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "function";
	this.name = name;
	this.args = args;

	this.Eval = function(environment,onReturn) {
		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var self = this; // hack to deal with scope (TODO : move up higher?)

		var argumentValues = [];
		var i = 0;

		function evalArgs(args, done) {
			// TODO : really hacky way to make we get the first
			// symbol's NAME instead of its variable value
			// if we are trying to do something with a property
			if (self.name === "property" && i === 0 && i < args.length) {
				if (args[i].type === "variable") {
					argumentValues.push(args[i].name);
					i++;
				}
				else {
					// first argument for a property MUST be a variable symbol
					// -- so skip everything if it's not!
					i = args.length;
				}
			}

			if (i < args.length) {
				// Evaluate each argument
				args[i].Eval(
					environment,
					function(val) {
						argumentValues.push(val);
						i++;
						evalArgs(args, done);
					});
			}
			else {
				done();
			}
		};

		evalArgs(
			this.args,
			function() {
				if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
					events.Raise("script_node_exit", { id: self.GetId() });
				}

				environment.EvalFunction(self.name, argumentValues, onReturn);
			});
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.type === "dialog_block";
		if (isDialogBlock && this.name === "print") {
			// TODO this could cause problems with "real" print functions
			return this.args[0].value; // first argument should be the text of the {print} func
		}
		else if (isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.args.length; i++) {
				str += " ";
				str += this.args[i].Serialize(depth);
			}
			return str;
		}
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

var LiteralNode = function(value) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	}

	this.Serialize = function(depth) {
		var str = "";

		if (this.value === null) {
			return str;
		}

		if (typeof this.value === "string") {
			str += '"';
		}

		str += this.value;

		if (typeof this.value === "string") {
			str += '"';
		}

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.value + " " + this.GetId();
	};
}

var VarNode = function(name) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

var ExpNode = function(operator, left, right) {
	Object.assign( this, new TreeRelationship() );
	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// console.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// console.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	}

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if (!isNegativeNumber) {
			var str = "";

			if (this.left != undefined && this.left != null) {
				str += this.left.Serialize(depth) + " ";
			}

			str += this.operator;

			if (this.right != undefined && this.right != null) {
				str += " " + this.right.Serialize(depth);
			}

			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		if(this.left != null)
			this.left.VisitAll( visitor, depth + 1 );
		if(this.right != null)
			this.right.VisitAll( visitor, depth + 1 );
	};

	this.ToString = function() {
		return this.type + " " + this.operator + " " + this.GetId();
	};
}

var SequenceBase = function() {
	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.children.length; i++) {
			str += leadingWhitespace(depth + 1) + Sym.List + " ";
			str += this.children[i].Serialize(depth + 2);
			str += "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

var SequenceNode = function(options) {
	Object.assign(this, new TreeRelationship());
	Object.assign(this, new SequenceBase());
	this.type = "sequence";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// console.log("SEQUENCE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
	}
}

var CycleNode = function(options) {
	Object.assign(this, new TreeRelationship());
	Object.assign(this, new SequenceBase());
	this.type = "cycle";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// console.log("CYCLE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
		else {
			index = 0;
		}
	}
}

var ShuffleNode = function(options) {
	Object.assign(this, new TreeRelationship());
	Object.assign(this, new SequenceBase());
	this.type = "shuffle";
	this.AddChildren(options);

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while (optionsUnshuffled.length > 0) {
			var i = Math.floor(Math.random() * optionsUnshuffled.length);
			optionsShuffled.push(optionsUnshuffled.splice(i,1)[0]);
		}
	}
	shuffle(this.children);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		optionsShuffled[index].Eval(environment, onReturn);
		
		index++;
		if (index >= this.children.length) {
			shuffle(this.children);
			index = 0;
		}
	}
}

// TODO : rename? ConditionalNode?
var IfNode = function(conditions, results, isSingleLine) {
	Object.assign(this, new TreeRelationship());
	this.type = "if";

	for (var i = 0; i < conditions.length; i++) {
		this.AddChild(new ConditionPairNode(conditions[i], results[i]));
	}

	var self = this;
	this.Eval = function(environment, onReturn) {
		// console.log("EVAL IF");
		var i = 0;
		function TestCondition() {
			self.children[i].Eval(environment, function(result) {
				if (result.conditionValue == true) {
					onReturn(result.resultValue);
				}
				else if (i+1 < self.children.length) {
					i++;
					TestCondition();
				}
				else {
					onReturn(null);
				}
			});
		};
		TestCondition();
	}

	if (isSingleLine === undefined) {
		isSingleLine = false; // This is just for serialization
	}

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			// HACKY - should I even keep this mode???
			str += this.children[0].children[0].Serialize() + " ? " + this.children[0].children[1].Serialize();
			if (this.children.length > 1 && this.children[1].children[0].type === Sym.Else) {
				str += " " + Sym.ElseExp + " " + this.children[1].children[1].Serialize();
			}
		}
		else {
			str += "\n";
			for (var i = 0; i < this.children.length; i++) {
				str += this.children[i].Serialize(depth);
			}
			str += leadingWhitespace(depth);
		}
		return str;
	}

	this.IsSingleLine = function() {
		return isSingleLine;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

var ConditionPairNode = function(condition, result) {
	Object.assign(this, new TreeRelationship());

	this.type = "condition_pair";

	this.AddChild(condition);
	this.AddChild(result);

	var self = this;

	this.Eval = function(environment, onReturn) {
		self.children[0].Eval(environment, function(conditionSuccess) {
			if (conditionSuccess) {
				self.children[1].Eval(environment, function(resultValue) {
					onReturn({ conditionValue:true, resultValue:resultValue });
				});
			}
			else {
				onReturn({ conditionValue:false });
			}
		});
	}

	this.Serialize = function(depth) {
		var str = "";
		str += leadingWhitespace(depth + 1);
		str += Sym.List + " " + this.children[0].Serialize(depth) + " " + Sym.ConditionEnd + Sym.Linebreak;
		str += this.children[1].Serialize(depth + 2) + Sym.Linebreak;
		return str;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	}
}

var ElseNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = Sym.Else;

	this.Eval = function(environment, onReturn) {
		onReturn(true);
	}

	this.Serialize = function() {
		return Sym.Else;
	}

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

var Sym = {
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"',
	ConditionEnd : "?",
	Else : "else",
	ElseExp : ":", // special shorthand for expressions (deprecate?)
	Set : "=",
	Operators : ["==", ">=", "<=", ">", "<", "-", "+", "/", "*"], // operators need to be in reverse order of precedence
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr, rootId) {
		var rootNode = new DialogBlockNode();
		rootNode.rootId = rootId;
		var state = new ParserState(rootNode, scriptStr);

		console.log(scriptStr);
		console.log(state.Source());

		if (state.MatchAhead(Sym.DialogOpen)) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock(Sym.DialogOpen + Sym.Linebreak, Sym.Linebreak + Sym.DialogClose);
			rootNode = new DialogBlockNode();
			rootNode.rootId = rootId; // hacky!!
			state = new ParserState(rootNode, dialogStr);
			state = ParseDialog(state);
		}
		else {
			// single-line dialog block
			state = ParseDialog(state);
		}

		return state.rootNode;
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// console.log(str);
			str = "" + str; // hack to turn single chars into strings
			// console.log(str);
			// console.log(str.length);
			for (var j = 0; j < str.length; j++) {
				if (i + j >= sourceStr.length) {
					return false;
				}
				else if (str[j] != sourceStr[i+j]) {
					return false;
				}
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// console.log(j);
			while (j < sourceStr.length && end.indexOf(sourceStr[j]) == -1) {
				str += sourceStr[j];
				j++;
			}
			// console.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function(open, close, includeSymbols) {
			if (includeSymbols === undefined || includeSymbols === null) {
				includeSymbols = false;
			}

			var startIndex = i;

			var matchCount = 0;
			if (this.MatchAhead(open)) {
				matchCount++;
				this.Step(open.length);
			}

			while (matchCount > 0 && !this.Done()) {
				if (this.MatchAhead(close)) {
					matchCount--;
					this.Step( close.length );
				}
				else if (this.MatchAhead(open)) {
					matchCount++;
					this.Step(open.length);
				}
				else {
					this.Step();
				}
			}

			if (includeSymbols) {
				return sourceStr.slice(startIndex, i);
			}
			else {
				return sourceStr.slice(startIndex + open.length, i - close.length);
			}
		}

		this.Print = function() { console.log(sourceStr); };
		this.Source = function() { return sourceStr; };
	};

	/*
		ParseDialog():
		This function adds {print} nodes and linebreak {br} nodes to display text,
		interleaved with bracketed code nodes for functions and flow control,
		such as text effects {shk} {wvy} or sequences like {cycle} and {shuffle}.
		The parsing of those code blocks is handled by ParseCode.

		Note on parsing newline characters:
		- there should be an implicit linebreak {br} after each dialog line
		- a "dialog line" is defined as any line that either:
			- 1) contains dialog text (any text outside of a code block)
			- 2) is entirely empty (no text, no code)
			- *or* 3) contains a list block (sequence, cycle, shuffle, or conditional)
		- lines *only* containing {code} blocks are not dialog lines

		NOTE TO SELF: all the state I'm storing in here feels like
		evidence that the parsing system kind of broke down at this point :(
		Maybe it would feel better if I move into the "state" object
	*/
	function ParseDialog(state) {
		var curLineNodeList = [];
		var curText = "";
		var curLineIsEmpty = true;
		var curLineContainsDialogText = false;
		var prevLineIsDialogLine = false;

		var curLineIsDialogLine = function() {
			return curLineContainsDialogText || curLineIsEmpty;
		}

		var resetLineStateForNewLine = function() {
			prevLineIsDialogLine = curLineIsDialogLine();
			curLineContainsDialogText = false;
			curLineIsEmpty = true;
			curText = "";
			curLineNodeList = [];
		}

		var tryAddTextNodeToList = function() {
			if (curText.length > 0) {
				var printNode = new FuncNode("print", [new LiteralNode(curText)]);
				curLineNodeList.push(printNode);

				curText = "";
				curLineIsEmpty = false;
				curLineContainsDialogText = true;
			}
		}

		var addCodeNodeToList = function() {
			var codeSource = state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			var codeState = new ParserState(new CodeBlockNode(), codeSource);
			codeState = ParseCode(codeState);
			var codeBlockNode = codeState.rootNode;
			curLineNodeList.push(codeBlockNode);

			curLineIsEmpty = false;

			// lists count as dialog text, because they can contain it
			if (isMultilineListBlock(codeBlockNode)) {
				curLineContainsDialogText = true;
			}
		}

		var tryAddLinebreakNodeToList = function() {
			if (prevLineIsDialogLine) {
				var linebreakNode = new FuncNode("br", []);
				curLineNodeList.unshift(linebreakNode);
			}
		}

		var addLineNodesToParent = function() {
			for (var i = 0; i < curLineNodeList.length; i++) {
				state.curNode.AddChild(curLineNodeList[i]);
			}
		}

		while (!state.Done()) {
			if (state.MatchAhead(Sym.CodeOpen)) { // process code block
				// add any buffered text to a print node, and parse the code
				tryAddTextNodeToList();
				addCodeNodeToList();
			}
			else if (state.MatchAhead(Sym.Linebreak)) { // process new line
				// add any buffered text to a print node, 
				// and add a linebreak if we are between two dialog lines
				tryAddTextNodeToList();
				tryAddLinebreakNodeToList();

				// since we've reached the end of a line
				// add stored nodes for this line to the parent node we are building,
				// and reset state for the next line
				addLineNodesToParent();
				resetLineStateForNewLine();

				state.Step();
			}
			else {
				// continue adding text to the current text buffer
				curText += state.Char();
				state.Step();
			}
		}

		// to make sure we don't leave anything behind:
		// add buffered text to a print node and add all nodes
		// to the current parent node
		tryAddTextNodeToList();
		tryAddLinebreakNodeToList();
		addLineNodesToParent();

		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState(new DialogBlockNode(), dialogStr);
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	/*
		ParseConditional():
		A conditional contains a list of conditions that can be
		evaluated to true or false, followed by more dialog
		that will be evaluated if the condition is true. The first
		true condition is the one that gets evaluated.
	*/
	function ParseConditional(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var requiredLeadingWhitespace = -1;

		// TODO : very similar to sequence parsing - can we share anything?
		function parseConditionalItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewCondition = false;
			var encounteredNonWhitespace = false;
			var encounteredConditionEnd = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewCondition = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// if this is the condition, we need to track whether we've
				// reached the end of the condition
				if (isNewCondition && !encounteredConditionEnd) {
					if (state.Char() === Sym.ConditionEnd) {
						encounteredConditionEnd = true;
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					if (!encounteredConditionEnd) { // skip all characters including & after the condition end
						lineText += state.Char();
					}
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewCondition:isNewCondition };
		}

		// TODO : this is copied from sequence parsing; share?
		function trimLeadingWhitespace(text, trimLength) {
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseConditionalItemLine(state);

			if (lineResults.isNewCondition) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curIndex++;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}

			// to avoid extra newlines in nested conditionals, only count lines
			// that at least match the whitespace count of the initial line
			// NOTE: see the comment in sequence parsing for more details
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);

				if (lineResults.isNewCondition) {
					conditionStrings[curIndex] += trimmedText;
				}
				else {
					resultStrings[curIndex] += trimmedText + Sym.Linebreak;
				}
			}
		}

		// hack: cut off the trailing newlines from all the result strings
		resultStrings = resultStrings.map(function(result) { return result.slice(0,-1); });

		var conditions = [];
		for (var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if (str === Sym.Else) {
				conditions.push(new ElseNode());
			}
			else {
				var exp = CreateExpression(str);
				conditions.push(exp);
			}
		}

		var results = [];
		for (var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			results.push(dialogBlock);
		}

		state.curNode.AddChild(new IfNode(conditions, results));

		return state;
	}

	function IsSequence(str) {
		// console.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	/*
		ParseSequence():
		Sequence nodes contain a list of dialog block nodes. The order those
		nodes are evaluated is determined by the type of sequence:
		- sequence: each child node evaluated once in order
		- cycle: repeats from the beginning after all nodes evaluate
		- shuffle: evaluate in a random order

		Each item in a sequence is sepearated by a "-" character.
		The seperator must come at the beginning of the line,
		but may be preceded by whitespace (in any amount).

		About whitespace: Whitespace at the start of a line
		is ignored if it less than or equal to the count of
		whitespace that preceded the list separator ("-") at
		the start of that item. (The count also includes the
		seperator and the extra space after the seperator.)
	 */
	function ParseSequence(state, sequenceType) {
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var requiredLeadingWhitespace = -1;

		function parseSequenceItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewListItem = false;
			var encounteredNonWhitespace = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewListItem = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					lineText += state.Char();
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewListItem:isNewListItem };
		}

		function trimLeadingWhitespace(text, trimLength) {
			// the split and join is necessary because a single "line"
			// can contain sequences that may contain newlines of their own
			// (we treat them all as one "line" for sequence parsing purposes)
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseSequenceItemLine(state);

			if (lineResults.isNewListItem) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}

			// to avoid double counting closing lines (empty ones ending in a curly brace)
			// we only allow lines that have at least as much whitespace as the start of the list item
			// TODO : I think right now this leads to a bug if the list item's indentation is less than
			// its parent code block... hopefully that won't be a big deal for now
			// (NOTE: I think the bug could be fixed by only applying this to the FINAL line of an item, but
			// that would require more consideration and testing)
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);
				itemStrings[curItemIndex] += trimmedText + Sym.Linebreak;
			}
		}

		// a bit hacky: cut off the trailing newlines from all the items
		itemStrings = itemStrings.map(function(item) { return item.slice(0,-1); });

		var options = [];
		for (var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(false /* doIndentFirstLine */), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			options.push(dialogBlock);
		}

		if (sequenceType === "sequence") {
			state.curNode.AddChild(new SequenceNode(options));
		}
		else if (sequenceType === "cycle") {
			state.curNode.AddChild(new CycleNode(options));
		}
		else if (sequenceType === "shuffle") {
			state.curNode.AddChild(new ShuffleNode(options));
		}

		return state;
	}

	function ParseFunction(state, funcName) {
		console.log("~~~ PARSE FUNCTION " + funcName);

		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// console.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// console.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState(new CodeBlockNode(), state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose));
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// console.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// console.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState(new CodeBlockNode(), codeStr);
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// console.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// console.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// console.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// console.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	function CreateExpression(expStr) {
		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}

		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(Sym.Set);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = Sym.Set;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+Sym.Set.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(Sym.ConditionEnd);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = Sym.ConditionEnd;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+Sym.ConditionEnd.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState(new DialogBlockNode(), str);
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(Sym.ElseExp); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+Sym.ElseExp.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < Sym.Operators.length); i++ ) {
			var opSym = Sym.Operators[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function IsWhitespace(str) {
		return ( str === " " || str === "\t" || str === "\n" );
	}

	function IsExpression(str) {
		var tempState = new ParserState(null, str); // hacky
		var textOutsideCodeBlocks = "";

		while (!tempState.Done()) {
			if (tempState.MatchAhead(Sym.CodeOpen)) {
				tempState.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			}
			else {
				textOutsideCodeBlocks += tempState.Char();
				tempState.Step();
			}
		}

		var containsAnyExpressionOperators = (textOutsideCodeBlocks.indexOf(Sym.ConditionEnd) != -1) ||
				(textOutsideCodeBlocks.indexOf(Sym.Set) != -1) ||
				(Sym.Operators.some(function(opSym) { return textOutsideCodeBlocks.indexOf(opSym) != -1; }));

		return containsAnyExpressionOperators;
	}

	function IsLiteral(str) {
		var isBool = str === "true" || str === "false";
		var isNum = !isNaN(parseFloat(str));
		var isStr = str[0] === '"' && str[str.length-1] === '"';
		var isVar = IsValidVariableName(str);
		var isEmpty = str.length === 0;
		return isBool || isNum || isStr || isVar || isEmpty;
	}

	function ParseExpression(state) {
		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing
		// console.log("EXPRESSION " + line);
		var exp = CreateExpression(line);
		// console.log(exp);
		state.curNode.AddChild(exp);
		state.Step(line.length);
		return state;
	}

	function IsConditionalBlock(state) {
		var peakToFirstListSymbol = state.Peak([Sym.List]);

		var foundListSymbol = peakToFirstListSymbol < state.Source().length;

		var areAllCharsBeforeListWhitespace = true;
		for (var i = 0; i < peakToFirstListSymbol.length; i++) {
			if (!IsWhitespace(peakToFirstListSymbol[i])) {
				areAllCharsBeforeListWhitespace = false;
			}
		}

		var peakToFirstConditionSymbol = state.Peak([Sym.ConditionEnd]);
		peakToFirstConditionSymbol = peakToFirstConditionSymbol.slice(peakToFirstListSymbol.length);
		var hasNoLinebreakBetweenListAndConditionEnd = peakToFirstConditionSymbol.indexOf(Sym.Linebreak) == -1;

		return foundListSymbol && 
			areAllCharsBeforeListWhitespace && 
			hasNoLinebreakBetweenListAndConditionEnd;
	}

	function ParseCode(state) {
		if (IsConditionalBlock(state)) {
			state = ParseConditional(state);
		}
		else if (environment.HasFunction(state.Peak([" "]))) { // TODO --- what about newlines???
			var funcName = state.Peak([" "]);
			state.Step(funcName.length);
			state = ParseFunction(state, funcName);
		}
		else if (IsSequence(state.Peak([" ", Sym.Linebreak]))) {
			var sequenceType = state.Peak([" ", Sym.Linebreak]);
			state.Step(sequenceType.length);
			state = ParseSequence(state, sequenceType);
		}
		else if (IsLiteral(state.Source()) || IsExpression(state.Source())) {
			state = ParseExpression(state);
		}
		else {
			var undefinedSrc = state.Peak([]);
			var undefinedNode = new UndefinedNode(undefinedSrc);
			state.curNode.AddChild(undefinedNode);
		}

		// just go to the end now
		while (!state.Done()) {
			state.Step();
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
		var codeState = new ParserState(new CodeBlockNode(), codeStr);
		codeState = ParseCode( codeState );
		state.curNode.AddChild( codeState.rootNode );
		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {

	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		img : null,
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		font_scale : 0.5, // we draw font at half-size compared to everything else
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;
		textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);
	}

	function textScale() {
		return scale * textboxInfo.font_scale;
	}

	function relativeFontWidth() {
		return Math.ceil( font.getWidth() * textboxInfo.font_scale );
	}

	function relativeFontHeight() {
		return Math.ceil( font.getHeight() * textboxInfo.font_scale );
	}

	var context = null;
	this.AttachContext = function(c) {
		context = c;
	};

	this.ClearTextbox = function() {
		if(context == null) return;

		//create new image none exists
		if(textboxInfo.img == null)
			textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);

		// fill text box with black
		for (var i=0;i<textboxInfo.img.data.length;i+=4)
		{
			textboxInfo.img.data[i+0]=0;
			textboxInfo.img.data[i+1]=0;
			textboxInfo.img.data[i+2]=0;
			textboxInfo.img.data[i+3]=255;
		}
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	this.DrawTextbox = function() {
		if(context == null) return;
		if (isCentered) {
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, ((height/2)-(textboxInfo.height/2))*scale);
		}
		else if (player().y < mapsize/2) {
			//bottom
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, (height-textboxInfo.bottom-textboxInfo.height)*scale);
		}
		else {
			//top
			context.putImageData(textboxInfo.img, textboxInfo.left*scale, textboxInfo.top*scale);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];
	this.DrawNextArrow = function() {
		// console.log("draw arrow!");
		var top = (textboxInfo.height-5) * scale;
		var left = (textboxInfo.width-(5+4)) * scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < scale; sy++) {
						for (var sx = 0; sx < scale; sx++) {
							var pxl = 4 * ( ((top+(y*scale)+sy) * (textboxInfo.width*scale)) + (left+(x*scale)+sx) );
							textboxInfo.img.data[pxl+0] = 255;
							textboxInfo.img.data[pxl+1] = 255;
							textboxInfo.img.data[pxl+2] = 255;
							textboxInfo.img.data[pxl+3] = 255;
						}
					}
				}
			}
		}
	};

	var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better
	this.DrawChar = function(char, row, col, leftPos) {
		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		}; // compute render offset *every* frame

		char.SetPosition(row,col);
		char.ApplyEffects(effectTime);

		var charData = char.bitmap;

		var top = (4 * scale) + (row * 2 * scale) + (row * font.getHeight() * text_scale) + Math.floor( char.offset.y );
		var left = (4 * scale) + (leftPos * text_scale) + Math.floor( char.offset.x );

		var debug_r = Math.random() * 255;

		for (var y = 0; y < char.height; y++) {
			for (var x = 0; x < char.width; x++) {

				var i = (y * char.width) + x;
				if ( charData[i] == 1 ) {

					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
							textboxInfo.img.data[pxl+0] = char.color.r;
							textboxInfo.img.data[pxl+1] = char.color.g;
							textboxInfo.img.data[pxl+2] = char.color.b;
							textboxInfo.img.data[pxl+3] = char.color.a;
						}
					}
				}
				// else {
				// 	// DEBUG

				// 	//scaling nonsense
				// 	for (var sy = 0; sy < text_scale; sy++) {
				// 		for (var sx = 0; sx < text_scale; sx++) {
				// 			var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
				// 			textboxInfo.img.data[pxl+0] = debug_r;
				// 			textboxInfo.img.data[pxl+1] = 0;
				// 			textboxInfo.img.data[pxl+2] = 0;
				// 			textboxInfo.img.data[pxl+3] = 255;
				// 		}
				// 	}
				// }

			}
		}
		
		// call printHandler for character
		char.OnPrint();
	};

	var effectTime = 0; // TODO this variable should live somewhere better
	this.Draw = function(buffer, dt) {
		effectTime += dt;

		this.ClearTextbox();

		buffer.ForEachActiveChar(this.DrawChar);

		if (buffer.CanContinue()) {
			this.DrawNextArrow();
		}

		this.DrawTextbox();

		if (buffer.DidPageFinishThisFrame() && onPageFinish != null) {
			onPageFinish();
		}
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?
	}

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}


var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var font = null;
	var arabicHandler = new ArabicHandler();
	var onDialogEndCallbacks = [];

	this.SetFont = function(f) {
		font = f;
	}

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// console.log(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// console.log(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		afterManualPagebreak = false;

		activeTextEffects = [];

		onDialogEndCallbacks = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;
		}

		if (this.CurChar() != null) {
			if (this.CurChar().isPageBreak) {
				// special case for page break marker character!
				isDialogReadyToContinue = true;
				didPageFinishThisFrame = true;
			}
			
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
		}
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	this.Skip = function() {
		console.log("SKIPPP");
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount()) {
			this.DoNextChar();

			if(isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}
		rowIndex = this.CurRowCount()-1;
		charIndex = this.CurCharCount()-1;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog

		for (var i = 0; i < onDialogEndCallbacks.length; i++) {
			onDialogEndCallbacks[i]();
		}
	}

	var afterManualPagebreak = false; // is it bad to track this state like this?

	this.Continue = function() {
		console.log("CONTINUE");

		// if we used a page break character to continue we need
		// to run whatever is in the script afterwards! // TODO : make this comment better
		if (this.CurChar().isPageBreak) {
			// hacky: always treat a page break as the end of dialog
			// if there's more dialog later we re-activate the dialog buffer
			this.EndDialog();
			afterManualPagebreak = true;
			this.CurChar().OnContinue();
			return false;
		}
		if (pageIndex + 1 < this.CurPageCount()) {
			console.log("FLIP PAGE!");
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			console.log("END DIALOG!");
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.OnDialogEnd = function(callback) {
		if (!isActive) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar(effectList) {
		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)

		this.color = { r:255, g:255, b:255, a:255 };
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// console.log("SET POS");
			// console.log(this);
			this.row = row;
			this.col = col;
		}

		this.ApplyEffects = function(time) {
			// console.log("APPLY EFFECTS! " + time);
			for(var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// console.log("FX " + effectName);
				TextEffects[ effectName ].DoEffect( this, time );
			}
		}

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		}
		this.OnPrint = function() {
			if (printHandler != null) {
				// console.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		}

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var charData = font.getChar(char);
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
	}

	function DialogDrawingChar(drawingId, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var imageData = renderer.GetImageSource(drawingId)[0];
		var imageDataFlat = [];
		for (var i = 0; i < imageData.length; i++) {
			// console.log(imageData[i]);
			imageDataFlat = imageDataFlat.concat(imageData[i]);
		}

		this.bitmap = imageDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function DialogScriptControlChar() {
		Object.assign(this, new DialogChar([]));

		this.width = 0;
		this.height = 0;
		this.spacing = 0;
	}

	// is a control character really the best way to handle page breaks?
	function DialogPageBreakChar() {
		Object.assign(this, new DialogChar([]));

		this.width = 0;
		this.height = 0;
		this.spacing = 0;

		this.isPageBreak = true;

		var continueHandler = null;

		this.SetContinueHandler = function(handler) {
			continueHandler = handler;
		}

		this.OnContinue = function() {
			if (continueHandler) {
				continueHandler();
			}
		}
	}

	function AddWordToCharArray(charArray,word,effectList) {
		for(var i = 0; i < word.length; i++) {
			charArray.push( new DialogFontChar( font, word[i], effectList ) );
		}
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddScriptReturn = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var controlChar = new DialogScriptControlChar();
		controlChar.SetPrintHandler(onReturnHandler);

		curRowArr.push(controlChar);

		isActive = true;
	}

	this.AddDrawing = function(drawingId) {
		// console.log("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects);

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (afterManualPagebreak) {
			this.FlipPage(); // hacky

			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);

			afterManualPagebreak = false;
		}
		else if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0) {
			//stay on same row
			curRowArr.push(drawingChar);
		}
		else if (curRowIndex == 0) {
			//start next row
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer[curPageIndex].push([]);
			curRowIndex++;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}
		else {
			//start next page
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr) {
		console.log("ADD TEXT " + textStr);

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth(wordWithPrecedingSpace);

			var rowLength = GetCharArrayWidth(curRowArr);

			if (afterManualPagebreak) {
				this.FlipPage();

				// hacky copied bit for page breaks
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);

				afterManualPagebreak = false;
			}
			else if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray(curRowArr, wordWithPrecedingSpace, activeTextEffects);
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer[curPageIndex].push([]);
				curRowIndex++;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);
			}
			else {
				//start next page
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[buffer.length-1];
		var lastRow = lastPage[lastPage.length-1];
		if (lastRow.length == 0) {
			lastPage.splice(lastPage.length-1, 1);
		}
		if (lastPage.length == 0) {
			buffer.splice(buffer.length-1, 1);
		}

		//finish up 
		lastPage = buffer[buffer.length-1];
		lastRow = lastPage[lastPage.length-1];
		if (lastRow.length > 0) {
			var lastChar = lastRow[lastRow.length-1];
		}

		// console.log(buffer);

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[buffer.length-1];
		if (lastPage.length <= 1) {
			// console.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push([]);
		}
		else {
			// add new page
			buffer.push([[]]);
		}
		// console.log(buffer);

		isActive = true;
	}

	this.AddPagebreak = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		// need to actually create a whole new page if following another pagebreak character
		if (this.CurChar() && this.CurChar().isPageBreak) {
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
		}

		var pagebreakChar = new DialogPageBreakChar();
		pagebreakChar.SetContinueHandler(onReturnHandler);

		curRowArr.push(pagebreakChar);

		isActive = true;		
	}

	/* new text effects */
	this.HasTextEffect = function(name) {
		return activeTextEffects.indexOf( name ) > -1;
	}
	this.AddTextEffect = function(name) {
		activeTextEffects.push( name );
	}
	this.RemoveTextEffect = function(name) {
		activeTextEffects.splice( activeTextEffects.indexOf( name ), 1 );
	}

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* NEW TEXT EFFECTS */
var TextEffects = new Map();

var RainbowEffect = function() { // TODO - should it be an object or just a method?
	this.DoEffect = function(char,time) {
		// console.log("RAINBOW!!!");
		// console.log(char);
		// console.log(char.color);
		// console.log(char.col);

		var h = Math.abs( Math.sin( (time / 600) - (char.col / 8) ) );
		var rgb = hslToRgb( h, 1, 0.5 );
		char.color.r = rgb[0];
		char.color.g = rgb[1];
		char.color.b = rgb[2];
		char.color.a = 255;
	}
};
TextEffects["rbw"] = new RainbowEffect();

var ColorEffect = function(index) {
	this.DoEffect = function(char) {
		var pal = getPal( curPal() );
		var color = pal[ parseInt( index ) ];
		// console.log(color);
		char.color.r = color[0];
		char.color.g = color[1];
		char.color.b = color[2];
		char.color.a = 255;
	}
};
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1); // TODO : should I use parameters instead of special names?
TextEffects["clr3"] = new ColorEffect(2);

var WavyEffect = function() {
	this.DoEffect = function(char,time) {
		char.offset.y += Math.sin( (time / 250) - (char.col / 2) ) * 4;
	}
};
TextEffects["wvy"] = new WavyEffect();

var ShakyEffect = function() {
	function disturb(func,time,offset,mult1,mult2) {
		return func( (time * mult1) - (offset * mult2) );
	}

	this.DoEffect = function(char,time) {
		char.offset.y += 3
						* disturb(Math.sin,time,char.col,0.1,0.5)
						* disturb(Math.cos,time,char.col,0.3,0.2)
						* disturb(Math.sin,time,char.row,2.0,1.0);
		char.offset.x += 3
						* disturb(Math.cos,time,char.row,0.1,1.0)
						* disturb(Math.sin,time,char.col,3.0,0.7)
						* disturb(Math.cos,time,char.col,0.2,0.3);
	}
};
TextEffects["shk"] = new ShakyEffect();

var DebugHighlightEffect = function() {
	this.DoEffect = function(char) {
		char.color.r = 255;
		char.color.g = 255;
		char.color.b = 0;
		char.color.a = 255;
	}
}
TextEffects["_debug_highlight"] = new DebugHighlightEffect();

} // Dialog()
</script>

<script>
/*
TODO
- reset renderer function
- react to changes in: drawings, palettes
- possible future plan: limit size of cache (remove old images)
- change image store path from (pal > col > draw) to (draw > pal > col)
- get rid of old getSpriteImage (etc) methods
- get editor working again [in progress]
- move debug timer class into core (seems useful)
*/

function Renderer(tilesize, scale) {

console.log("!!!!! NEW RENDERER");

var imageStore = { // TODO : rename to imageCache
	source: {},
	render: {}
};

var palettes = null; // TODO : need null checks?
var context = null;

function setPalettes(paletteObj) {
	palettes = paletteObj;

	// TODO : should this really clear out the render cache?
	imageStore.render = {};
}

function getPaletteColor(paletteId, colorIndex) {
	if (palettes[paletteId] === undefined) {
		paletteId = "default";
	}

	var palette = palettes[paletteId];

	if (colorIndex > palette.colors.length) { // do I need this failure case? (seems un-reliable)
		colorIndex = 0;
	}

	var color = palette.colors[colorIndex];

	return {
		r : color[0],
		g : color[1],
		b : color[2]
	};
}

var debugRenderCount = 0;

// TODO : change image store path from (pal > col > draw) to (draw > pal > col)
function renderImage(drawing, paletteId) {
	// debugRenderCount++;
	// console.log("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;
	var imgSrc = imageStore.source[ drawing.drw ];

	// initialize render cache entry
	if (imageStore.render[drwId] === undefined || imageStore.render[drwId] === null) {
		imageStore.render[drwId] = {};
	}

	if (imageStore.render[drwId][pal] === undefined || imageStore.render[drwId][pal] === null) {
		imageStore.render[drwId][pal] = {};
	}

	// create array of ImageData frames
	imageStore.render[drwId][pal][colStr] = [];

	for (var i = 0; i < imgSrc.length; i++) {
		var frameSrc = imgSrc[i];
		var frameData = imageDataFromImageSource( frameSrc, pal, col );
		imageStore.render[drwId][pal][colStr].push(frameData);
	}
}

function imageDataFromImageSource(imageSource, pal, col) {
	//console.log(imageSource);

	var img = context.createImageData(tilesize*scale,tilesize*scale);

	var backgroundColor = getPaletteColor(pal,0);
	var foregroundColor = getPaletteColor(pal,col);

	for (var y = 0; y < tilesize; y++) {
		for (var x = 0; x < tilesize; x++) {
			var px = imageSource[y][x];
			for (var sy = 0; sy < scale; sy++) {
				for (var sx = 0; sx < scale; sx++) {
					var pxl = (((y * scale) + sy) * tilesize * scale * 4) + (((x*scale) + sx) * 4);
					if ( px === 1 ) {
						img.data[pxl + 0] = foregroundColor.r;
						img.data[pxl + 1] = foregroundColor.g;
						img.data[pxl + 2] = foregroundColor.b;
						img.data[pxl + 3] = 255;
					}
					else { //ch === 0
						img.data[pxl + 0] = backgroundColor.r;
						img.data[pxl + 1] = backgroundColor.g;
						img.data[pxl + 2] = backgroundColor.b;
						img.data[pxl + 3] = 255;
					}
				}
			}
		}
	}

	// convert to canvas: chrome has poor performance when working directly with image data
	var imageCanvas = document.createElement("canvas");
	imageCanvas.width = img.width;
	imageCanvas.height = img.height;
	var imageContext = imageCanvas.getContext("2d");
	imageContext.putImageData(img,0,0);

	return imageCanvas;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isImageRendered(drawing, paletteId) {
	var col = drawing.col;
	var colStr = "" + col;
	var pal = paletteId;
	var drwId = drawing.drw;

	if (undefinedOrNull(imageStore.render[drwId]) ||
		undefinedOrNull(imageStore.render[drwId][pal]) ||
		undefinedOrNull(imageStore.render[drwId][pal][colStr])) {
			return false;
	}
	else {
		return true;
	}
}

function getImageSet(drawing, paletteId) {
	return imageStore.render[drawing.drw][paletteId][drawing.col];
}

function getImageFrame(drawing, paletteId, frameOverride) {
	var frameIndex = 0;
	if (drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getImageSet(drawing, paletteId)[frameIndex];
}

function getOrRenderImage(drawing, paletteId, frameOverride) {
	if (!isImageRendered(drawing, paletteId)) {
		renderImage(drawing, paletteId);
	}

	return getImageFrame(drawing, paletteId, frameOverride);
}

/* PUBLIC INTERFACE */
this.GetImage = getOrRenderImage;

this.SetPalettes = setPalettes;

this.SetImageSource = function(drawingId, imageSourceData) {
	imageStore.source[drawingId] = imageSourceData;
	imageStore.render[drawingId] = {}; // reset render cache for this image
}

this.GetImageSource = function(drawingId) {
	return imageStore.source[drawingId];
}

this.GetFrameCount = function(drawingId) {
	return imageStore.source[drawingId].length;
}

this.AttachContext = function(ctx) {
	context = ctx;
}

} // Renderer()
</script>

<script>
var xhr; // TODO : remove
var canvas;
var context; // TODO : remove if safe?
var ctx;

var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var playerId = "A";

var titleDialogId = "title";
function getTitle() {
	return dialog[titleDialogId].src;
}
function setTitle(titleSrc) {
	dialog[titleDialogId] = { src:titleSrc, name:null };
}

var defaultFontName = "ascii_small";
var fontName = defaultFontName;
var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};
var textDirection = TextDirection.LeftToRight;

var names = {
	room : new Map(),
	tile : new Map(), // Note: Not currently enabled in the UI
	sprite : new Map(),
	item : new Map(),
	dialog : new Map(),
};
function updateNamesFromCurData() {

	function createNameMap(objectStore) {
		var map = new Map();
		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map.set(objectStore[id].name, id);
			}
		}
		return map;
	}

	names.room = createNameMap(room);
	names.tile = createNameMap(tile);
	names.sprite = createNameMap(sprite);
	names.item = createNameMap(item);
	names.dialog = createNameMap(dialog);
}

var spriteStartLocations = {};

/* VERSION */
var version = {
	major: 7, // major changes
	minor: 2, // smaller changes
	devBuildPhase: "RELEASE",
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
	flags = {
		ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated
	};
}
resetFlags(); //init flags on load script

// SUPER hacky location... :/
var editorDevFlags = {
	// NONE right now!
};

function clearGameData() {
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
	isEnding = false; //todo - correct place for this?
	variable = {};

	// TODO RENDERER : clear data?

	spriteStartLocations = {};

	// hacky to have this multiple times...
	names = {
		room : new Map(),
		tile : new Map(),
		sprite : new Map(),
		item : new Map(),
		dialog : new Map(),
	};

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;
}

var width = 128;
var height = 128;
var scale = 4; //this is stupid but necessary
var tilesize = 8;
var mapsize = 16;

var curRoom = "0";

var key = {
	left : 37,
	right : 39,
	up : 38,
	down : 40,
	space : 32,
	enter : 13,
	w : 87,
	a : 65,
	s : 83,
	d : 68,
	r : 82,
	shift : 16,
	ctrl : 17,
	alt : 18,
	cmd : 224
};

var prevTime = 0;
var deltaTime = 0;

//inventory update UI handles
var onInventoryChanged = null;
var onVariableChanged = null;
var onGameReset = null;

var isPlayerEmbeddedInEditor = false;

var renderer = new Renderer(tilesize, scale);

function getGameNameFromURL() {
	var game = window.location.hash.substring(1);
	// console.log("game name --- " + game);
	return game;
}

function attachCanvas(c) {
	canvas = c;
	canvas.width = width * scale;
	canvas.height = width * scale;
	ctx = canvas.getContext("2d");
	dialogRenderer.AttachContext(ctx);
	renderer.AttachContext(ctx);
}

var curGameData = null;
function load_game(game_data, startWithTitle) {
	curGameData = game_data; //remember the current game (used to reset the game)

	dialogBuffer.Reset();
	scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?

	parseWorld(game_data);

	if (!isPlayerEmbeddedInEditor) {
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), document.getElementById(defaultFontName).text.slice(1));
	}

	var font = fontManager.Get( fontName );
	dialogBuffer.SetFont(font);
	dialogRenderer.SetFont(font);

	setInitialVariables();

	// setInterval(updateLoadingScreen, 300); // hack test

	onready(startWithTitle);
}

function reset_cur_game() {
	if (curGameData == null) {
		return; //can't reset if we don't have the game data
	}

	stopGame();
	clearGameData();
	load_game(curGameData);

	if (isPlayerEmbeddedInEditor && onGameReset != null) {
		onGameReset();
	}
}

var update_interval = null;
function onready(startWithTitle) {
	if(startWithTitle === undefined || startWithTitle === null) startWithTitle = true;

	clearInterval(loading_interval);

	input = new InputManager();

	document.addEventListener('keydown', input.onkeydown);
	document.addEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.addEventListener('touchstart', input.ontouchstart, {passive:false});
		canvas.addEventListener('touchmove', input.ontouchmove, {passive:false});
		canvas.addEventListener('touchend', input.ontouchend, {passive:false});
	}
	else {
		// creates a 'touchTrigger' element that covers the entire screen and can universally have touch event listeners added w/o issue.

		// we're checking for existing touchTriggers both at game start and end, so it's slightly redundant.
	  	var existingTouchTrigger = document.querySelector('#touchTrigger');
	  	if (existingTouchTrigger === null){
	  	  var touchTrigger = document.createElement("div");
	  	  touchTrigger.setAttribute("id","touchTrigger");

	  	  // afaik css in js is necessary here to force a fullscreen element
	  	  touchTrigger.setAttribute(
	  	    "style","position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden;"
	  	  );
	  	  document.body.appendChild(touchTrigger);

	  	  touchTrigger.addEventListener('touchstart', input.ontouchstart);
	  	  touchTrigger.addEventListener('touchmove', input.ontouchmove);
	  	  touchTrigger.addEventListener('touchend', input.ontouchend);
	  	}
	}

	window.onblur = input.onblur;

	update_interval = setInterval(update,16);

	if(startWithTitle) { // used by editor 
		startNarrating(getTitle());
	}
}

function setInitialVariables() {
	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	console.log("stop GAME!");

	document.removeEventListener('keydown', input.onkeydown);
	document.removeEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.removeEventListener('touchstart', input.ontouchstart);
		canvas.removeEventListener('touchmove', input.ontouchmove);
		canvas.removeEventListener('touchend', input.ontouchend);
	}
	else {
		//check for touchTrigger and removes it

    		var existingTouchTrigger = document.querySelector('#touchTrigger');
    		if (existingTouchTrigger !== null){
    			existingTouchTrigger.removeEventListener('touchstart', input.ontouchstart);
    			existingTouchTrigger.removeEventListener('touchmove', input.ontouchmove);
    			existingTouchTrigger.removeEventListener('touchend', input.ontouchend);

    			existingTouchTrigger.parentElement.removeChild(existingTouchTrigger);
    		}
	}

	window.onblur = null;

	clearInterval(update_interval);
}

/* loading animation */
var loading_anim_data = [
	[
		0,1,1,1,1,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,1,1,1,1,0,
	],
	[
		0,0,0,0,0,0,0,0,
		1,0,0,0,0,0,0,1,
		1,1,1,0,0,1,1,1,
		1,1,1,1,1,0,0,1,
		1,1,1,1,1,0,0,1,
		1,1,1,0,0,1,1,1,
		1,0,0,0,0,0,0,1,
		0,0,0,0,0,0,0,0,
	]
];
var loading_anim_frame = 0;
var loading_anim_speed = 500;
var loading_interval = null;

function loadingAnimation() {
	//create image
	var loadingAnimImg = ctx.createImageData(8*scale, 8*scale);
	//draw image
	for (var y = 0; y < 8; y++) {
		for (var x = 0; x < 8; x++) {
			var i = (y * 8) + x;
			if (loading_anim_data[loading_anim_frame][i] == 1) {
				//scaling nonsense
				for (var sy = 0; sy < scale; sy++) {
					for (var sx = 0; sx < scale; sx++) {
						var pxl = 4 * ( (((y*scale)+sy) * (8*scale)) + ((x*scale)+sx) );
						loadingAnimImg.data[pxl+0] = 255;
						loadingAnimImg.data[pxl+1] = 255;
						loadingAnimImg.data[pxl+2] = 255;
						loadingAnimImg.data[pxl+3] = 255;
					}
				}
			}
		}
	}
	//put image on canvas
	ctx.putImageData(loadingAnimImg,scale*(width/2 - 4),scale*(height/2 - 4));
	//update frame
	loading_anim_frame++;
	if (loading_anim_frame >= 5) loading_anim_frame = 0;
}

function updateLoadingScreen() {
	// TODO : in progress
	ctx.fillStyle = "rgb(0,0,0)";
	ctx.fillRect(0,0,canvas.width,canvas.height);

	loadingAnimation();
	drawSprite( getSpriteImage(sprite["a"],"0",0), 8, 8, ctx );
}

function update() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	if (curRoom == null) {
		// in the special case where there is no valid room, end the game
		startNarrating( "", true /*isEnding*/ );
	}

	if (!transition.IsTransitionActive()) {
		updateInput();
	}

	if (transition.IsTransitionActive()) {
		// transition animation takes over everything!
		transition.UpdateTransition(deltaTime);
	}
	else {
		if (!isNarrating && !isEnding) {
			updateAnimation();
			drawRoom( room[curRoom] ); // draw world if game has begun
		}
		else {
			//make sure to still clear screen
			ctx.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
			ctx.fillRect(0,0,canvas.width,canvas.height);
		}

		// if (isDialogMode) { // dialog mode
		if(dialogBuffer.IsActive()) {
			dialogRenderer.Draw( dialogBuffer, deltaTime );
			dialogBuffer.Update( deltaTime );
		}

		// keep moving avatar if player holds down button
		if( !dialogBuffer.IsActive() && !isEnding )
		{
			if( curPlayerDirection != Direction.None ) {
				playerHoldToMoveTimer -= deltaTime;

				if( playerHoldToMoveTimer <= 0 )
				{
					movePlayer( curPlayerDirection );
					playerHoldToMoveTimer = 150;
				}
			}
		}
	}

	prevTime = curTime;

	input.resetKeyPressed();
	input.resetTapReleased();
}

function updateInput() {
	if( dialogBuffer.IsActive() ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* CONTINUE DIALOG */
			if (dialogBuffer.CanContinue()) {
				var hasMoreDialog = dialogBuffer.Continue();
				if(!hasMoreDialog) {
					// ignore currently held keys UNTIL they are released (stops player from insta-moving)
					input.ignoreHeldKeys();
				}
			}
			else {
				dialogBuffer.Skip();
			}
		}
	}
	else if ( isEnding ) {
		if (input.anyKeyPressed() || input.isTapReleased()) {
			/* RESTART GAME */
			reset_cur_game();
		}
	}
	else {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if ( input.isKeyDown( key.left ) || input.isKeyDown( key.a ) || input.swipeLeft() ) {
			curPlayerDirection = Direction.Left;
		}
		else if ( input.isKeyDown( key.right ) || input.isKeyDown( key.d ) || input.swipeRight() ) {
			curPlayerDirection = Direction.Right;
		}
		else if ( input.isKeyDown( key.up ) || input.isKeyDown( key.w ) || input.swipeUp() ) {
			curPlayerDirection = Direction.Up;
		}
		else if ( input.isKeyDown( key.down ) || input.isKeyDown( key.s ) || input.swipeDown() ) {
			curPlayerDirection = Direction.Down;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer( curPlayerDirection );
			playerHoldToMoveTimer = 500;
		}
	}
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
	animationCounter += deltaTime;

	if ( animationCounter >= animationTime ) {

		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

	}
}

function resetAllAnimations() {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.animation.isAnimated) {
			spr.animation.frameIndex = 0;
		}
	}

	for (id in tile) {
		var til = tile[id];
		if (til.animation.isAnimated) {
			til.animation.frameIndex = 0;
		}
	}

	for (id in item) {
		var itm = item[id];
		if (itm.animation.isAnimated) {
			itm.animation.frameIndex = 0;
		}
	}
}

function getSpriteAt(x,y) {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === curRoom) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}
	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;

var InputManager = function() {
	var self = this;

	var pressed;
	var ignored;
	var newKeyPress;
	var touchState;

	function resetAll() {
		pressed = {};
		ignored = {};
		newKeyPress = false;

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : Direction.None,
			tapReleased : false
		};
	}
	resetAll();

	function stopWindowScrolling(e) {
		if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
			e.preventDefault();
	}

	function tryRestartGame(e) {
		/* RESTART GAME */
		if ( e.keyCode === key.r && ( e.getModifierState("Control") || e.getModifierState("Meta") ) ) {
			if ( confirm("Restart the game?") ) {
				reset_cur_game();
			}
		}
	}

	function eventIsModifier(event) {
		return (event.keyCode == key.shift || event.keyCode == key.ctrl || event.keyCode == key.alt || event.keyCode == key.cmd);
	}

	function isModifierKeyDown() {
		return ( self.isKeyDown(key.shift) || self.isKeyDown(key.ctrl) || self.isKeyDown(key.alt) || self.isKeyDown(key.cmd) );
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// console.log("IGNORE -- " + key);
			}
		}
	}

	this.onkeydown = function(event) {
		// console.log("KEYDOWN -- " + event.keyCode);

		stopWindowScrolling(event);

		tryRestartGame(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		if (!self.isKeyDown(event.keyCode)) {
			newKeyPress = true;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// console.log("KEYUP -- " + event.keyCode);
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;
	}

	this.ontouchstart = function(event) {
		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = Direction.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = Direction.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == Direction.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = Direction.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyPressed = function() {
		return newKeyPress;
	}

	this.resetKeyPressed = function() {
		newKeyPress = false;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == Direction.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == Direction.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == Direction.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == Direction.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// console.log("~~~ BLUR ~~");
		resetAll();
	}
}
var input = null;

function movePlayer(direction) {
	if (player().room == null || !Object.keys(room).includes(player().room)) {
		return; // player room is missing or invalid.. can't move them!
	}

	var spr = null;

	if ( curPlayerDirection == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
	}
	else if ( curPlayerDirection == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
	}
	else if ( curPlayerDirection == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
	}
	else if ( curPlayerDirection == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
	}
	
	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		var itm = room[player().room].items[itmIndex];
		var itemRoom = player().room;

		startItemDialog(itm.id, function() {
			// remove item from room
			room[itemRoom].items.splice(itmIndex, 1);

			// update player inventory
			if (player().inventory[itm.id]) {
				player().inventory[itm.id] += 1;
			}
			else {
				player().inventory[itm.id] = 1;
			}

			// show inventory change in UI
			if (onInventoryChanged != null) {
				onInventoryChanged(itm.id);
			}
		});
	}

	if (end) {
		startEndingDialog(end);
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	else if (spr) {
		startSpriteDialog(spr /*spriteId*/);
	}
}

var transition = new TransitionManager();

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (ext.transition_effect != null) {
			transition.BeginTransition(player().room, player().x, player().y, ext.dest.room, ext.dest.x, ext.dest.y, ext.transition_effect);
			transition.UpdateTransition(0);
		}

		player().room = ext.dest.room;
		player().x = ext.dest.x;
		player().y = ext.dest.y;
		curRoom = ext.dest.room;

		initRoom(curRoom);
	};

	if (ext.dlg != undefined && ext.dlg != null) {
		// TODO : I need to simplify dialog code,
		// so I don't have to get the ID and the source str
		// every time!
		startDialog(
			dialog[ext.dlg].src,
			ext.dlg,
			function(result) {
				var isLocked = ext.property && ext.property.locked === true;
				if (!isLocked) {
					GoToDest();
				}
			},
			ext);
	}
	else {
		GoToDest();
	}
}

function initRoom(roomId) {
	// init exit properties
	for (var i = 0; i < room[roomId].exits.length; i++) {
		room[roomId].exits[i].property = { locked:false };
	}

	// init ending properties
	for (var i = 0; i < room[roomId].endings.length; i++) {
		room[roomId].endings[i].property = { locked:false };
	}
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= 16) || isWall( player().x + 1, player().y );
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= 16) || isWall( player().x, player().y + 1 );
}

function isWall(x,y,roomId) {
	if(roomId == undefined || roomId == null)
		roomId = curRoom;

	var tileId = getTile( x, y );

	if( tileId === '0' )
		return false; // Blank spaces aren't walls, ya doofus

	if( tile[tileId].isWall === undefined || tile[tileId].isWall === null ) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf( getTile(x,y) );
		return i > -1;
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

function getExit(roomId,x,y) {
	for (i in room[roomId].exits) {
		var e = room[roomId].exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId,x,y) {
	for (i in room[roomId].endings) {
		var e = room[roomId].endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getTile(x,y) {
	// console.log(x + " " + y);
	var t = getRoom().tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	if (palette[id] === undefined) {
		id = "default";
	}

	return palette[ id ].colors;
}

function getRoom() {
	return room[curRoom];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function parseWorld(file) {
	spriteStartLocations = {};

	resetFlags();

	var versionNumber = 0;

	// flags to keep track of which compatibility conversions
	// need to be applied to this game data
	var compatibilityFlags = {
		convertSayToPrint : false,
		combineEndingsWithDialog : false,
		convertImplicitSpriteDialogIds : false,
	};

	var lines = file.split("\n");
	var i = 0;
	while (i < lines.length) {
		var curLine = lines[i];

		// console.log(lines[i]);

		if (i == 0) {
			i = parseTitle(lines, i);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number (from a comment.. hacky I know)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				versionNumber = parseFloat(curLine.replace("# BITSY VERSION ", ""));

				if (versionNumber < 5.0) {
					compatibilityFlags.convertSayToPrint = true;
				}

				if (versionNumber < 7.0) {
					compatibilityFlags.combineEndingsWithDialog = true;
					compatibilityFlags.convertImplicitSpriteDialogIds = true;
				}
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) == "PAL") {
			i = parsePalette(lines, i);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { //SET for back compat
			i = parseRoom(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(lines, i);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(lines, i);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(lines, i);
		}
		else if (getType(curLine) === "DRW") {
			i = parseDrawing(lines, i);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === "END" && compatibilityFlags.combineEndingsWithDialog) {
			// parse endings for back compat
			i = parseEnding(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === "VAR") {
			i = parseVariable(lines, i);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(lines, i);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(lines, i);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(lines, i);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(lines, i);
		}
		else {
			i++;
		}
	}

	placeSprites();

	var roomIds = Object.keys(room);
	if (player() != undefined && player().room != null && roomIds.includes(player().room)) {
		// player has valid room
		curRoom = player().room;
	}
	else if (roomIds.length > 0) {
		// player not in any room! what the heck
		curRoom = roomIds[0];
	}
	else {
		// uh oh there are no rooms I guess???
		curRoom = null;
	}

	if (curRoom != null) {
		initRoom(curRoom);
	}

	renderer.SetPalettes(palette);

	scriptCompatibility(compatibilityFlags);

	return versionNumber;
}

function scriptCompatibility(compatibilityFlags) {
	if (compatibilityFlags.convertSayToPrint) {
		console.log("CONVERT SAY TO PRINT!");

		var PrintFunctionVisitor = function() {
			var didChange = false;
			this.DidChange = function() { return didChange; };

			this.Visit = function(node) {
				if (node.type != "function") {
					return;
				}

				if (node.name === "say") {
					node.name = "print";
					didChange = true;
				}
			};
		};

		for (dlgId in dialog) {
			var dialogScript = scriptInterpreter.Parse(dialog[dlgId].src);
			var visitor = new PrintFunctionVisitor();
			dialogScript.VisitAll(visitor);
			if (visitor.DidChange()) {
				var newDialog = dialogScript.Serialize();
				if (newDialog.indexOf("\n") > -1) {
					newDialog = '"""\n' + newDialog + '\n"""';
				}
				dialog[dlgId].src = newDialog;
			}
		}
	}
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null)
		skipFonts = false;

	var worldStr = "";
	/* TITLE */
	worldStr += getTitle() + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	if (version.devBuildPhase != "RELEASE") {
		worldStr += "# DEVELOPMENT BUILD -- " + version.devBuildPhase;
	}
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		if (id != "default") {
			worldStr += "PAL " + id + "\n";
			if( palette[id].name != null )
				worldStr += "NAME " + palette[id].name + "\n";
			for (i in getPal(id)) {
				for (j in getPal(id)[i]) {
					worldStr += getPal(id)[i][j];
					if (j < 2) worldStr += ",";
				}
				worldStr += "\n";
			}
			worldStr += "\n";
		}
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					if (e.transition_effect != undefined && e.transition_effect != null) {
						worldStr += " FX " + e.transition_effect;
					}
					if (e.dlg != undefined && e.dlg != null) {
						worldStr += " DLG " + e.dlg;
					}
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		if (room[id].pal != null && room[id].pal != "default") {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		if (id != titleDialogId) {
			worldStr += "DLG " + id + "\n";
			worldStr += dialog[id].src + "\n";
			if (dialog[id].name != null) {
				worldStr += "NAME " + dialog[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	var imageSource = renderer.GetImageSource(drwId);
	var drwStr = "";
	for (f in imageSource) {
		for (y in imageSource[f]) {
			var rowStr = "";
			for (x in imageSource[f][y]) {
				rowStr += imageSource[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (imageSource.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function placeSprites() {
	for (id in spriteStartLocations) {
		//console.log(id);
		//console.log( spriteStartLocations[id] );
		//console.log(sprite[id]);
		sprite[id].room = spriteStartLocations[id].room;
		sprite[id].x = spriteStartLocations[id].x;
		sprite[id].y = spriteStartLocations[id].y;
		//console.log(sprite[id]);
	}
}

/* ARGUMENT GETTERS */
function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function parseTitle(lines, i) {
	var results = scriptUtils.ReadDialogScript(lines,i);
	setTitle(results.script);
	i = results.index;

	i++;

	return i;
}

function parseRoom(lines, i, compatibilityFlags) {
	var id = getId(lines[i]);
	room[id] = {
		id : id,
		tilemap : [],
		walls : [],
		exits : [],
		endings : [],
		items : [],
		pal : null,
		name : null
	};
	i++;

	// create tile map
	if ( flags.ROOM_FORMAT == 0 ) {
		// old way: no commas, single char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lines[i].charAt(x) );
			}
			y++;
		}
	}
	else if ( flags.ROOM_FORMAT == 1 ) {
		// new way: comma separated, multiple char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			var lineSep = lines[i].split(",");
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lineSep[x] );
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// console.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in room[id].tilemap) {
					for (s in sprList) {
						var col = room[id].tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							room[id].tilemap[row][col] = "0";
							spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			room[id].items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			room[id].walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				},
				transition_effect : null,
				dlg: null,
			};

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == "FX") {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else if (exitArgs[exitArgIndex] == "DLG") {
					ext.dlg = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else {
					exitArgIndex += 1;
				}
			}

			room[id].exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId(lines[i]);

			// compatibility with when endings were stored separate from other dialog
			if (compatibilityFlags.combineEndingsWithDialog) {
				endId = "end_" + endId;
			}

			var endCoords = getCoord(lines[i], 2);
			var end = {
				id : endId,
				x : parseInt(endCoords[0]),
				y : parseInt(endCoords[1])
			};

			room[id].endings.push(end);
		}
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			room[id].pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			room[id].name = name;
			names.room.set(name, id);
		}

		i++;
	}

	return i;
}

function parsePalette(lines,i) { //todo this has to go first right now :(
	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if (args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function parseTile(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store tile source
		drwId = "TIL_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 1; // default palette color index is 1
	var isWall = null; // null indicates it can vary from room to room (original version)
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.tile.set( name, id );
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg( lines[i], 1 );
			if( wallArg === "true" ) {
				isWall = true;
			}
			else if( wallArg === "false" ) {
				isWall = false;
			}
		}
		i++;
	}

	//tile data
	tile[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name,
		isWall : isWall
	};

	return i;
}

function parseSprite(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store sprite source
		drwId = "SPR_" + id;
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	var startingInventory = {};
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getId(lines[i]) );
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.sprite.set( name, id );
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat( getArg(lines[i], 2) );
			startingInventory[itemId] = itemCount;
		}
		i++;
	}

	//sprite data
	sprite[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		room : null, //default location is "offstage"
		x : -1,
		y : -1,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		inventory : startingInventory,
		name : name
	};
	return i;
}

function parseItem(lines, i) {
	var id = getId(lines[i]);
	var drwId = null;
	var name = null;

	i++;

	if (getType(lines[i]) === "DRW") { //load existing drawing
		drwId = getId(lines[i]);
		i++;
	}
	else {
		// store item source
		drwId = "ITM_" + id; // these prefixes are maybe a terrible way to differentiate drawing tyepes :/
		i = parseDrawingCore( lines, i, drwId );
	}

	//other properties
	var colorIndex = 2; //default palette color index is 2
	var dialogId = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			colorIndex = parseInt( getArg( lines[i], 1 ) );
		}
		// else if (getType(lines[i]) === "POS") {
		// 	/* STARTING POSITION */
		// 	var posArgs = lines[i].split(" ");
		// 	var roomId = posArgs[1];
		// 	var coordArgs = posArgs[2].split(",");
		// 	spriteStartLocations[id] = {
		// 		room : roomId,
		// 		x : parseInt(coordArgs[0]),
		// 		y : parseInt(coordArgs[1])
		// 	};
		// }
		else if(getType(lines[i]) === "DLG") {
			dialogId = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			name = lines[i].split(/\s(.+)/)[1];
			names.item.set( name, id );
		}
		i++;
	}

	//item data
	item[id] = {
		id : id,
		drw : drwId, //drawing id
		col : colorIndex,
		dlg : dialogId,
		// room : null, //default location is "offstage"
		// x : -1,
		// y : -1,
		animation : {
			isAnimated : (renderer.GetFrameCount(drwId) > 1),
			frameIndex : 0,
			frameCount : renderer.GetFrameCount(drwId)
		},
		name : name
	};

	// console.log("ITM " + id);
	// console.log(item[id]);

	return i;
}

function parseDrawing(lines, i) {
	// store drawing source
	var drwId = getId( lines[i] );
	return parseDrawingCore( lines, i, drwId );
}

function parseDrawingCore(lines, i, drwId) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while ( y < tilesize ) {
		var l = lines[i+y];
		var row = [];
		for (x = 0; x < tilesize; x++) {
			row.push( parseInt( l.charAt(x) ) );
		}
		frameList[frameIndex].push( row );
		y++;

		if (y === tilesize) {
			i = i + y;
			if ( lines[i] != undefined && lines[i].charAt(0) === ">" ) {
				// start next frame!
				frameList.push( [] );
				frameIndex++;
				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	renderer.SetImageSource(drwId, frameList);

	return i;
}

function parseScript(lines, i, backCompatPrefix, compatibilityFlags) {
	var id = getId(lines[i]);
	id = backCompatPrefix + id;
	i++;

	var results = scriptUtils.ReadDialogScript(lines,i);

	dialog[id] = { src:results.script, name:null };

	if (compatibilityFlags.convertImplicitSpriteDialogIds) {
		// explicitly hook up dialog that used to be implicitly
		// connected by sharing sprite and dialog IDs in old versions
		if (sprite[id]) {
			if (sprite[id].dlg === undefined || sprite[id].dlg === null) {
				sprite[id].dlg = id;
			}
		}
	}

	i = results.index;

	return i;
}

function parseDialog(lines, i, compatibilityFlags) {
	// hacky but I need to store this so I can set the name below
	var id = getId(lines[i]);

	i = parseScript(lines, i, "", compatibilityFlags);

	if (lines[i].length > 0 && getType(lines[i]) === "NAME") {
		dialog[id].name = lines[i].split(/\s(.+)/)[1]; // TODO : hacky to keep copying this regex around...
		names.dialog.set(dialog[id].name, id);
		i++;
	}

	return i;
}

// keeping this around to parse old files where endings were separate from dialogs
function parseEnding(lines, i, compatibilityFlags) {
	return parseScript(lines, i, "end_", compatibilityFlags);
}

function parseVariable(lines, i) {
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	variable[id] = value;
	return i;
}

function parseFontName(lines, i) {
	fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(lines, i) {
	textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(lines, i) {
	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseFlag(lines, i) {
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	flags[id] = parseInt( valStr );
	i++;
	return i;
}

function drawTile(img,x,y,context) {
	if (!context) { //optional pass in context; otherwise, use default
		context = ctx;
	}
	// NOTE: images are now canvases, instead of raw image data (for chrome performance reasons)
	context.drawImage(img,x*tilesize*scale,y*tilesize*scale,tilesize*scale,tilesize*scale);
}

function drawSprite(img,x,y,context) { //this may differ later (or not haha)
	drawTile(img,x,y,context);
}

function drawItem(img,x,y,context) {
	drawTile(img,x,y,context); //TODO these methods are dumb and repetitive
}

// var debugLastRoomDrawn = "0";

function drawRoom(room,context,frameIndex) { // context & frameIndex are optional
	if (!context) { //optional pass in context; otherwise, use default (ok this is REAL hacky isn't it)
		context = ctx;
	}

	// if (room.id != debugLastRoomDrawn) {
	// 	debugLastRoomDrawn = room.id;
	// 	console.log("DRAW ROOM " + debugLastRoomDrawn);
	// }

	var paletteId = "default";

	if (room === undefined) {
		// protect against invalid rooms
		context.fillStyle = "rgb(" + getPal(paletteId)[0][0] + "," + getPal(paletteId)[0][1] + "," + getPal(paletteId)[0][2] + ")";
		context.fillRect(0,0,canvas.width,canvas.height);
		return;
	}

	//clear screen
	if (room.pal != null && palette[paletteId] != undefined) {
		paletteId = room.pal;
	}
	context.fillStyle = "rgb(" + getPal(paletteId)[0][0] + "," + getPal(paletteId)[0][1] + "," + getPal(paletteId)[0][2] + ")";
	context.fillRect(0,0,canvas.width,canvas.height);

	//draw tiles
	for (i in room.tilemap) {
		for (j in room.tilemap[i]) {
			var id = room.tilemap[i][j];
			if (id != "0") {
				//console.log(id);
				if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
					id = "0";
					room.tilemap[i][j] = id;
				}
				else {
					// console.log(id);
					drawTile( getTileImage(tile[id],paletteId,frameIndex), j, i, context );
				}
			}
		}
	}

	//draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		drawItem( getItemImage(item[itm.id],paletteId,frameIndex), itm.x, itm.y, context );
	}

	//draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === room.id) {
			drawSprite( getSpriteImage(spr,paletteId,frameIndex), spr.x, spr.y, context );
		}
	}
}

// TODO : remove these get*Image methods
function getTileImage(t,palId,frameIndex) {
	return renderer.GetImage(t,palId,frameIndex);
}

function getSpriteImage(s,palId,frameIndex) {
	return renderer.GetImage(s,palId,frameIndex);
}

function getItemImage(itm,palId,frameIndex) {
	return renderer.GetImage(itm,palId,frameIndex);
}

function curPal() {
	return getRoomPal(curRoom);
}

function getRoomPal(roomId) {
	var defaultId = "default";

	if (roomId == null) {
		return defaultId;
	}
	else if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return defaultId;
		}
	}
	return defaultId;
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;
var dialogModule = new Dialog();
var dialogRenderer = dialogModule.CreateRenderer();
var dialogBuffer = dialogModule.CreateBuffer();
var fontManager = new FontManager();

// TODO : is this scriptResult thing being used anywhere???
function onExitDialog(scriptResult, dialogCallback) {
	console.log("EXIT DIALOG!");

	isDialogMode = false;

	if (isNarrating) {
		isNarrating = false;
	}

	if (isDialogPreview) {
		isDialogPreview = false;

		if (onDialogPreviewEnd != null) {
			onDialogPreviewEnd();
		}
	}

	if (dialogCallback != undefined && dialogCallback != null) {
		dialogCallback(scriptResult);
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr,end) {
	console.log("NARRATE " + dialogStr);

	if(end === undefined) {
		end = false;
	}

	isNarrating = true;
	isEnding = end;

	startDialog(dialogStr);
}

function startEndingDialog(ending) {
	isNarrating = true;
	isEnding = true;

	startDialog(
		dialog[ending.id].src,
		ending.id,
		function() {
			var isLocked = ending.property && ending.property.locked === true;
			if (isLocked) {
				isEnding = false;
			}
		},
		ending);
}

function startItemDialog(itemId, dialogCallback) {
	var dialogId = item[itemId].dlg;
	// console.log("START ITEM DIALOG " + dialogId);
	if (dialog[dialogId]) {
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId, dialogCallback);
	}
	else {
		dialogCallback();
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg;
	// console.log("START SPRITE DIALOG " + dialogId);
	if (dialog[dialogId]){
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr,dialogId);
	}
}

function startDialog(dialogStr, scriptId, dialogCallback, objectContext) {
	// console.log("START DIALOG ");
	if (dialogStr.length <= 0) {
		// console.log("ON EXIT DIALOG -- startDialog 1");
		onExitDialog(null, dialogCallback);
		return;
	}

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(isNarrating /*centered*/);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	var onScriptEnd = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, dialogCallback);
		});
	};

	if (scriptId === undefined) { // TODO : what's this for again?
		scriptInterpreter.Interpret(dialogStr, onScriptEnd);
	}
	else {
		if (!scriptInterpreter.HasScript(scriptId)) {
			scriptInterpreter.Compile(scriptId, dialogStr);
		}
		// scriptInterpreter.DebugVisualizeScript(scriptId);
		scriptInterpreter.Run(scriptId, onScriptEnd, objectContext);
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, dialogCallback) {
	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(true);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	// TODO : do I really need a seperate callback for this debug mode??
	onDialogPreviewEnd = dialogCallback;

	var onScriptEndCallback = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, null);
		});
	};

	scriptInterpreter.Eval(script, onScriptEndCallback);
}

/* NEW SCRIPT STUFF */
var scriptModule = new Script();
var scriptInterpreter = scriptModule.CreateInterpreter();
var scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
// scriptInterpreter.SetDialogBuffer( dialogBuffer );

</script>

<!-- store default font in separate script tag for back compat-->
<!-- Borksy modification: uses better encoded default font. -->
<script type="text/bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
000000
000000
000000
001010
010100
000000
000000
000000
CHAR 160
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 161
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 162
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 163
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 165
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 167
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 171
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 172
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 177
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 178
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 187
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 188
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 189
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 191
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 196
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 197
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 198
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 199
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 201
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 209
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 214
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 220
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 223
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 224
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 225
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 226
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 230
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 231
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 232
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 233
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 234
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 235
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 236
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 237
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 238
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 239
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 241
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 242
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 243
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 244
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 246
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 247
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 249
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 250
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 251
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 252
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 255
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 402
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 915
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 920
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 931
011111
010000
001000
000100
001000
010000
011111
000000
CHAR 934
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 937
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 948
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 949
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 960
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 963
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 964
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 966
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 8226
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8252
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 8592
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 8593
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 8594
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 8595
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 8734
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 8735
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 8801
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 8804
000010
001100
010000
001100
000010
000000
011110
000000
CHAR 8805
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 8962
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 8976
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 9472
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 9474
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 9488
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 9492
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 9500
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 9508
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 9516
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 9524
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 9532
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 9552
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 9553
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 9556
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 9557
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 9558
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 9559
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 9561
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 9562
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 9563
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 9564
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 9565
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 9566
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 9567
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 9568
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 9569
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 9570
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 9571
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 9572
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 9573
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 9574
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 9575
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 9576
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 9577
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 9580
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 9601
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 9602
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 9603
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 9604
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 9605
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 9606
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 9607
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 9608
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 9609
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9610
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9611
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 9613
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 9615
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 9617
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 9618
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 9619
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 9644
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 9650
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 9658
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 9660
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 9668
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 9675
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 9688
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9689
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 9786
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 9787
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 9788
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 9792
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 9794
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 9824
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 9827
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 9829
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 9830
000000
000100
001110
011111
011111
001110
000100
000000
CHAR 9834
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 9835
000011
001101
001011
001101
001011
011011
011000
000000
</script>

<!-- BORKSY HACKS -->
<script type="text/javascript" id="borksyHacks">
//borksy uses dist versions of hacks from the bitsy hacks repo now

/**
🔀
@file dialog choices
@summary binary dialog choices
@license MIT
@version 15.4.2
@requires 7.0
@author Sean S. LeBlanc

@description
Adds a dialog tag which allows you to present the player with binary dialog choices.
Uses as an arrow cursor by default, but this can be changed in the hackOptions to use a custom bitsy sprite instead.

Usage:
{choice
  - option one
    result of picking option
  - option two
    result of picking option
}

Recommended uses:
DLG_simple_response
"""
Greeting text{choice
  - Response one
    answer to response one
  - Response two
    answer to response two
}
"""

DLG_complex_response
"""
Greeting text{choice
  - Response one
    {a = 1}
  - Response two
    {a = 2}
}
constant part of answer{
  - a == 1 ?
    custom part based on response one
  - a == 2 ?
    custom part based on response two
}
"""

Note: it's recommended you combine this hack
with the dialog jump hack for complex cases.

Limitations:
Each option must fit on a single line, or the interaction will break.

Checking the value of a variable set in an option
*immediately after the choice* will not work,
as it will evaluate before the player has selected
an option if there is no text in-between the two.
e.g.
"""
{a = 1}
{choice
  - Response one
    {a = 2}
  - Response two
    {a = 3}
}
{
  - a == 1 ?
    this will print
  - a == 2 ?
    these will not
  - a == 3 ?
    these will not
}
"""

HOW TO USE:
1. Copy-paste into a script tag after the bitsy source
2. Edit hackOptions below as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions =  {
// if defined, the cursor is drawn as the sprite with the given id
// e.g. replace with `getCursorSprite('A')` to use the player's avatar as a cursor
// if not defined, uses an arrow graphic similar to the continue arrow

cursor: getCursorSprite(),

// modifies the scale/position of the cursor
// recommended combinations:

// 	- scale: 4, y: 1, x: 0
// 	- scale: 2, y: 3, x: 1
// 	- scale: 2, y: 4, x: 0 + custom cursor

transform: {
	scale: bitsy.scale,
	y: 1,
	x: 0,
},
} ;

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw new Error('Couldn\'t find "' + searchRegex + '" in script tags');
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	if (
		!kitsy.queuedInjectScripts.some(function (script) {
			return searchRegex.toString() === script.searchRegex.toString() && replaceString === script.replaceString;
		})
	) {
		kitsy.queuedInjectScripts.push({
			searchRegex: searchRegex,
			replaceString: replaceString,
		});
	} else {
		console.warn('Ignored duplicate inject');
	}
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {},
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}

function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			}
			// run synchronously
			returnVal = functions[i++].apply(this, args);
			if (returnVal && returnVal.length) {
				args = returnVal;
			}
			return runBefore.apply(this, args);
		}

		return runBefore.apply(this, arguments);
	};
}

function reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

/**
 * Helper for printing a paragraph break inside of a dialog function.
 * Adds the function `AddParagraphBreak` to `DialogBuffer`
 */

inject$1(/(this\.AddLinebreak = )/, 'this.AddParagraphBreak = function() { buffer.push( [[]] ); isActive = true; };\n$1');





var dialogChoices = {
	choice: 0,
	choices: [],
	choicesActive: false,
	swiped: false,
	handleInput: function (dialogBuffer) {
		if (!this.choicesActive) {
			this.swiped = false;
			return false;
		}
		var pswiped = this.swiped;
		var swiped = !pswiped && (bitsy.input.swipeUp() || bitsy.input.swipeDown() || bitsy.input.swipeRight());
		if (swiped) {
			this.swiped = true;
		} else if (!bitsy.input.swipeUp() && !bitsy.input.swipeDown() && !bitsy.input.swipeRight()) {
			this.swiped = false;
		}
		var l = Math.max(this.choices.length, 1);
		// navigate
		if (
			(bitsy.input.anyKeyPressed() && (bitsy.input.isKeyDown(bitsy.key.up) || bitsy.input.isKeyDown(bitsy.key.w)))
			|| (swiped && bitsy.input.swipeUp())
		) {
			this.choice -= 1;
			if (this.choice < 0) {
				this.choice += l;
			}
			return false;
		}
		if (
			(bitsy.input.anyKeyPressed() && (bitsy.input.isKeyDown(bitsy.key.down) || bitsy.input.isKeyDown(bitsy.key.s)))
			|| (swiped && bitsy.input.swipeDown())
		) {
			this.choice = (this.choice + 1) % l;
			return false;
		}
		// select
		if (
			((bitsy.input.anyKeyPressed() && (
				bitsy.input.isKeyDown(bitsy.key.right)
					|| bitsy.input.isKeyDown(bitsy.key.d)
					|| bitsy.input.isKeyDown(bitsy.key.enter)
					|| bitsy.input.isKeyDown(bitsy.key.space)
			))
				|| (swiped && bitsy.input.swipeRight()))
		) {
			// evaluate choice
			this.choices[this.choice]();
			// reset
			this.choice = 0;
			this.choices = [];
			this.choicesActive = false;
			// get back into the regular dialog flow
			if (dialogBuffer.Continue()) {
				dialogBuffer.Update(0);
				// make sure to close dialog if there's nothing to say
				// after the choice has been made
				if (!dialogBuffer.CurCharCount()) {
					dialogBuffer.EndDialog();
				}
			}
			return true;
		}
		return false;
	},
};

bitsy.dialogChoices = dialogChoices;

function getCursorSprite(cursor) {
	return cursor ? `renderer.GetImageSource(sprite['${cursor}'].drw)[sprite['${cursor}'].animation.frameIndex]` : `[
		[0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0],
		[0, 1, 0, 0, 0, 0, 0, 0],
		[0, 1, 1, 0, 0, 0, 0, 0],
		[0, 1, 1, 1, 0, 0, 0, 0],
		[0, 1, 1, 0, 0, 0, 0, 0],
		[0, 1, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0]
	]`;
}

// parsing
// (adds a new sequence node type)
inject$1(/(\|\| str === "shuffle")/, '$1 || str === "choice"');
inject$1(/(state\.curNode\.AddChild\(new ShuffleNode\(options\)\);\n.*})/, `$1
else if(sequenceType === "choice") {
	state.curNode.AddChild(new ChoiceNode(options));
}`);

inject$1(/(var ShuffleNode = )/, `
var ChoiceNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "choice";
	this.options = options;
	options.forEach(function(option){
		var br = option.children.find(function(child){ return child.name === 'br'; });
		if (!br) {
			option.onSelect = [];
			return;
		}
		var idx = option.children.indexOf(br);
		option.onSelect = option.children.slice(idx+1);
		option.children = option.children.slice(0, idx);
	});

	this.Eval = function(environment,onReturn) {
		var lastVal = null;
		var i = 0;
		function evalChildren(children,done) {
			if(i < children.length) {
				children[i].Eval(environment, function(val) {
					if (i === children.length - 1) {
						environment.GetDialogBuffer().AddParagraphBreak();
					} else {
						environment.GetDialogBuffer().AddLinebreak();
					}
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
				window.dialogChoices.choicesActive = true;
			}
		}
		window.dialogChoices.choices = this.options.map(function(option){
			return function(){
				option.onSelect.forEach(function(child){
					child.Eval(environment, function(){});
				});
			};
		});
		if (environment.GetDialogBuffer().CurCharCount() > 0) {
			environment.GetDialogBuffer().AddParagraphBreak();
		}
		evalChildren(this.options, function () {
			onReturn(lastVal);
		});
	}
}
$1`);

// rendering
// (re-uses existing arrow image data,
// but draws rotated to point at text)
inject$1(/(this\.DrawNextArrow = )/, `
this.DrawChoiceArrow = function() {
	var rows = ${hackOptions.cursor};
	var top = (${hackOptions.transform.y} + window.dialogChoices.choice * (textboxInfo.padding_vert + relativeFontHeight())) * scale;
	var left = ${hackOptions.transform.x}*scale;
	for (var y = 0; y < rows.length; y++) {
		var cols = rows[y];
		for (var x = 0; x < cols.length; x++) {
			if (cols[x]) {
				//scaling nonsense
				for (var sy = 0; sy < ${hackOptions.transform.scale}; sy++) {
					for (var sx = 0; sx < ${hackOptions.transform.scale}; sx++) {
						var pxl = 4 * ( ((top+(y*${hackOptions.transform.scale})+sy) * (textboxInfo.width*scale)) + (left+(x*${hackOptions.transform.scale})+sx) );
						textboxInfo.img.data[pxl+0] = 255;
						textboxInfo.img.data[pxl+1] = 255;
						textboxInfo.img.data[pxl+2] = 255;
						textboxInfo.img.data[pxl+3] = 255;
					}
				}
			}
		}
	}
};
$1`);
inject$1(/(this\.DrawTextbox\(\);)/, `
if (window.dialogChoices.choicesActive) {
	this.DrawChoiceArrow();
}
$1`);

// interaction
// (overrides the dialog skip/page flip)
inject$1(/(if\( dialogBuffer\.IsActive\(\) \) {)/, `$1
if(window.dialogChoices.handleInput(dialogBuffer)) {
	return;
} else `);
inject$1(/(this\.CanContinue = function\(\) {)/, `$1
if(window.dialogChoices.choicesActive){
	return false;
}
`);

exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

}(this.hacks.dialog_choices = this.hacks.dialog_choices || {}, window));

/**
📐
@file textbox styler
@summary customize the style and properties of the textbox
@license MIT
@version 15.4.2
@requires Bitsy Version: 6.1
@author Dana Holdampf & Sean S. LeBlanc

@description
This hack lets you edit the appearance, position, and other properties of the textbox.
It lets you draw a border, replace the continue arrow, resize or reposition the box, recolor text or backgrounds, etc.
You can also use dialog tags to switch styles, or redefine style properties, from a dialog.

NOTE: This hack re-implements the functionality of the Long Dialog hack.
Since they modify the same code, don't use them both to avoid conflicts!
Like the Long Dialog hack, it also includes the paragraph break "(p)" dialog tag.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Edit hackOptions below, to define the default textbox style
3. Optionally, add additional alternate styles to the dialogStyles section

You can define custom style properties for the textbox in the hackOptions below.
- The topmost options are the default style properties, which are applied to the textbox initially.
- The dialogStyles section is used for defining alternate styles you can switch between.
- Use the dialog commands below to switch between styles, or change individual properties.

The Dialog Tags for switching textbox styles are as follows:
============================================================

-- SWITCH TEXTBOX STYLE, WITH UNDEFINED PROPERTIES BEING IGNORED ---------------

{textStyle "dialogStyle"}
{textStyleNow "dialogStyle"}

Information:
- Replaces current textbox style with a new set of style properties, as defined in the dialogStyles below.
- Only changes style properties that are defined in the dialogStyle. Undefined properties are left unchanged.

Parameters:
- dialogStyle:	id/name of a dialogStyle, as defined in the hackOptions below. (ex. "vanilla", "centered", "inverted", etc.)

-- SWITCH TEXTBOX STYLE, WITH UNDEFINED PROPERTIES REVERTING TO DEFAULTS -------

{setTextStyle "dialogStyle"}
{setTextStyleNow "dialogStyle"}

Information:
- As above, but any undefined style properties in the new dialogStyle revert to the default style properties.

Parameters:
- dialogStyle:	id/name of a dialog style, as defined in the hackOptions below. (ex. "vanilla", "centered", "inverted", etc.)

-- CHANGE AN INDIVIDUAL TEXTBOX STYLE PROPERTY ---------------------------------

{textProperty "styleProperty, styleValue"}
{textPropertyNow "styleProperty, styleValue"}

Information:
- Sets an individual textbox style property, to a given value. See the hackOptions below for valid properties and values.

Parameters:
- styleProperty:	id/name of a style property, as defined in the hackOptions below. (ex. "borderColor", "textboxWidth", "textSpeed", etc.)
- styleValue:		value to assign to the styleProperty, as defined in the hackOptions below. (ex. "[128,128,128,256]", "140", etc.)

-- REVERT TEXTBOX STYLE TO THE DEFAULT STYLE -----------------------------------

{resetTextStyle}
{resetTextStyleNow}

Information:
- Resets all style properties to the values in the default dialog style, as defined in the hackOptions below.

-- REVERT AN INDIVIDUAL TEXTBOX STYLE PROPERTY TO IT'S DEFAULT VALUE -----------

{resetProperty "styleProperty"}
{resetPropertyNow "styleProperty"}

Information:
- Resets an individual style property to it's default value, as defined in the hackOptions below.

Parameters:
- styleProperty:	id/name of a style property, as defined in the hackOptions below. (ex. "borderColor", "textboxWidth", "textSpeed", etc.)

-- SET OR MODIFY THE POSITION AND SIZE OF THE TEXTBOX TO AN ABSOLUTE VALUE -----

{textPosition "x, y, width, minLines, maxLines"}
{textPositionNow "x, y, width, minLines, maxLines"}

Information:
- Repositions and resizes the textbox, at an absolute position based on parameters.
- Calculates the necessary style properties and spacing for the textbox automatically.

Parameters:
- x, y:			The x and y coordinates of the top left corner. Measured in bitsy-scale pixels (0-128).
- width:		The width of the textbox. Measured in bitsy-scale pixels (0-128).
- minLines: 	The minimum number of lines to display on the textbox. Height resizes automatically.
- maxLines: 	The maximum number of lines to display on the textbox. Height resizes automatically.
				If any parameter is left blank, the textbox will use it's current values.
				If given a +/- value (+8, -40, etc) that value is adjusted relative to it's current value.

----------------------------------------------------------------

DIALOG TAG NOTES:
- Add "Now" to the end of these dialog tags to make the tag trigger mid-dialog, rather than after the current dialog is concluded.
- To reset a property or style to default values, you can also set a style or style property value to "default".
- NOTE: Changing the style after some text is already printed can break existing text.
- Colors are defined as 4 values, [red,green,blue,alpha], each ranging from 0-255.
- Alpha is opacity; colors can be translucent by reducing Alpha below 255. 0 is fully transparent.

Examples:
- {textStyleNow "center"} immediately applies a style defined below, which centers the textbox, without overriding other existing style properties.
- {setTextStyle "vertical"} after the current dialog ends, switches to a vertical textbox style, defined in dialogStyles.
- {textPropertyNow "textSpeed, 25"} immediately reduces the time to print each character to 25ms.
- {resetTextStyle} Once this text is finished, will reset the textbox to the default style.
- {resetPropertyNow "textScale"} Immediately restores the text scale property to the default setting.
- {textPosition "8, 8, 120"} Resizes the textbox to cover the entire screen, with 8 pixels of padding on every side.

TODO: For future versions
- Redraw existing textbox contents in new style, when switching, and then continue.
- Recalculate textbox's center position, considering textbox margins in center calculation?
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions =  {
// (Ayo's note: Please remember you can resize the infobox you're reading this in.)

// Determines where the textbox is positioned. "shift" moves the textbox based on the player's position.
verticalPosition: 'shift', // options are "top", "center", "bottom", or "shift" (moves based on player position)
horizontalPosition: 'center', // options are "left", "center", "right", or "shift" (moves based on player position)

textboxColor: [0, 0, 0, 255], // Colors text and textbox are drawn, in [R,G,B,A]. TODO: Alpha doesn't presently work!
textboxWidth: 120, // Width of textbox in pixels. Default 104.
textboxMarginX: 4, // Pixels of space outside the left (or right) of the textbox. Default 12.
textboxMarginY: 4, // Pixels of space outside the top (or bottom) of the textbox. Default 12.

textColor: [255, 255, 255, 255], // Default color of text.
textMinLines: 2, // Minimum number of rows for text. Determines starting textbox height. Default 2.
textMaxLines: 2, // Maximum number of rows for text. Determines max textbox height. Default 2.
textScale: 2, // Scaling factor for text. Default 2. Best with 1, 2, or 4.
textSpeed: 50, // Time to print each character, in milliseconds. Default 50.
textPaddingX: 0, // Default horizontal padding around the text.
textPaddingY: 2, // Default vertical padding around the text.

// Color the continue arrow is drawn using, in [R,G,B,A]
arrowColor: [255, 255, 255, 255], // Foreground color of arrow sprite.
arrowBGColor: [0, 0, 0, 255], // Background color. If transparent, draws no BG.

// Position of textbox continue arrow, on bottom of textbox.
arrowAlign: 'right', // Options are: "right", "center", or "left" aligned

// Pixels of padding the arrow is inset from the edge by
arrowInsetX: 12,
arrowInsetY: 0,

// Should match dimensions of the sprite below
arrowWidth: 8, // Width of arrow sprite below, in pixels
arrowHeight: 5, // Height of arrow sprite below, in pixels
arrowScale: 2, // Scaling factor for arrow sprite. Default 2. Best with 1, 2, or 4.

// Pixels defining the textbox continue arrow. 1 draws a pixel in main Color, 0 draws in BG Color.
arrowSprite: [
	1, 1, 1, 1, 1, 1, 1, 1,
	0, 1, 1, 1, 1, 1, 1, 0,
	0, 0, 1, 1, 1, 1, 0, 0,
	0, 0, 0, 1, 1, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
],
// Colors the borders are drawn using, in [R,G,B,A].
borderColor: [128, 128, 128, 255], // Foreground color for border tiles.
borderMidColor: [51, 51, 51, 255], // Foreground color used for middle border tiles.
borderBGColor: [0, 0, 0, 255], // Background color the border tiles. If transparent, draws no BG.

// Border is drawn past the edges of the textbox.
// Should match dimensions of the sprite below
borderWidth: 8, // Width of border sprites, in pixels. Default 8.
borderHeight: 8, // Height of border sprites, in pixels. Default 8.
borderScale: 2, // Scaling factor for border sprites. Default 2. Best with 1, 2, or 4.

// Pixels defining the corners and edges the border is drawn with. 1 draws a pixel in foreground color, 0 in BG.
borderUL: [
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 1, 1, 1, 1, 1, 1,
	0, 0, 1, 1, 1, 1, 1, 1,
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 0,
],
borderU: [
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
],
borderUR: [
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 1, 1, 1, 1, 0, 0,
	1, 1, 1, 1, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
],
borderL: [
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 0,
],
borderR: [
	0, 0, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
],
borderDL: [
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 1, 1, 1, 1, 1, 1,
	0, 0, 1, 1, 1, 1, 1, 1,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
],
borderD: [
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
],
borderDR: [
	0, 0, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
	0, 0, 0, 0, 1, 1, 0, 0,
	1, 1, 1, 1, 1, 1, 0, 0,
	1, 1, 1, 1, 1, 1, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
],
borderM: [
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
],

dialogStyles: {
	// You can define alternate Dialog Styles here, which can be switched to in-game from dialog.
	// These can be switched between using the (Style "styleName") or (ApplyStyle "styleName") commands.
	// These Dialog Styles are meant as examples. Feel free to edit, rename, or remove them.
	custom: {
		// Copy any hackOptions from above into this section, and modify them, to create a new Style.
	},
	vanilla: {
		// An example style, which emulates the original Bitsy textbox.
		verticalPosition: 'shift',
		horizontalPosition: 'center',
		textboxWidth: 104,
		textboxMarginX: 12,
		textboxMarginY: 12,
		textMinLines: 2,
		textMaxLines: 2,
		textPaddingX: 8,
		textPaddingY: 10,
		borderWidth: 0,
		borderHeight: 0,
		arrowScale: 4,
		arrowInsetX: 4,
		arrowInsetY: 1,
		arrowWidth: 5,
		arrowHeight: 3,
		arrowSprite: [
			1, 1, 1, 1, 1,
			0, 1, 1, 1, 0,
			0, 0, 1, 0, 0,
		],
	},
	centered: {
		// An example style, that centers the textbox as with Starting or Ending text.
		verticalPosition: 'center',
		horizontalPosition: 'center',
	},
	vertical: {
		// An example style, that positions the textbox vertically, on the left or right side.
		verticalPosition: 'center',
		horizontalPosition: 'shift',
		textboxWidth: 48,
		textMinLines: 16,
		textMaxLines: 16,
	},
	corner: {
		// An example style, which positions a resizing textbox in the corner opposite the player.
		verticalPosition: 'shift',
		horizontalPosition: 'shift',
		textboxWidth: 64,
		textMinLines: 1,
		textMaxLines: 8,
	},
	inverted: {
		// An example style, which inverts the normal textbox colors
		textboxColor: [255, 255, 255, 255],
		textColor: [0, 0, 0, 255],
		borderColor: [128, 128, 128, 255],
		borderMidColor: [204, 204, 204, 255],
		borderBGColor: [255, 255, 255, 255],
		arrowColor: [0, 0, 0, 255],
		arrowBGColor: [255, 255, 255, 255],
	},
	smallBorder: {
		// An example style, which uses a smaller border with a blue background.
		borderWidth: 4,
		borderHeight: 4,
		textPaddingX: 4,
		textPaddingY: 4,
		borderColor: [255, 255, 255, 255],
		borderBGColor: [51, 153, 204, 255],
		arrowBGColor: [51, 153, 204, 255],
		borderUL: [
			0, 0, 0, 0,
			0, 1, 1, 1,
			0, 1, 1, 0,
			0, 1, 0, 1,
		],
		borderU: [
			0, 0, 0, 0,
			1, 1, 1, 1,
			0, 0, 0, 0,
			0, 0, 0, 0,
		],
		borderUR: [
			0, 0, 0, 0,
			1, 1, 1, 0,
			0, 0, 1, 0,
			0, 1, 1, 0,
		],
		borderL: [
			0, 1, 0, 0,
			0, 1, 0, 0,
			0, 1, 0, 0,
			0, 1, 0, 0,
		],
		borderR: [
			1, 1, 1, 0,
			1, 1, 1, 0,
			1, 1, 1, 0,
			1, 1, 1, 0,
		],
		borderDL: [
			0, 1, 0, 0,
			0, 1, 0, 1,
			0, 1, 1, 1,
			0, 0, 0, 0,
		],
		borderD: [
			1, 1, 1, 1,
			1, 1, 1, 1,
			1, 1, 1, 1,
			0, 0, 0, 0,
		],
		borderDR: [
			0, 1, 1, 0,
			1, 0, 1, 0,
			1, 1, 1, 0,
			0, 0, 0, 0,
		],
		borderM: [
			0, 0, 0, 0,
			0, 0, 0, 0,
			0, 0, 0, 0,
			0, 0, 0, 0,
		],
	},
},
} ;

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw new Error('Couldn\'t find "' + searchRegex + '" in script tags');
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**
 * Helper for parsing parameters that may be relative to another value
 * e.g.
 * - getRelativeNumber('1', 5) -> 1
 * - getRelativeNumber('+1', 5) -> 6
 * - getRelativeNumber('-1', 5) -> 4
 * - getRelativeNumber('', 5) -> 5
 * @param {string} value absolute or relative string to parse
 * @param {number} relativeTo value to use as fallback if none is provided, and as base for relative value
 * @return {number} resulting absolute or relative number
 */
function getRelativeNumber(value, relativeTo) {
	var v = (value || value === 0 ? value : relativeTo);
	if (typeof v === 'string' && (v.startsWith('+') || v.startsWith('-'))) {
		return relativeTo + Number(v);
	}
	return Number(v);
}

/**
 * @param {number} value number to clamp
 * @param {number} min minimum
 * @param {number} max maximum
 * @return min if value < min, max if value > max, value otherwise
 */
function clamp(value, min, max) {
	return Math.max(min, Math.min(max, value));
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	if (
		!kitsy.queuedInjectScripts.some(function (script) {
			return searchRegex.toString() === script.searchRegex.toString() && replaceString === script.replaceString;
		})
	) {
		kitsy.queuedInjectScripts.push({
			searchRegex: searchRegex,
			replaceString: replaceString,
		});
	} else {
		console.warn('Ignored duplicate inject');
	}
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {},
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}

function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			}
			// run synchronously
			returnVal = functions[i++].apply(this, args);
			if (returnVal && returnVal.length) {
				args = returnVal;
			}
			return runBefore.apply(this, args);
		}

		return runBefore.apply(this, arguments);
	};
}

function reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
			if (match.substr(0, 1) === '\\') {
				return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}

function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject$1(
		/(var functionMap = new Map\(\);[^]*?)(this.HasFunction)/m,
		'$1\nfunctionMap.set("' + tag + '", ' + code + ');\n$2',
	);
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
	injectDialogTag(tag, 'function(e, p, o){ kitsy.deferredDialogFunctions["' + tag + '"].push({e:e,p:p}); o(null); }');
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
	addDialogTag(tag + 'Now', function (environment, parameters, onReturn) {
		fn(environment, parameters);
		onReturn(null);
	});
	addDeferredDialogTag(tag, fn);
}

/**
 * Helper for printing a paragraph break inside of a dialog function.
 * Adds the function `AddParagraphBreak` to `DialogBuffer`
 */

inject$1(/(this\.AddLinebreak = )/, 'this.AddParagraphBreak = function() { buffer.push( [[]] ); isActive = true; };\n$1');

/**
📃
@file paragraph-break
@summary Adds paragraph breaks to the dialogue parser
@license WTFPL (do WTF you want)
@version auto
@requires Bitsy Version: 5.0, 5.1
@author Sean S. LeBlanc, David Mowatt

@description
Adds a (p) tag to the dialogue parser that forces the following text to
start on a fresh dialogue screen, eliminating the need to spend hours testing
line lengths or adding multiple line breaks that then have to be reviewed
when you make edits or change the font size.

Note: Bitsy has a built-in implementation of paragraph-break as of 7.0;
before using this, you may want to check if it fulfills your needs.

Usage: (p)

Example: I am a cat(p)and my dialogue contains multitudes

HOW TO USE:
  1. Copy-paste this script into a new script tag after the Bitsy source code.
     It should appear *before* any other mods that handle loading your game
     data so it executes *after* them (last-in first-out).

NOTE: This uses parentheses "()" instead of curly braces "{}" around function
      calls because the Bitsy editor's fancy dialog window strips unrecognized
      curly-brace functions from dialog text. To keep from losing data, write
      these function calls with parentheses like the examples above.

      For full editor integration, you'd *probably* also need to paste this
      code at the end of the editor's `bitsy.js` file. Untested.
*/

// Adds the actual dialogue tag. No deferred version is required.
addDialogTag('p', function (environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddParagraphBreak();
	onReturn(null);
});
// End of (p) paragraph break mod





// Make them accessible at a higher scope, so Dialog functions can see them.
var textboxStyler = window.textboxStyler = {
	defaultStyle: {
		verticalPosition: hackOptions.verticalPosition,
		horizontalPosition: hackOptions.horizontalPosition,
		textboxColor: hackOptions.textboxColor,
		textboxWidth: hackOptions.textboxWidth,
		textboxMarginX: hackOptions.textboxMarginX,
		textboxMarginY: hackOptions.textboxMarginY,
		textColor: hackOptions.textColor,
		textMinLines: hackOptions.textMinLines,
		textMaxLines: hackOptions.textMaxLines,
		textScale: hackOptions.textScale,
		textSpeed: hackOptions.textSpeed,
		textPaddingX: hackOptions.textPaddingX,
		textPaddingY: hackOptions.textPaddingY,
		borderColor: hackOptions.borderColor,
		borderBGColor: hackOptions.borderBGColor,
		borderMidColor: hackOptions.borderMidColor,
		borderWidth: hackOptions.borderWidth,
		borderHeight: hackOptions.borderHeight,
		borderScale: hackOptions.borderScale,
		arrowColor: hackOptions.arrowColor,
		arrowBGColor: hackOptions.arrowBGColor,
		arrowScale: hackOptions.arrowScale,
		arrowAlign: hackOptions.arrowAlign,
		arrowInsetX: hackOptions.arrowInsetX,
		arrowInsetY: hackOptions.arrowInsetY,
		arrowWidth: hackOptions.arrowWidth,
		arrowHeight: hackOptions.arrowHeight,
		arrowSprite: hackOptions.arrowSprite,
		borderUL: hackOptions.borderUL,
		borderU: hackOptions.borderU,
		borderUR: hackOptions.borderUR,
		borderL: hackOptions.borderL,
		borderR: hackOptions.borderR,
		borderDL: hackOptions.borderDL,
		borderD: hackOptions.borderD,
		borderDR: hackOptions.borderDR,
		borderM: hackOptions.borderM,
	},

	activeStyle: {
		verticalPosition: hackOptions.verticalPosition,
		horizontalPosition: hackOptions.horizontalPosition,
		textboxColor: hackOptions.textboxColor,
		textboxWidth: hackOptions.textboxWidth,
		textboxMarginX: hackOptions.textboxMarginX,
		textboxMarginY: hackOptions.textboxMarginY,
		textColor: hackOptions.textColor,
		textMinLines: hackOptions.textMinLines,
		textMaxLines: hackOptions.textMaxLines,
		textScale: hackOptions.textScale,
		textSpeed: hackOptions.textSpeed,
		textPaddingX: hackOptions.textPaddingX,
		textPaddingY: hackOptions.textPaddingY,
		borderColor: hackOptions.borderColor,
		borderBGColor: hackOptions.borderBGColor,
		borderMidColor: hackOptions.borderMidColor,
		borderWidth: hackOptions.borderWidth,
		borderHeight: hackOptions.borderHeight,
		borderScale: hackOptions.borderScale,
		arrowColor: hackOptions.arrowColor,
		arrowBGColor: hackOptions.arrowBGColor,
		arrowScale: hackOptions.arrowScale,
		arrowAlign: hackOptions.arrowAlign,
		arrowInsetX: hackOptions.arrowInsetX,
		arrowInsetY: hackOptions.arrowInsetY,
		arrowWidth: hackOptions.arrowWidth,
		arrowHeight: hackOptions.arrowHeight,
		arrowSprite: hackOptions.arrowSprite,
		borderUL: hackOptions.borderUL,
		borderU: hackOptions.borderU,
		borderUR: hackOptions.borderUR,
		borderL: hackOptions.borderL,
		borderR: hackOptions.borderR,
		borderDL: hackOptions.borderDL,
		borderD: hackOptions.borderD,
		borderDR: hackOptions.borderDR,
		borderM: hackOptions.borderM,
	},

	styles: hackOptions.dialogStyles,

	// Sets activeStyle elements to the new style if defined, or to defaultStyle's elements if not.
	style: function (newStyle) {
		console.log('SETTING TEXTBOX STYLE TO: ' + newStyle);
		// If newStyle doesn't exist, resets to default
		if (!textboxStyler.styles[newStyle]) {
			textboxStyler.resetStyle();
			console.log('UNDEFINED STYLE. RESETTING TO DEFAULT.');
			return;
		}
		textboxStyler.activeStyle = Object.assign({}, textboxStyler.defaultStyle, textboxStyler.styles[newStyle]);
		textboxStyler.updateTextbox(); // Updates values used for rendering text.
	},
	// Applies defined style parameters to the existing style, without changing anything else.
	setStyle: function (newStyle) {
		console.log('APPLYING STYLE ' + newStyle + ' TO EXISTING TEXTBOX STYLE');
		// If newStyle doesn't exist, does nothing.
		if (!textboxStyler.styles[newStyle]) {
			console.log('UNDEFINED STYLE.');
			return;
		}
		textboxStyler.activeStyle = Object.assign({}, textboxStyler.activeStyle, textboxStyler.styles[newStyle]);
		textboxStyler.updateTextbox();
	},
	// Manually sets a specific property of the active style.
	setProperty: function (property, value) {
		console.log('APPLYING STYLE PROPERTY: ' + property + ', ' + value);
		if (Object.prototype.hasOwnProperty.call(textboxStyler.activeStyle, property)) {
			if (!value || value === 'default') {
				console.log('UNDEFINED PROPERTY. SETTING TO DEFAULT.');
				textboxStyler.activeStyle[property] = Object.assign({}, textboxStyler.defaultStyle)[property];
			} else {
				textboxStyler.activeStyle[property] = value;
			}
		}

		textboxStyler.updateTextbox();
	},
	// Resets Active Textbox Style to Default Style
	resetStyle: function () {
		console.log('RESETTING TO DEFAULT TEXTBOX STYLE');
		textboxStyler.activeStyle = Object.assign({}, textboxStyler.defaultStyle);

		textboxStyler.updateTextbox();
	},
	// Resets a Textbox Style Property to it's Default value
	resetProperty: function (property) {
		console.log('RESETTING STYLE PROPERTY TO DEFAULT: ' + property);
		if (Object.prototype.hasOwnProperty.call(textboxStyler.activeStyle, property)) {
			textboxStyler.activeStyle[property] = Object.assign({}, textboxStyler.defaultStyle)[property];
		} else {
			console.log('UNDEFINED PROPERTY.');
			return;
		}

		textboxStyler.updateTextbox();
	},
	// A command to set or adjust the absolute position, width, and lines of a textbox.
	textboxPosition: function (x, y, boxWidth, boxMinLines, boxMaxLines) {
		var curX = textboxStyler.activeStyle.textboxMarginX;
		var curY = textboxStyler.activeStyle.textboxMarginY;
		var curWidth = textboxStyler.activeStyle.textboxWidth;
		var curMinLines = textboxStyler.activeStyle.textboxMinLines;
		var curMaxLines = textboxStyler.activeStyle.textboxMaxLines;

		x = clamp(getRelativeNumber(x, curX), 0, bitsy.width - 1);
		y = clamp(getRelativeNumber(y, curY), 0, bitsy.height - 1);
		boxWidth = clamp(getRelativeNumber(boxWidth, curWidth), 0, bitsy.width - 1);
		boxMinLines = clamp(getRelativeNumber(boxMinLines, curMinLines), 0, bitsy.height - 1);
		boxMaxLines = clamp(getRelativeNumber(boxMaxLines, curMaxLines), 0, bitsy.height - 1);

		textboxStyler.activeStyle.textboxWidth = boxWidth;
		textboxStyler.activeStyle.textboxMinLines = boxMinLines;
		textboxStyler.activeStyle.textboxMaxLines = boxMaxLines;
		textboxStyler.activeStyle.textboxMarginY = y;
		textboxStyler.activeStyle.textboxMarginX = x;
		textboxStyler.activeStyle.verticalPosition = 'top';
		textboxStyler.activeStyle.horizontalPosition = 'left';

		textboxStyler.updateTextbox();
	},

	// First draft of position. Kept here for future versions.
	textboxCornersWIP: function (x1, y1, x2, y2) {
		// Trim and sanitize X and Y Positions, and set to current position if omitted.
		var curX1 = textboxStyler.activeStyle.textboxMarginX;
		var curX2 = curX1 + textboxStyler.activeStyle.textboxWidth;
		var curY1 = textboxStyler.activeStyle.textboxMarginY;
		var curY2 = curY1 + (textboxStyler.activeStyle.textPaddingY + textboxStyler.activeStyle.borderHeight - 2 + (2 * textboxStyler.activeStyle.textMinLines));

		x1 = clamp(getRelativeNumber(x1, curX1), 0, bitsy.width - 1);
		x2 = clamp(getRelativeNumber(x2, curX2), 0, bitsy.width - 1);
		y1 = clamp(getRelativeNumber(y1, curY1), 0, bitsy.height - 1);
		y2 = clamp(getRelativeNumber(y2, curY2), 0, bitsy.height - 1);

		console.log('SETTING TEXTBOX CORNERS TO (' + x1 + ',' + y1 + ') and (' + x2 + ',' + y2 + ')');
		var topPos = Math.min(y1, y2);
		var leftPos = Math.min(x1, x2);
		var bottomPos = Math.max(y1, y2);
		var rightPos = Math.max(x1, x2);
		var width = rightPos - leftPos;
		var height = bottomPos - topPos;
		var lineCount = Math.floor(height / 8);

		textboxStyler.activeStyle.textboxWidth = width;
		textboxStyler.activeStyle.textMinLines = Math.max(1, lineCount);
		textboxStyler.activeStyle.textMaxLines = Math.max(1, lineCount);
		textboxStyler.activeStyle.textPaddingY = (height - (textboxStyler.activeStyle.textMinLines * 8)) / 2;
		textboxStyler.activeStyle.textboxMarginY = topPos;
		textboxStyler.activeStyle.textboxMarginX = leftPos;
		textboxStyler.activeStyle.verticalPosition = 'top';
		textboxStyler.activeStyle.horizontalPosition = 'left';

		textboxStyler.updateTextbox();
	},
	// Updates parameters of the textbox based on style settings.
	// TODO: see if you can re-render existing textbox content in new style?
	updateTextbox: function () {
		window.textboxInfo.width = textboxStyler.activeStyle.textboxWidth;
		// window.textboxInfo.height = textboxStyler.activeStyle.textPaddingY + textboxStyler.activeStyle.borderHeight - 2 + (2 * textboxStyler.activeStyle.textMinLines);
		window.textboxInfo.top = textboxStyler.activeStyle.textboxMarginY;
		window.textboxInfo.left = textboxStyler.activeStyle.textboxMarginX;
		window.textboxInfo.bottom = textboxStyler.activeStyle.textboxMarginY;
		window.textboxInfo.font_scale = textboxStyler.activeStyle.textScale / 4;
		window.textboxInfo.padding_vert = textboxStyler.activeStyle.textPaddingY;
		window.textboxInfo.padding_horz = textboxStyler.activeStyle.textPaddingX;
		window.textboxInfo.arrow_height = textboxStyler.activeStyle.textPaddingY + textboxStyler.activeStyle.borderHeight - 4;

		window.textboxInfo.img = bitsy.ctx.createImageData(window.textboxInfo.width * bitsy.scale, window.textboxInfo.height * bitsy.scale);
	},
	// Draw border to the background of the textbox image, before rendering text or arrows.
	drawBorder: function () {
		// console.log ("DRAWING TEXTBOX BORDER");
		// Iterates through each pixel of the textbox, and determines if a border pixel should be drawn.
		// Compares 1D array of textbox pixels to 1D arrays for each border sprite, to determine whether to draw a pixel.
		for (var y = 0; y < (4 / textboxStyler.activeStyle.borderScale) * window.textboxInfo.height; y++) {
			for (var x = 0; x < (4 / textboxStyler.activeStyle.borderScale) * window.textboxInfo.width; x++) {
				// NOTE: borderXId and borderYId translate message box coordinates to border tile coordinates.
				// Use modulo to translate textbox space into tiles, for drawing borders pixel-by-pixel.
				// For bottom/right borders, border sprites should be anchored to the bottom/right instead.
				// borderYId and borderXId get pixel coordinates anchored to the top or left
				// borderDId and borderRId get pixel coordinates anchored to down or right (for right/bottom edges)
				var borderYId = (y % textboxStyler.activeStyle.borderHeight);
				var borderXId = (x % textboxStyler.activeStyle.borderWidth);
				var borderDId = ((y + ((4 / textboxStyler.activeStyle.borderScale) * window.textboxInfo.height)) % textboxStyler.activeStyle.borderHeight);
				var borderRId = ((x + ((4 / textboxStyler.activeStyle.borderScale) * window.textboxInfo.width)) % textboxStyler.activeStyle.borderWidth);

				// NOTE: There's a weird bug with odd vs even textbox heights. Here's a hacky fix for now.
				// TODO: Handle decimal heights? Still bugs with those (may come up with bitsy's text scaling)
				if (window.textboxInfo.height % textboxStyler.activeStyle.borderScale !== 0) {
					borderDId = ((y - 4 + ((4 / textboxStyler.activeStyle.borderScale) * window.textboxInfo.height)) % textboxStyler.activeStyle.borderHeight);
				}

				// Calculates index in the 1D array of the border sprite.
				var borderPxl = (borderYId * textboxStyler.activeStyle.borderWidth) + borderXId;
				var bottomPxl = (borderDId * textboxStyler.activeStyle.borderWidth) + borderXId;
				var rightPxl = (borderYId * textboxStyler.activeStyle.borderWidth) + borderRId;
				var bottomRightPxl = (borderDId * textboxStyler.activeStyle.borderWidth) + borderRId;

				// Determines if the current pixel is along one of the textbox's edges, or if it's in the center.
				var borderTop = y < textboxStyler.activeStyle.borderHeight;
				var borderBottom = y >= window.textboxInfo.height * (4 / textboxStyler.activeStyle.borderScale) - textboxStyler.activeStyle.borderHeight;
				var borderLeft = x < textboxStyler.activeStyle.borderWidth;
				var borderRight = x >= window.textboxInfo.width * (4 / textboxStyler.activeStyle.borderScale) - textboxStyler.activeStyle.borderWidth;

				// Does this pixel is draw???
				// 1= draw a border pixel, 0= No! Draw a border bg pixel instead
				var borderDraw;

				// Retrieve pixel data from appropriate sprite. Special handling for bottom/right borders!
				if (borderBottom) {
					if (borderLeft) {
						// Bottom Left Corner
						borderDraw = textboxStyler.activeStyle.borderDL[bottomPxl];
					} else if (borderRight) {
						// Bottom Right Corner
						borderDraw = textboxStyler.activeStyle.borderDR[bottomRightPxl];
					} else {
						// Bottom Middle Edge
						borderDraw = textboxStyler.activeStyle.borderD[bottomPxl];
					}
				} else if (borderTop) {
					if (borderLeft) {
						// Top Left Corner
						borderDraw = textboxStyler.activeStyle.borderUL[borderPxl];
					} else if (borderRight) {
						// Top Right Corner
						borderDraw = textboxStyler.activeStyle.borderUR[rightPxl];
					} else {
						// Top Middle Edge
						borderDraw = textboxStyler.activeStyle.borderU[borderPxl];
					}
				} else if (borderLeft) {
					// Left Edge
					borderDraw = textboxStyler.activeStyle.borderL[borderPxl];
				} else if (borderRight) {
					// Right Edge
					borderDraw = textboxStyler.activeStyle.borderR[rightPxl];
				} else {
					// Middle
					borderDraw = textboxStyler.activeStyle.borderM[borderPxl];
				}

				// scaling shenanigans (maps sprite scale pixels to bitsy/screen-scale pixels)
				for (var sy = 0; sy < textboxStyler.activeStyle.borderScale; sy++) {
					for (var sx = 0; sx < textboxStyler.activeStyle.borderScale; sx++) {
						var pxl = 4 * ((((textboxStyler.activeStyle.borderScale * y) + sy) * (4 * window.textboxInfo.width)) + (textboxStyler.activeStyle.borderScale * x) + sx);

						// If it's a border pixel, Retrieves RGBA values for the border, and draws it.
						if (borderDraw) {
							if (borderTop || borderBottom || borderLeft || borderRight) {
								window.textboxInfo.img.data[pxl + 0] = textboxStyler.activeStyle.borderColor[0];
								window.textboxInfo.img.data[pxl + 1] = textboxStyler.activeStyle.borderColor[1];
								window.textboxInfo.img.data[pxl + 2] = textboxStyler.activeStyle.borderColor[2];
								window.textboxInfo.img.data[pxl + 3] = textboxStyler.activeStyle.borderColor[3];
							} else {
								window.textboxInfo.img.data[pxl + 0] = textboxStyler.activeStyle.borderMidColor[0];
								window.textboxInfo.img.data[pxl + 1] = textboxStyler.activeStyle.borderMidColor[1];
								window.textboxInfo.img.data[pxl + 2] = textboxStyler.activeStyle.borderMidColor[2];
								window.textboxInfo.img.data[pxl + 3] = textboxStyler.activeStyle.borderMidColor[3];
							}
						} else if (borderTop || borderBottom || borderLeft || borderRight) {
							// If it's a border BG pixel, gets RGBA colors based on if it's on an edge or in middle.
							window.textboxInfo.img.data[pxl + 0] = textboxStyler.activeStyle.borderBGColor[0];
							window.textboxInfo.img.data[pxl + 1] = textboxStyler.activeStyle.borderBGColor[1];
							window.textboxInfo.img.data[pxl + 2] = textboxStyler.activeStyle.borderBGColor[2];
							window.textboxInfo.img.data[pxl + 3] = textboxStyler.activeStyle.borderBGColor[3];
						} else {
							window.textboxInfo.img.data[pxl + 0] = textboxStyler.activeStyle.textboxColor[0];
							window.textboxInfo.img.data[pxl + 1] = textboxStyler.activeStyle.textboxColor[1];
							window.textboxInfo.img.data[pxl + 2] = textboxStyler.activeStyle.textboxColor[2];
							window.textboxInfo.img.data[pxl + 3] = textboxStyler.activeStyle.textboxColor[3];
						}
					}
				}
			}
		}
	},
};

// Applies only a Style's defined attributes to the current textbox style.
// {style "StyleName"}
// {textStyleNow "StyleName"}
addDualDialogTag('textStyle', function (_environment, parameters) {
	textboxStyler.style(parameters[0]);
});

// Sets the current Style of the textbox (undefined attributes use Defaults instead)
// {setTextStyle "StyleName"}
// {setTextStyleNow "StyleName"}
addDualDialogTag('setTextStyle', function (_environment, parameters) {
	textboxStyler.setStyle(parameters[0]);
});

// Applies the current Style of the textbox (undefined attributes use Defaults instead)
// {textProperty "StyleProperty, StyleValue"}
// {textPropertyNow "StyleProperty, StyleValue"}
addDualDialogTag('textProperty', function (_environment, parameters) {
	var params = parameters[0].split(',');
	textboxStyler.setProperty(params[0], params[1]);
});

// Resets the Style of the textbox to the Default style.
// {resetTextStyle}
// {resetTextStyleNow}
addDualDialogTag('resetTextStyle', function () {
	textboxStyler.resetStyle();
});

// Resets a Style Property of the textbox to it's Default value.
// {resetTextProperty "StyleProperty"}
// {resetTextPropertyNow "StyleProperty"}
addDualDialogTag('resetTextProperty', function (_environment, parameters) {
	textboxStyler.resetProperty(parameters[0]);
});

// Repositions and resizes textbox at an absolute position, based on coordinates.
// {textPosition "x, y, width, minLines, maxLines"}
// {textPositionNow "x, y, width, minLines, maxLines"}
addDualDialogTag('textPosition', function (_environment, parameters) {
	var params = parameters[0].split(',');
	textboxStyler.textboxPosition(params[0], params[1], params[2], params[3], params[4]);
});

// =============================================================
// | HACK SCRIPT INJECTS |/////////////////////////////////////|
// =============================================================
// Replaces initial textbox parameters, based on currently active style (or defaults).
// Makes textboxInfo available at the window level
// Recalculates textbox parameters, even values no longer used with hack, for compatibility.
var textboxInfoReplace = `var textboxInfo = {
	img : null,
	width : textboxStyler.activeStyle.textboxWidth,
	height : textboxStyler.activeStyle.textPaddingY + textboxStyler.activeStyle.borderHeight - 2 + (2 * textboxStyler.activeStyle.textMinLines),
	top : textboxStyler.activeStyle.textboxMarginY,
	left : textboxStyler.activeStyle.textboxMarginX,
	bottom : textboxStyler.activeStyle.textboxMarginY,
	font_scale : textboxStyler.activeStyle.textScale/4,
	padding_vert : textboxStyler.activeStyle.textPaddingY,
	padding_horz : textboxStyler.activeStyle.textPaddingX,
	arrow_height : textboxStyler.activeStyle.textPaddingY + textboxStyler.activeStyle.borderHeight - 4,
};
window.textboxInfo = textboxInfo;`;
inject$1(/var textboxInfo = [^]*?};/, textboxInfoReplace);

// Replaces ClearTextbox function to include border-drawing scripts
var clearTextboxReplace = `this.ClearTextbox = function() {
	if(context == null) return;

	//create new image none exists
	if(textboxInfo.img == null)
		textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);

	// Draw Textbox Background based on BGColor (indices are R,G,B, and A)
	for (var i=0;i<textboxInfo.img.data.length;i+=4)
	{
		textboxInfo.img.data[i+0]=textboxStyler.activeStyle.textboxColor[0];
		textboxInfo.img.data[i+1]=textboxStyler.activeStyle.textboxColor[1];
		textboxInfo.img.data[i+2]=textboxStyler.activeStyle.textboxColor[2];
		textboxInfo.img.data[i+3]=textboxStyler.activeStyle.textboxColor[3];
	}

	textboxStyler.drawBorder();
};`;
inject$1(/this.ClearTextbox = [^]*?};/, clearTextboxReplace);

// Replaces Draw Textbox function, with function that supports vertical and horizontal shifting
var drawTextboxReplace = `this.DrawTextbox = function() {
	if(context == null) return;

	// Textbox defaults to center-aligned
	var textboxXPosition = ((width/2)-(textboxInfo.width/2))*scale;
	var textboxYPosition = ((height/2)-(textboxInfo.height/2))*scale;

	if (isCentered) {
		context.putImageData(textboxInfo.img, textboxXPosition, textboxYPosition);
	}
	else {
		if (textboxStyler.activeStyle.verticalPosition.toLowerCase() == "shift") {
			if (player().y < mapsize/2) {
				//player on bottom half, so draw on top
				textboxYPosition = ((height-textboxInfo.top-textboxInfo.height)*scale);
			}
			else {
				textboxYPosition = textboxInfo.top*scale;
			}
		}
		else if (textboxStyler.activeStyle.verticalPosition.toLowerCase() == "top") {
			textboxYPosition = textboxInfo.top*scale;
		}
		else if (textboxStyler.activeStyle.verticalPosition.toLowerCase() == "bottom") {
			textboxYPosition = ((height-textboxInfo.top-textboxInfo.height)*scale);
		}

		if (textboxStyler.activeStyle.horizontalPosition.toLowerCase() == "shift") {
			if (player().x < mapsize/2) {
				// player on left half, so draw on right
				textboxXPosition = ((width-textboxInfo.left-textboxInfo.width)*scale);
			}
			else {
				textboxXPosition = textboxInfo.left*scale;
			}
		}
		else if (textboxStyler.activeStyle.horizontalPosition.toLowerCase() == "right") {
			textboxXPosition = ((width-textboxInfo.left-textboxInfo.width)*scale);
		}
		else if (textboxStyler.activeStyle.horizontalPosition.toLowerCase() == "left") {
			textboxXPosition = textboxInfo.left*scale;
		}

		// Draw the Textbox
		context.putImageData(textboxInfo.img, textboxXPosition, textboxYPosition);
	}
};`;
inject$1(/this.DrawTextbox = [^]*?};/, drawTextboxReplace);

// Replace DrawNextArrow function, to support custom sprites, colors, and arrow repositioning
var drawNextArrowReplace = `this.DrawNextArrow = function() {
	// Arrow sprite is center-bottom by default
	var top = ((4/textboxStyler.activeStyle.arrowScale)*textboxInfo.height - textboxStyler.activeStyle.arrowHeight - textboxStyler.activeStyle.arrowInsetY) *  textboxStyler.activeStyle.arrowScale;
	var left = ((4/textboxStyler.activeStyle.textboxArrowScale)*textboxInfo.width - textboxStyler.activeStyle.arrowXSize) * textboxStyler.activeStyle.textboxArrowScale*0.5;

	// Reposition arrow based on arrowAlign and RTL settings (flipped for RTL Languages)
	if (textboxStyler.activeStyle.arrowAlign.toLowerCase() == "left") {
		if (textDirection === TextDirection.RightToLeft) {
			left = ((4/textboxStyler.activeStyle.arrowScale)*textboxInfo.width - textboxStyler.activeStyle.arrowWidth - textboxStyler.activeStyle.arrowInsetX) *  textboxStyler.activeStyle.arrowScale;
		}
		else {
			left = (textboxStyler.activeStyle.arrowXPadding) * textboxStyler.activeStyle.textboxArrowScale;
		}
	}
	else if (textboxStyler.activeStyle.arrowAlign.toLowerCase() == "right") {
		if (textDirection === TextDirection.RightToLeft) {
			left = (arrowXPadding) * textboxArrowScale;
		}
		else {
			left = ((4/textboxStyler.activeStyle.arrowScale)*textboxInfo.width - textboxStyler.activeStyle.arrowWidth - textboxStyler.activeStyle.arrowInsetX) *  textboxStyler.activeStyle.arrowScale;
		}
	}
	
	// Draw arrow sprite pixels on textbox
	for (var y = 0; y < textboxStyler.activeStyle.arrowHeight; y++) {
		for (var x = 0; x < textboxStyler.activeStyle.arrowWidth; x++) {
			var i = (y * textboxStyler.activeStyle.arrowWidth) + x;

			//scaling hooplah
			for (var sy = 0; sy < textboxStyler.activeStyle.arrowScale; sy++) {
				for (var sx = 0; sx < textboxStyler.activeStyle.arrowScale; sx++) {
					var pxl = 4 * ( ((top+(y*textboxStyler.activeStyle.arrowScale)+sy) * (textboxInfo.width*4)) + (left+(x*textboxStyler.activeStyle.arrowScale)+sx) );
					// Draws arrow's pixels in Arrow Color
					if (textboxStyler.activeStyle.arrowSprite[i] == 1) {
						textboxInfo.img.data[pxl+0] = textboxStyler.activeStyle.arrowColor[0];
						textboxInfo.img.data[pxl+1] = textboxStyler.activeStyle.arrowColor[1];
						textboxInfo.img.data[pxl+2] = textboxStyler.activeStyle.arrowColor[2];
						textboxInfo.img.data[pxl+3] = textboxStyler.activeStyle.arrowColor[3];
					}
					// Draws arrow's bg pixels using Arrow BG Color
					else {
						textboxInfo.img.data[pxl+0] = textboxStyler.activeStyle.arrowBGColor[0];
						textboxInfo.img.data[pxl+1] = textboxStyler.activeStyle.arrowBGColor[1];
						textboxInfo.img.data[pxl+2] = textboxStyler.activeStyle.arrowBGColor[2];
						textboxInfo.img.data[pxl+3] = textboxStyler.activeStyle.arrowBGColor[3];
					}
				}
			}
		}
	}
};`;
inject$1(/this.DrawNextArrow = [^]*?};/, drawNextArrowReplace);

// Inject to support custom text scaling
inject$1(/var text_scale = .+?;/, 'var text_scale = textboxStyler.activeStyle.textScale;');

// Injects to support text padding within the textbox
var topTextPaddingReplace = 'var top = (2 * textboxStyler.activeStyle.textPaddingY) + (textboxStyler.activeStyle.borderHeight * 2) + (row * 2 * scale) + (row * font.getHeight() * textboxStyler.activeStyle.textScale) + Math.floor( char.offset.y );';
var leftTextPaddingReplace = 'var left = (2* textboxStyler.activeStyle.textPaddingX) + (textboxStyler.activeStyle.borderWidth * 2) + (leftPos * textboxStyler.activeStyle.textScale) + Math.floor( char.offset.x );';
inject$1(/var top = \(4 \* scale\) \+ \(row \* 2 \* scale\) .+?\);/, topTextPaddingReplace);
inject$1(/var left = \(4 \* scale\) \+ \(leftPos \* text_scale\) .+?\);/, leftTextPaddingReplace);

// Inject to support custom text speeds
inject$1(/var nextCharMaxTime = .+?;/, 'var nextCharMaxTime = textboxStyler.activeStyle.textSpeed;');

// Inject to support custom default text color
inject$1(/this.color = .+?};/, 'this.color = { r:textboxStyler.activeStyle.textColor[0], g:textboxStyler.activeStyle.textColor[1], b:textboxStyler.activeStyle.textColor[2], a:textboxStyler.activeStyle.textColor[3] };');

// Inject to support dynamic textbox resizing. Attach to window to make it accessible from hack.
inject$1(/var pixelsPerRow = .+?;/, 'window.pixelsPerRow = (textboxStyler.activeStyle.textboxWidth*(4/textboxStyler.activeStyle.textScale)) - (textboxStyler.activeStyle.borderWidth*(4/textboxStyler.activeStyle.textScale)) - (textboxStyler.activeStyle.textPaddingX*(4/textboxStyler.activeStyle.textScale));');
// var pixelsPerRow = (textboxWidth*2) - (borderWidth*2) - (textPaddingX*2); // hard-coded fun times!!! 192

// Store font height at parent level when calculated.
var fontSizeInject = `else if (args[0] == "SIZE") {
	width = parseInt(args[1]);
	height = parseInt(args[2]);
	window.fontHeight = height;
	console.log(fontHeight);
}`;
inject$1(/else if \(args\[0\] == "SIZE"\) {[^]*?}/, fontSizeInject);
// =============================================================
// | RE-IMPLEMENTED LONG DIALOG HACK INJECTS |/////////////////|
// =============================================================
// Modified from Sean leBlanc's Long Dialog hack, to include textbox borders and padding
// Needed to recalculate textbox height, based on current style parameters.
// Added textMinLines and textMaxLines to hackOptions parameters, to include in style swapping

// override textbox height (and recalculate textboxWidth)
inject$1(/textboxInfo\.height = .+;/, `Object.defineProperty(textboxInfo, 'height', {
	get() { return textboxStyler.activeStyle.textPaddingY + textboxStyler.activeStyle.borderHeight - 2 + ((2 + relativeFontHeight()) * Math.max(textboxStyler.activeStyle.textMinLines, dialogBuffer.CurPage().indexOf(dialogBuffer.CurRow())+Math.sign(dialogBuffer.CurCharCount()))); }
})`);

// prevent textbox from caching
inject$1(/(if\(textboxInfo\.img == null\))/, '// $1');

// rewrite hard-coded row limit
inject$1(/(else if \(curRowIndex )== 0/g, '$1 < textboxStyler.activeStyle.textMaxLines - 1');
inject$1(/(if \(lastPage\.length) <= 1/, '$1 < textboxStyler.activeStyle.textMaxLines');

exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

}(this.hacks.textbox_styler = this.hacks.textbox_styler || {}, window));

/**
😌
@file bitsymuse
@summary A variety of Bitsy sound and music handlers
@license MIT
@version 15.4.2
@requires 4.8, 4.9
@author David Mowatt

@description
A hack that adds a variety of audio controls, including music that changes as you move between rooms.
If the same song is played as you move between rooms, the audio file will continue playing.

Check out https://kool.tools/bitsy/tools/bitsymuse-ui for a tool to help configure this hack

HOW TO USE:
1. Place your audio files somewhere relative to your bitsy html file (in the zip if you're uploading to itch.io)
2. Copy-paste this script into a script tag after the bitsy source.
3. Edit hackOptions below to set up the track list for rooms you move through.

In addition to the track list, which will play audio based on the room id/name,
you have access to the following commands you can add to dialogue:

1. (soundeffectNow "<audio ID>") will play a sound without interrupting the music as soon as it is called in the dialogue
2. (soundeffect "<audio ID>") will play a sound without interrupting the music once the dialogue box closes
3. (musicNow "<audio ID>") will change the music as soon as it is called in the dialogue
4. (music "<audio ID>") will change the music once the dialogue box closes

You can call both musicNow and music in the same dialogue, to e.g. change the music while you speak to a character
and then restart the regular room music once you stop speaking to them.
You can also use a special ID ("S" by default) to Silence the music.

By default, music tracks automatically restart from the beginning if you go back to a previous track.
This can also be changed in the hackOptions below.
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions =  {
// Put entries in this list for each audio file you want to use.
// The key will be the id needed to play it in dialog tags and 
// the musicByRoom options below, and the value will be the 
// properties of the corresponding <audio> tag (e.g. src, loop, volume)
// Note: you can add <audio> tags to the html manually if you prefer

audio: {
	// Note: the entries below are examples that should be removed and replaced with your own audio files
	'example song ID': { src: './example song filepath.mp3', loop: true },
	'example sfx ID': { src: './example sfx filepath.mp3', volume: 0.5 },
},
	
// Put entries in this list for every room ID or name that will 
// change the music. If the player moves between rooms with the 
// same audio ID, the music keeps playing seamlessly.

// Undefined rooms will keep playing whatever music they were last playing.

musicByRoom: {
	// Note: the entries below are examples that should be removed and replaced with your own room -> audio id mappings
	0: 'example song ID',
	1: 'S', // This room is silent - it will stop music when you enter (see `silenceId` below)
	2: 'another song ID',
	h: 'a song ID for a room with a non-numeric ID',
	'my room': 'a song ID for a room with a user-defined name',
},

silenceId: 'S', // Use this song ID to make a room fall silent.
resume: false, // If true, songs will pause/resume on change; otherwise, they'll stop/play (doesn't affect sound effect
} ;

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw new Error('Couldn\'t find "' + searchRegex + '" in script tags');
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting room by name or id
 * @param {string} name id or name of room to return
 * @return {string} room, or undefined if it doesn't exist
 */
function getRoom(name) {
	var id = Object.prototype.hasOwnProperty.call(bitsy.room, name) ? name : bitsy.names.room.get(name);
	return bitsy.room[id];
}

/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	if (
		!kitsy.queuedInjectScripts.some(function (script) {
			return searchRegex.toString() === script.searchRegex.toString() && replaceString === script.replaceString;
		})
	) {
		kitsy.queuedInjectScripts.push({
			searchRegex: searchRegex,
			replaceString: replaceString,
		});
	} else {
		console.warn('Ignored duplicate inject');
	}
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {},
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}

function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			}
			// run synchronously
			returnVal = functions[i++].apply(this, args);
			if (returnVal && returnVal.length) {
				args = returnVal;
			}
			return runBefore.apply(this, args);
		}

		return runBefore.apply(this, arguments);
	};
}

function reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
			if (match.substr(0, 1) === '\\') {
				return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}

function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject$1(
		/(var functionMap = new Map\(\);[^]*?)(this.HasFunction)/m,
		'$1\nfunctionMap.set("' + tag + '", ' + code + ');\n$2',
	);
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
	injectDialogTag(tag, 'function(e, p, o){ kitsy.deferredDialogFunctions["' + tag + '"].push({e:e,p:p}); o(null); }');
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
	addDialogTag(tag + 'Now', function (environment, parameters, onReturn) {
		fn(environment, parameters);
		onReturn(null);
	});
	addDeferredDialogTag(tag, fn);
}





var audioElementsById = {};
var currentMusic;
var roomMusicFlag = null;

// cleanup old audio tags if any are present (e.g. on restart)
before('load_game', function () {
	Object.entries(hackOptions.audio).forEach(function (entry) {
		var el = document.getElementById(entry[0]);
		if (el) {
			el.remove();
		}
		delete audioElementsById[entry[0]];
	});
});

after('load_game', function () {
	var room;
	// expand the map to include ids of rooms listed by name
	Object.entries(hackOptions.musicByRoom).forEach(function (entry) {
		room = getRoom(entry[0]);
		if (room) {
			hackOptions.musicByRoom[room.id] = entry[1];
		}
	});
	// add audio tags from options
	Object.entries(hackOptions.audio).forEach(function (entry) {
		var el = document.createElement('audio');
		var src = entry[1].src;
		el.id = entry[0];
		Object.assign(el, entry[1]);
		if (typeof src !== 'string') {
			el.src = null;
			src.forEach(function (s) {
				var sourceEl = document.createElement('source');
				sourceEl.src = s;
				sourceEl.type = 'audio/' + s.split('.').pop();
				el.appendChild(sourceEl);
			});
		}
		document.body.appendChild(el);
		audioElementsById[el.id] = el;
	});

	// handle autoplay restrictions by playing then pausing
	// every audio element on the first user interaction
	function handleAutoPlayRestrictions() {
		Object.values(audioElementsById).forEach(function (audio) {
			audio.play();
			// let the current song play
			if (currentMusic === audio.id) {
				return;
			}
			audio.pause();
			audio.currentTime = 0;
		});
		document.body.removeEventListener('pointerup', handleAutoPlayRestrictions);
		document.body.removeEventListener('keydown', handleAutoPlayRestrictions);
	}

	document.body.addEventListener('pointerup', handleAutoPlayRestrictions);
	document.body.addEventListener('keydown', handleAutoPlayRestrictions);
});

function getAudio(id) {
	var el = audioElementsById[id] || (audioElementsById[id] = document.getElementById(id));
	if (!el) {
		throw new Error("bitsymuse tried to use audio with id '" + id + "' but couldn't find one on the page!");
	}
	return el;
}

function playSound(soundParam) {
	if (!soundParam) {
		return;
	}
	getAudio(soundParam).play();
}

function changeMusic(newMusic) {
	var audio;
	// if we didn't get new music,
	// or the music didn't change,
	// there's no work to be done
	if (!newMusic || newMusic === currentMusic) {
		return;
	}

	// stop old music
	if (currentMusic && currentMusic !== hackOptions.silenceId) {
		audio = getAudio(currentMusic);
		audio.pause();
		if (!hackOptions.resume) {
			audio.currentTime = 0.0;
		}
	}

	// start new music
	currentMusic = newMusic;
	// special case: don't start anything new
	if (newMusic === hackOptions.silenceId) {
		return;
	}
	getAudio(newMusic).play();
}

after('drawRoom', function () {
	if (roomMusicFlag !== bitsy.curRoom) {
		changeMusic(hackOptions.musicByRoom[bitsy.curRoom]);
		roomMusicFlag = bitsy.curRoom;
	}
});

// Implement the dialog functions
addDualDialogTag('music', function (environment, parameters) {
	if (!parameters[0]) {
		throw new Error('{music/musicNow} was missing parameters! Usage: {music/musicNow "track name"}');
	}
	changeMusic(parameters[0]);
});

addDualDialogTag('soundeffect', function (environment, parameters) {
	if (!parameters[0]) {
		throw new Error('{soundeffect/soundeffectNow} was missing parameters! Usage: {soundeffect/soundeffectNow "track name"}');
	}
	playSound(parameters[0]);
});
// End of (music) dialog function mod

exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

}(this.hacks.bitsymuse = this.hacks.bitsymuse || {}, window));

/**
💾
@file save
@summary save/load your game
@license MIT
@version 15.4.2
@requires 5.4
@author Sean S. LeBlanc

@description
Introduces save/load functionality.

Includes:
	- data that may be saved/loaded:
		- current room/position within room
		- inventory/items in rooms
		- dialog variables
		- dialog position
	- basic autosave
	- dialog tags:
		- (save): saves game
		- (load ""): loads game; parameter is text to show as title on load
		- (clear): clears saved game
		- (saveNow)/(loadNow)/(clearNow): instant varieties of above tags

Notes:
	- Storage is implemented through browser localStorage: https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage
	  Remember to clear storage while working on a game, otherwise loading may prevent you from seeing your changes!
	  You can use the `clearOnStart` option to do this for you when testing.
	- This hack only tracks state which could be modified via vanilla bitsy features,
	  i.e. compatibility with other hacks that modify state varies;
	  you may need to modify save/load to include/exclude things for compatibility.
	  (feel free to ask for help tailoring these to your needs!)
	- There is only one "save slot"; it would not be too difficult to implement more,
	  but it adds a lot of complexity that most folks probably don't need.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Edit hackOptions below as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions =  {
// when to save/load
autosaveInterval: Infinity, // time in milliseconds between autosaves (never autosaves if Infinity)
loadOnStart: true, // if true, loads save when starting
clearOnEnd: false, // if true, deletes save when restarting after reaching an ending
clearOnStart: false, // if true, deletes save when page is loaded (mostly for debugging)

// what to save/load
position: true, // if true, saves which room the player is in, and where they are in the room
variables: true, // if true, saves dialog variables (note: does not include item counts)
items: true, // if true, saves player inventory (i.e. item counts) and item placement in rooms
dialog: true, // if true, saves dialog position (for sequences etc)
key: 'snapshot', // where in localStorage to save/load data
} ;

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw new Error('Couldn\'t find "' + searchRegex + '" in script tags');
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	if (
		!kitsy.queuedInjectScripts.some(function (script) {
			return searchRegex.toString() === script.searchRegex.toString() && replaceString === script.replaceString;
		})
	) {
		kitsy.queuedInjectScripts.push({
			searchRegex: searchRegex,
			replaceString: replaceString,
		});
	} else {
		console.warn('Ignored duplicate inject');
	}
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {},
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}

function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			}
			// run synchronously
			returnVal = functions[i++].apply(this, args);
			if (returnVal && returnVal.length) {
				args = returnVal;
			}
			return runBefore.apply(this, args);
		}

		return runBefore.apply(this, arguments);
	};
}

function reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
			if (match.substr(0, 1) === '\\') {
				return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}

function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject$1(
		/(var functionMap = new Map\(\);[^]*?)(this.HasFunction)/m,
		'$1\nfunctionMap.set("' + tag + '", ' + code + ');\n$2',
	);
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
	injectDialogTag(tag, 'function(e, p, o){ kitsy.deferredDialogFunctions["' + tag + '"].push({e:e,p:p}); o(null); }');
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
	addDialogTag(tag + 'Now', function (environment, parameters, onReturn) {
		fn(environment, parameters);
		onReturn(null);
	});
	addDeferredDialogTag(tag, fn);
}





function save() {
	var snapshot = {};
	if (hackOptions.position) {
		snapshot.room = bitsy.curRoom;
		snapshot.x = bitsy.player().x;
		snapshot.y = bitsy.player().y;
	}
	if (hackOptions.items) {
		snapshot.inventory = bitsy.player().inventory;
		snapshot.items = Object.entries(bitsy.room).map(function (room) {
			return [room[0], room[1].items];
		});
	}
	if (hackOptions.variables) {
		snapshot.variables = bitsy.scriptInterpreter.GetVariableNames().map(function (variable) {
			return [variable, bitsy.scriptInterpreter.GetVariable(variable)];
		});
	}
	if (hackOptions.dialog) {
		snapshot.sequenceIndices = bitsy.saveHack.sequenceIndices;
	}
	localStorage.setItem(hackOptions.key, JSON.stringify(snapshot));
}

function load() {
	var snapshot = localStorage.getItem(hackOptions.key);
	// if there's no save, abort load
	if (!snapshot) {
		return;
	}
	snapshot = JSON.parse(snapshot);

	if (hackOptions.position) {
		if (snapshot.room) {
			bitsy.curRoom = bitsy.player().room = snapshot.room;
		}
		if (snapshot.x && snapshot.y) {
			bitsy.player().x = snapshot.x;
			bitsy.player().y = snapshot.y;
		}
	}
	if (hackOptions.items) {
		if (snapshot.inventory) {
			bitsy.player().inventory = snapshot.inventory;
		}
		if (snapshot.items) {
			snapshot.items.forEach(function (entry) {
				bitsy.room[entry[0]].items = entry[1];
			});
		}
	}
	if (hackOptions.variables && snapshot.variables) {
		snapshot.variables.forEach(function (variable) {
			bitsy.scriptInterpreter.SetVariable(variable[0], variable[1]);
		});
	}
	if (hackOptions.dialog && snapshot.sequenceIndices) {
		bitsy.saveHack.sequenceIndices = snapshot.sequenceIndices;
	}
}

function clear() {
	localStorage.removeItem(hackOptions.key);
}

function nodeKey(node) {
	var key = node.key = node.key || node.options.map(function (option) {
		return option.Serialize();
	}).join('\n');
	return key;
}
// setup global needed for saving/loading dialog progress
bitsy.saveHack = {
	sequenceIndices: {},
	saveSeqIdx: function (node, index) {
		var key = nodeKey(node);
		bitsy.saveHack.sequenceIndices[key] = index;
	},
	loadSeqIdx: function (node) {
		var key = nodeKey(node);
		return bitsy.saveHack.sequenceIndices[key];
	},
};

// use saved index to eval/calc next index if available
inject(/(ptionsShuffled\[index\].Eval)/g, 'ptionsShuffled[window.saveHack.loadSeqIdx(this) || index].Eval');
inject(/var next = index \+ 1;/g, 'var next = (window.saveHack.loadSeqIdx(this) || index) + 1;');
// save index on changes
inject(/(index = next);/g, '$1,window.saveHack.saveSeqIdx(this, next);');
inject(/(\tindex = 0);/g, '$1,window.saveHack.saveSeqIdx(this, 0);');

// hook up autosave
var autosaveInterval;
after('onready', function () {
	if (hackOptions.autosaveInterval < Infinity) {
		clearInterval(autosaveInterval);
		autosaveInterval = setInterval(save, hackOptions.autosaveInterval);
	}
});

// hook up autoload
after('onready', function () {
	if (hackOptions.loadOnStart) {
		load();
	}
});

// hook up clear on end
before('reset_cur_game', function () {
	if (hackOptions.clearOnEnd) {
		if (bitsy.isEnding) {
			clear();
		}
	}
});

// hook up clear on start
before('startExportedGame', function () {
	if (hackOptions.clearOnStart) {
		clear();
	}
});

// hook up dialog functions
function dialogLoad(environment, parameters) {
	var loadOnStart = hackOptions.loadOnStart;
	hackOptions.loadOnStart = true;
	bitsy.reset_cur_game();
	hackOptions.loadOnStart = loadOnStart;
	bitsy.dialogBuffer.EndDialog();
	bitsy.startNarrating(parameters[0] || '');
}
addDualDialogTag('save', save);
addDualDialogTag('load', dialogLoad);
addDualDialogTag('clear', clear);

exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

}(this.hacks.save = this.hacks.save || {}, window));

/**
⏱️
@file stopwatch
@summary time player actions
@license MIT
@version 15.4.2
@author Lenny Magner

@description
Lets you start, stop and reset a timer from dialogue and print the resulting time as part of dialogue.

Usage:
	(startWatch "timer id"): starts a timer with provided id
	(stopWatch "timer id"): stops a timer with provided id
	(resumeWatch "timer id"): resumes a timer with provided id
	(sayWatch "timer id"): prints a timer with provided id

There's also startWatchNow, stopWatchNow, and resumeWatchNow,
which do the same things, but immediately instead of when dialog ends.

Notes on edge/error cases:
	(startWatch "existing id"): overwrites existing timer
	(stopWatch "non-existent id"): does nothing
	(stopWatch "stopped id"): does nothing
	(resumeWatch "non-existent id"): starts new timer
	(resumeWatch "running id"): does nothing
	(sayWatch "non-existent id"): throws error

HOW TO USE:
1. Copy-paste into a script tag after the bitsy source
2. Customize `timeToString` function in hackOptions below as needed
3. Add tags to your dialog as needed

NOTE: This uses parentheses "()" instead of curly braces "{}" around function
      calls because the Bitsy editor's fancy dialog window strips unrecognized
      curly-brace functions from dialog text. To keep from losing data, write
      these function calls with parentheses like the examples above.

      For full editor integration, you'd *probably* also need to paste this
      code at the end of the editor's `bitsy.js` file. Untested.
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions =  {
// function which returns the string which bitsy will print
// parameter is a timer object with:
//   start: value of Date.now() on startWatch
//   end: value of Date.now() on stopWatch,
//        or undefined if timer is running
// current implementation is "minutes:seconds"

timeToString: function (timer) {
  var ms = getTimeDifferenceInMs(timer);
  var time = new Date(ms);
  var mins = time.getUTCMinutes();
  var secs = time.getUTCSeconds();
  if (secs < 10) {
    secs = "0" + secs;
  }
  return mins + ":" + secs;
}
} ;

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw new Error('Couldn\'t find "' + searchRegex + '" in script tags');
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**
 * Helper for printing dialog inside of a dialog function.
 * Intended to be called using the environment + onReturn parameters of the original function;
 * e.g.
 * addDialogTag('myTag', function (environment, parameters, onReturn) {
 * 	printDialog(environment, 'my text', onReturn);
 * });
 * @param {Environment} environment Bitsy environment object; first param to a dialog function
 * @param {String} text Text to print
 * @param {Function} onReturn Bitsy onReturn function; third param to a dialog function
 */
function printDialog(environment, text, onReturn) {
	environment.GetDialogBuffer().AddText(text, function () {
		onReturn(null);
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	if (
		!kitsy.queuedInjectScripts.some(function (script) {
			return searchRegex.toString() === script.searchRegex.toString() && replaceString === script.replaceString;
		})
	) {
		kitsy.queuedInjectScripts.push({
			searchRegex: searchRegex,
			replaceString: replaceString,
		});
	} else {
		console.warn('Ignored duplicate inject');
	}
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {},
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}

function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			}
			// run synchronously
			returnVal = functions[i++].apply(this, args);
			if (returnVal && returnVal.length) {
				args = returnVal;
			}
			return runBefore.apply(this, args);
		}

		return runBefore.apply(this, arguments);
	};
}

function reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
			if (match.substr(0, 1) === '\\') {
				return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}

function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject$1(
		/(var functionMap = new Map\(\);[^]*?)(this.HasFunction)/m,
		'$1\nfunctionMap.set("' + tag + '", ' + code + ');\n$2',
	);
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
	injectDialogTag(tag, 'function(e, p, o){ kitsy.deferredDialogFunctions["' + tag + '"].push({e:e,p:p}); o(null); }');
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
	addDialogTag(tag + 'Now', function (environment, parameters, onReturn) {
		fn(environment, parameters);
		onReturn(null);
	});
	addDeferredDialogTag(tag, fn);
}





function getTimeDifferenceInMs(timer) {
	return (timer.end || Date.now()) - timer.start;
}

// map of timers
var timers;

function startWatch(environment, parameters) {
	var id = parameters[0];
	timers[id] = {
		start: Date.now(),
		end: undefined,
	};
}

// note: this updates start time directly
function resumeWatch(environment, parameters) {
	var id = parameters[0];
	var timer = timers[id];

	// just start the timer if there isn't one
	if (!timer) {
		startWatch(environment, parameters);
		return;
	}

	// don't do anything if the timer's not running
	if (!timer.end) {
		return;
	}

	// resume timer
	timer.start = Date.now() - (timer.end - timer.start);
	timer.end = undefined;
}

function stopWatch(environment, parameters) {
	var id = parameters[0];
	var timer = timers[id];
	// don't do anything if there's no timer
	if (!timer) {
		return;
	}
	// don't do anything if the timer's not running
	if (timer.end) {
		return;
	}
	// end timer
	timer.end = Date.now();
}

// clear timers on game-load
before('load_game', function () {
	timers = {};
});

// add control functions
addDualDialogTag('startWatch', startWatch);
addDualDialogTag('stopWatch', stopWatch);
addDualDialogTag('resumeWatch', resumeWatch);

// add display function
addDialogTag('sayWatch', function (environment, parameters, onReturn) {
	var timer = timers[parameters[0]];
	if (!timer) {
		throw new Error('Tried to sayWatch "' + parameters[0] + '" but it was never started');
	}
	printDialog(environment, hackOptions.timeToString(timer), onReturn);
});

exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

}(this.hacks.stopwatch = this.hacks.stopwatch || {}, window));

/**
🏁
@file transparent sprites
@summary makes all sprites have transparent backgrounds
@license MIT
@version 15.4.2
@requires Bitsy Version: 6.1
@author Sean S. LeBlanc

@description
Makes all sprites have transparent backgrounds.
i.e. tiles can be seen underneath the player, sprites, and items.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Edit hackOptions below as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions =  {
isTransparent: function (drawing) {
	// return drawing.name == 'tea'; // specific transparent drawing
	// return ['tea', 'flower', 'hat'].indexOf(drawing.name) !== -1; // specific transparent drawing list
	// return drawing.name && drawing.name.indexOf('TRANSPARENT') !== -1; // transparent drawing flag in name
	return true; // all drawings are transparent
},
} ;

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw new Error('Couldn\'t find "' + searchRegex + '" in script tags');
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {},
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}

function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			}
			// run synchronously
			returnVal = functions[i++].apply(this, args);
			if (returnVal && returnVal.length) {
				args = returnVal;
			}
			return runBefore.apply(this, args);
		}

		return runBefore.apply(this, arguments);
	};
}

function reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}





var madeTransparent;
var makeTransparent;
before('onready', function () {
	madeTransparent = {};
	makeTransparent = false;
});
before('renderer.GetImage', function (drawing, paletteId, frameOverride) {
	// check cache first
	var cache = madeTransparent[drawing.drw] = madeTransparent[drawing.drw] || {};
	var p = cache[paletteId] = cache[paletteId] || {};
	var frameIndex = frameOverride || drawing.animation.frameIndex;
	var source = bitsy.renderer.GetImageSource(drawing.drw);
	if (p[frameIndex] === source) {
		// already made this transparent
		return;
	}

	// flag the next draw as needing to be made transparent
	p[frameIndex] = source;
	makeTransparent = hackOptions.isTransparent(drawing);
});

before('drawTile', function (canvas) {
	if (makeTransparent) {
		// redraw with all bg pixels transparent
		var ctx = canvas.getContext('2d');
		var data = ctx.getImageData(0, 0, canvas.width, canvas.height);
		var bg = bitsy.getPal(bitsy.getRoomPal(bitsy.player().room))[0];
		for (let i = 0; i < data.data.length; i += 4) {
			var r = data.data[i];
			var g = data.data[i + 1];
			var b = data.data[i + 2];
			if (r === bg[0] && g === bg[1] && b === bg[2]) {
				data.data[i + 3] = 0;
			}
		}
		ctx.putImageData(data, 0, 0);
		// clear the flag
		makeTransparent = false;
	}
});

exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

}(this.hacks.transparent_sprites = this.hacks.transparent_sprites || {}, window));



</script>

<script type="text/javascript" id="borksyAdditionalJS">

</script>

<script>
	/**
🎨
@file palette maps
@summary allows color pallettes to be defined on a tile-by-tile basis
@license MIT
@version 15.4.2
@requires Bitsy Version: 6.1
@author Dana Holdampf

@description
This hack lets you change the color palette, on a tile-by-tile basis.
Each tile can use a different palette's background, tile, sprite, and extra colors.
This can also recolor sprites, changing their palette as they move through a recolored tile.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Edit hackOptions below, as needed

You can use this hack in 3 main ways:
=====================================
First, you can define a Palette Map for any room, in the hackOptions below.
- A Palette Map is a 16-by-16 grid of Palette IDs, separated by commas.
- This corresponds to what palette each location in that room will be drawn with.
- The Palette Map will override the room's default background, tile color, sprite color, etc.
- Values in the Palette Map correspond to the Palette IDs in your Game Data (0, 1, a, etc.).
- The value "-", or other undefined Palette IDs, will draw using the room's default palette.
- NOTE: The Palette Map recolors everything, including Sprites and Items drawn at that position.

Second, you can put a Palette Override Tag in the name of any tile, sprite, or item.
- By default, this tag is #PAL0, #PAL1, #PALa, etc., but this can be changed below.
- This causes that graphic to always be drawn in the specified Palette's colors.
- Set prioritizePaletteTag to false in the options, to not have tags override a Palette Map.

Third, you can use included dialog commands, to modify the palette of a room or tile.
- NOTE: If you know JS, you can also use the JavaScript Dialog Hack to modify palettes.

-- SETTING ROOM'S DEFAULT PALETTE ------------------------------

{palette "id, room"}
{paletteNow "id, room"}

Information:
- Sets default palette of a room, without changing it's Palette Map.
- This is the normal room palette set in the editor, used by tiles with undefined or empty palette ids.

Parameters:
- id:	The id (letter/number) of the color palette, which will be used as the room's new default palette.
		See the Game Data tab to reference color palette IDs
- room:	The id (number/letter) of the room you're editing the palette map for.
		Leave blank to modify the room the player is currently in.

-- SETTING PALETTE OF A SPECIFIC TILE --------------------------

{tilePalette "id, x, y, room"}
{tilePaletteNow "id, x, y, room"}

Information:
- Changes palette used at a coordinate in a room's Palette Map.
- The Palette Map affects all tiles, items, or sprites at that location.

Parameters:
- id:	The id (number/letter) of the color palette, which will override the palette used at a given position.
		Leave this blank to reset a tile's palette, and revert to the room's palette (still include commas).
		See the Game Data tab to reference color palette IDs
- x, y:	The x and y coordinates of the target tile you want to change the palette of, from 0-15.
		Put + or - before a coordinate to target tiles relative to the player's position. (ex. +10, -2).
		Leave X or Y blank (or use +0) to use the player's current position.
- room:	The id (number/letter) of the room you're editing the palette map for.
		Leave blank to modify the room the player is currently in.

-- RESETTING THE PALETTE OF ALL TILES IN A ROOM ----------------

{resetTilePalette "room"}
{resetTilePaletteNow "room"}

Information:
- Resets the Palette Map of a room back to the values it had to start.
- If the room had no default Palette Map defined in the Hack Options, tiles will be set to none.

Parameters:
- room:	The id (number/letter) of the room you're resetting the palette map for.
		Leave blank to modify the room the player is currently in.

-- CLEARS THE PALETTE MAP FOR ALL TILES IN A ROOM -------------

{clearTilePalette "roomId"}
{clearTilePaletteNow "roomId"}

Information:
- clears Palette Map data for a room, so all tiles use the room's default.

Parameters:
- room:	The id (number/letter) of the room you're resetting the palette map for.
		Leave blank to modify the room the player is currently in.

NOTE: add Now to any command to trigger it mid-dialog. (roomPalNow, tilePalNow, clearPalNow, resetPalNow)

Examples:
{palette "a,0"} sets the default palette for Room 0 to Palette a, once the dialog is done.
{paletteNow "2"} immediately sets the default palette for the current room to Palette 2.
{tilePalette "0,2,4"} sets the Palette Map at coordinates 0,2 in the current room to Palette 0.
{tilePaletteNow "z,0,0,13"} mid-dialog, sets the Palette Map at 0,0 in Room 13 to use Palette z.
{resetPalette "4"} resets Room 4's Palette Map to the palette IDs it had when the game started.
{resetPaletteNow} immediately resets the current room's Palette Map to the value it had at the start.
{clearPalette} removes Palette Map at all coordinates in the current room, so they use the default palette.
{clearPaletteNow "a1"} instantly clears Palette Map for Room a1, so all tiles show the default palette.

This hack is designed to be flexible. Here are some ideas for how to use it!
============================================================================
- By switching palettes from tile to tile, you can effectively use 2 unique colors per tile.
- You can palette-swap, allowing you to reuse the same tile or item in many colors.
- You can recolor areas for visual effects, like differently-lit, smokey, or underwater tiles.
- Using the dialog tags (or JavaScript) you can recolor an area without needing duplicate rooms.
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions = {
	paletteTag: '#PAL',
	// Add this flag to Tile/Sprite/Item Name, followed by a Palette ID (#PAL0, #PALa, etc.)
	// This tile, sprite, or item will automatically be drawn with that palette.
	// By default, this will override the room's default palette and the tile palette map.

	prioritizePaletteTag: true,
	// Whether the Palette Tag above takes priority over a room's Palette Map, when recoloring a graphic.
	// If true, Tile/Sprite/Item always uses the palette defined by it's Palette Tag, ignoring Palette Maps.
	// If false, Tile/Sprite/Item's palette is overridden by a room's Palette Map (whenever not default/"-").

	paletteMapDefinitions: {
		// You can define a Palette Map for any room here. Just copy or edit an element from this list.
		// Each row is a string of Palette IDs, separated by commas. These match the coordinates in the Room.
		// The Palette IDs in the grid are used to draw Tiles/Sprites/Items, instead of the room's default palette.
		// The IDs in the Palette Map match the Palette IDs in your Game Data (0, 1, a, z, etc.)
		// "-", or any ID that doesn't match a Palette ID, use the room's default palette.

		// This is a blank Palette Map for Room ID 0. It can be edited, copied, or removed.
		0: [
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
		],
		// This is a sample Palette Map for Room ID 100. It can be edited, copied, or removed.
		100: [
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,1,0,0,0,0,1,1,1,1,0,0,0,0,1,-',
			'-,0,-,-,-,-,-,-,-,-,-,-,-,-,0,-',
			'-,0,-,-,-,-,-,-,-,-,-,-,-,-,0,-',
			'-,0,-,-,1,1,0,0,1,1,0,0,-,-,0,-',
			'-,0,-,-,1,1,0,0,1,1,0,0,-,-,0,-',
			'-,2,-,-,0,0,1,1,0,0,1,1,-,-,2,-',
			'-,2,-,-,0,0,1,1,0,0,1,1,-,-,2,-',
			'-,2,-,-,1,1,0,0,1,1,0,0,-,-,2,-',
			'-,2,-,-,1,1,0,0,1,1,0,0,-,-,2,-',
			'-,0,-,-,0,0,1,1,0,0,1,1,-,-,0,-',
			'-,0,-,-,0,0,1,1,0,0,1,1,-,-,0,-',
			'-,0,-,-,-,-,-,-,-,-,-,-,-,-,0,-',
			'-,0,-,-,-,-,-,-,-,-,-,-,-,-,0,-',
			'-,1,0,0,0,0,3,3,3,3,0,0,0,0,1,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
		],
		// This is a blank Palette Map for Room ID ZZZ. It can be edited, copied, or removed.
		ZZZ: [
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
			'-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-',
		],
	},
};

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw new Error('Couldn\'t find "' + searchRegex + '" in script tags');
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**
 * Helper for parsing parameters that may be relative to another value
 * e.g.
 * - getRelativeNumber('1', 5) -> 1
 * - getRelativeNumber('+1', 5) -> 6
 * - getRelativeNumber('-1', 5) -> 4
 * - getRelativeNumber('', 5) -> 5
 * @param {string} value absolute or relative string to parse
 * @param {number} relativeTo value to use as fallback if none is provided, and as base for relative value
 * @return {number} resulting absolute or relative number
 */
function getRelativeNumber(value, relativeTo) {
	var v = (value || value === 0 ? value : relativeTo);
	if (typeof v === 'string' && (v.startsWith('+') || v.startsWith('-'))) {
		return relativeTo + Number(v);
	}
	return Number(v);
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	if (
		!kitsy.queuedInjectScripts.some(function (script) {
			return searchRegex.toString() === script.searchRegex.toString() && replaceString === script.replaceString;
		})
	) {
		kitsy.queuedInjectScripts.push({
			searchRegex: searchRegex,
			replaceString: replaceString,
		});
	} else {
		console.warn('Ignored duplicate inject');
	}
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {},
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}

function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			}
			// run synchronously
			returnVal = functions[i++].apply(this, args);
			if (returnVal && returnVal.length) {
				args = returnVal;
			}
			return runBefore.apply(this, args);
		}

		return runBefore.apply(this, arguments);
	};
}

function reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
			if (match.substr(0, 1) === '\\') {
				return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}

function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject$1(
		/(var functionMap = new Map\(\);[^]*?)(this.HasFunction)/m,
		'$1\nfunctionMap.set("' + tag + '", ' + code + ');\n$2',
	);
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
	injectDialogTag(tag, 'function(e, p, o){ kitsy.deferredDialogFunctions["' + tag + '"].push({e:e,p:p}); o(null); }');
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
	addDialogTag(tag + 'Now', function (environment, parameters, onReturn) {
		fn(environment, parameters);
		onReturn(null);
	});
	addDeferredDialogTag(tag, fn);
}





// The "default" Palette Map is applied to all rooms that don't have a Palette Map defined.
// Normally each coordinate is set to use the Room's Default Palette using "-", but this can be edited.
// These Palette Maps can be accessed via JS using "paletteMap.roomId[y/row][x/column]"
var defaultMap = new Array(bitsy.mapsize).fill(0).map(function () {
	return new Array(bitsy.mapsize).fill('-');
});
var paletteMap = {};

// Once world is parsed, parse the Palette Map data
after('parseWorld', parsePaletteMaps);

// Do a second pass after drawRoom, to overdraw any tiles that aren't the default palette
after('drawRoom', overdrawRecoloredTiles);

// Implement tags to set a room's Default Palette
addDualDialogTag('palette', function (environment, parameters) {
	var params = parameters[0].split(',');
	setRoomPalette(params[0], params[1]);
});

// Implement tags to modify a room's Palette Map
addDualDialogTag('tilePalette', function (environment, parameters) {
	var params = parameters[0].split(',');
	setPaletteAt(params[0], params[1], params[2], params[3]);
});

// Implement tags to delete a room's Palette Map
addDualDialogTag('clearTilePalette', function (environment, parameters) {
	clearPaletteMap(parameters[0]);
});

// Implement tags to set a reset a room's Palette Map to starting values
addDualDialogTag('resetTilePalette', function (environment, parameters) {
	resetPaletteMap(parameters[0]);
});

function getPaletteOverride(drawing) {
	if (!hackOptions.prioritizePaletteTag) {
		return undefined;
	}
	// Checks if tile/sprite/item's name contains the Palette Override Tag
	if (drawing.name) {
		var paletteId = drawing.name.indexOf(hackOptions.paletteTag);
		if (paletteId !== -1) {
			var p = drawing.name[paletteId + hackOptions.paletteTag.length];

			// TODO: make this not a single character
			// returns single digit/character after palette tag, if a valid palette
			if (bitsy.palette[p] !== undefined) {
				return p;
			}
		}
	}
	return undefined;
}

// TODO: If it's useful, replace this with a function to set every element of a Palette Map to an ID?
function clearPaletteMap(roomId) {
	console.log('Clearing palette map for room "' + roomId + '"');
	paletteMap[roomId] = JSON.parse(JSON.stringify(defaultMap));
}

function resetPaletteMap(roomId) {
	console.log('Resetting palette map for room "' + roomId + '"');

	// If given the Default parameter, resets the Default Map, and Returns.
	if (roomId.toLowerCase() === 'default') {
		clearPaletteMap('default');
		return;
	}

	// If it isn't the Default map, Deep Clone a new Palette Map object from it.
	paletteMap[roomId] = JSON.parse(JSON.stringify(paletteMap.default));

	// If Palette Map for current Room exists in Hack Options, overwrite the new map with this data.
	if (hackOptions.paletteMapDefinitions[roomId]) {
		var newPaletteData = hackOptions.paletteMapDefinitions[roomId];
		for (var y = 0; y < newPaletteData.length; y++) {
			var row = newPaletteData[y].split(',');
			for (var x = 0; x < row.length; x++) {
				var palette = row[x];
				// If Palette ID exists and matches a valid Palette, write it.
				paletteMap[roomId][y][x] = bitsy.palette[palette] ? palette : '-';
			}
		}
	}
}

function parsePaletteMaps() {
	console.log('Parsing palette maps');
	resetPaletteMap('default');
	Object.keys(bitsy.room).forEach(resetPaletteMap); // Initialize Palette Maps for each Room
}

// Trim and sanitize position parameter, and set relative positions
function getPosition(position, axis) {
	var playerPosition = bitsy.player()[axis];
	var p = getRelativeNumber(position, playerPosition);
	if (p < 0 || p > bitsy.mapsize - 1) {
		console.error('Position ' + p + '' + axis + ' out of bounds; 0-' + bitsy.mapsize - 1 + ' expected');
		return undefined;
	}
	return position;
}

// Trim and sanitize Room ID parameter, falling back to current room if omitted
function getRoom(roomId) {
	roomId = (roomId === undefined ? bitsy.curRoom : roomId).toString().trim();
	return bitsy.room[roomId];
}

function setPaletteAt(p, x, y, roomId) {
	x = getPosition(x, 'x');
	y = getPosition(y, 'y');
	var room = getRoom(roomId);

	// Trim and sanitize Room ID parameter, and set to current room if omitted
	if (!room) {
		console.error('Could not set palette: room with id "' + roomId + '" not found');
		return;
	}

	if (p === undefined) {
		p = '-';
	} else if (bitsy.palette[p] === undefined) {
		p = '-';
	}
	console.log('Set palette at ' + x + ',' + y + '(room ' + roomId + ') to ' + p);
	paletteMap[roomId][y][x] = p;
}

function setRoomPalette(paletteId, roomId) {
	var room = getRoom(roomId);
	if (!room) {
		console.error('Could not set palette: room with id "' + roomId + '" not found');
		return;
	}
	var palette = bitsy.palette[paletteId];
	if (!palette) {
		console.error('Could not set palette: invalid palette "' + paletteId + '"');
		return;
	}
	bitsy.room[roomId].pal = paletteId;
}

// get palette from palette map for room at provided position, falling back to current room palette
function getPaletteAt(x, y) {
	x = getPosition(x, 'x');
	y = getPosition(y, 'y');
	var room = paletteMap[bitsy.curRoom];
	var row = room && room[y];
	var col = row && row[x];
	return (col !== '-' && col) || bitsy.getRoom().pal;
}

function overdrawRecoloredTiles(room, context, frameIndex) {
	context = context || bitsy.ctx;

	// protect against invalid rooms
	if (room === undefined) {
		return;
	}
	var paletteId = room.pal || 'default';

	// draw tiles
	for (var y = 0; y < room.tilemap.length; ++y) {
		for (var x = 0; x < room.tilemap[y].length; ++x) {
			var tileTop = y * bitsy.tilesize;
			var tileLeft = x * bitsy.tilesize;
			var tilePaletteId = getPaletteAt(x, y);

			// skip if palette is invalid or default
			if (!bitsy.palette[tilePaletteId] || bitsy.palette[tilePaletteId] === paletteId) {
				continue;
			}
			// draw backgrounds as colored rectangles
			context.fillStyle = 'rgb(' + bitsy.getPal(tilePaletteId)[0].join(',') + ')';
			context.fillRect(tileLeft * bitsy.scale, tileTop * bitsy.scale, (tileLeft + bitsy.tilesize) * bitsy.scale, (tileTop + bitsy.tilesize) * bitsy.scale);

			// skip if tile is empty/invalid
			var id = room.tilemap[y][x];
			if (id === '0' || !bitsy.tile[id]) {
				continue;
			}

			// If a tile has the #PAL tag, it overrides the tile's normal palette.
			tilePaletteId = getPaletteOverride(bitsy.tile[room.tilemap[y][x]]) || tilePaletteId;
			bitsy.drawTile(bitsy.getTileImage(bitsy.tile[id], tilePaletteId, frameIndex), x, y, context);
		}
	}

	// draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];

		var itemPaletteId = getPaletteAt(itm.x, itm.y);
		// skip if palette is invalid or default
		if (!bitsy.palette[itemPaletteId] || bitsy.palette[itemPaletteId] === paletteId) {
			continue;
		}
		itemPaletteId = getPaletteOverride(bitsy.item[itm.id]) || itemPaletteId;
		bitsy.drawItem(bitsy.getItemImage(bitsy.item[itm.id], itemPaletteId, frameIndex), itm.x, itm.y, context);
	}

	// draw sprites
	Object.values(bitsy.sprite)
		.filter(function (spr) {
			return spr.room === room.id;
		})
		.forEach(function (spr) {
			// Get palette map at sprite's coordinate
			var spritePaletteId = getPaletteAt(spr.x, spr.y);
			// skip if palette is invalid or default
			if (!bitsy.palette[spritePaletteId] || bitsy.palette[spritePaletteId] === paletteId) {
				return;
			}
			spritePaletteId = getPaletteOverride(spr) || spritePaletteId;
			bitsy.drawSprite(bitsy.getSpriteImage(spr, spritePaletteId, frameIndex), spr.x, spr.y, context);
		});
}

exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

}(this.hacks.palette_maps = this.hacks.palette_maps || {}, window));

</script>

<script>
	/**
🚀
@file dialog jump
@summary jump from one dialog entry to another
@license MIT
@version 15.4.2
@requires 7.0
@author Sean S. LeBlanc

@description
This can be used to simplify complex dialog
by moving portions to self-contained dialog entries,
and then jumping to the appropriate id when necessary.

You can also provide raw dialog text instead of an id;
Functionally this isn't much different from writing raw dialog text,
but it has some uses for advanced cases (e.g. when combined with dialog choices)

Usage:
	(jump "dialogId")
	(jumpNow "dialogId")
	(jump "dialog to print")
	(jumpNow "dialog to print")

Note: be careful of infinite loops, e.g.
DLG_infinite_loop
"""
this will print forever(jump "DLG_infinite_loop")
"""

HOW TO USE:
Copy-paste into a script tag after the bitsy source
*/
(function (bitsy) {
'use strict';

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw new Error('Couldn\'t find "' + searchRegex + '" in script tags');
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	if (
		!kitsy.queuedInjectScripts.some(function (script) {
			return searchRegex.toString() === script.searchRegex.toString() && replaceString === script.replaceString;
		})
	) {
		kitsy.queuedInjectScripts.push({
			searchRegex: searchRegex,
			replaceString: replaceString,
		});
	} else {
		console.warn('Ignored duplicate inject');
	}
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {},
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}

function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			}
			// run synchronously
			returnVal = functions[i++].apply(this, args);
			if (returnVal && returnVal.length) {
				args = returnVal;
			}
			return runBefore.apply(this, args);
		}

		return runBefore.apply(this, arguments);
	};
}

function reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
			if (match.substr(0, 1) === '\\') {
				return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}

function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject$1(
		/(var functionMap = new Map\(\);[^]*?)(this.HasFunction)/m,
		'$1\nfunctionMap.set("' + tag + '", ' + code + ');\n$2',
	);
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
	injectDialogTag(tag, 'function(e, p, o){ kitsy.deferredDialogFunctions["' + tag + '"].push({e:e,p:p}); o(null); }');
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
	addDialogTag(tag + 'Now', function (environment, parameters, onReturn) {
		fn(environment, parameters);
		onReturn(null);
	});
	addDeferredDialogTag(tag, fn);
}



// jump function
function jump(targetDialog) {
	if (!targetDialog) {
		console.warn('Tried to jump to dialog, but no target dialog provided');
		return;
	}
	var dialogStr = bitsy.dialog[targetDialog];
	var dialogId;
	if (!dialogStr) {
		dialogStr = targetDialog;
	} else {
		dialogId = targetDialog;
		dialogStr = dialogStr.src;
	}
	bitsy.startDialog(dialogStr, dialogId);
}

addDualDialogTag('jump', function (environment, parameters) {
	jump(parameters[0]);
});

}(window));

</script>

<script>
	/**
😽
@file character portraits
@summary high quality anime jpegs (or pngs i guess)
@license MIT
@version 15.4.2
@requires Bitsy Version: 5.3
@author Sean S. LeBlanc

@description
Adds a tag (portrait "id") which adds the ability to draw high resolution images during dialog.

Examples:
	(portrait "cat")
		draws the image named "cat" in the hackOptions
	(portrait "")
		resets the portrait to not draw

By default, the portrait will clear when dialog is exited,
but this can be customized in the hackOptions below.

All portraits are drawn from the top-left corner, on top of the game and below the dialog box.
They are scaled uniformly according to the hackOptions below,
and are cropped to bitsy's canvas width/height.

All portraits are preloaded, but their loading state is ignored.
i.e. The game will start before they have all loaded,
and they simply won't draw if they're not loaded or have errored out.

All standard browser image formats are supported, but keep filesize in mind!

Notes:
- The hack is called "character portraits", but this can easily be used to show images of any sort
- Images drawn with this hack may taint bitsy's canvas, preventing exit transitions from working.
  You can avoid this by only using images hosted alongside your game on a server.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Edit the hackOptions object as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions = {
	// influences the resolution of the drawn image
	// `bitsy.scale` (4 by default) is the max and will match bitsy's internal scale (i.e. 512x512)
	// 1 will match bitsy's in-game virtual scale (i.e. 128x128)
	// it's best to decide this up-front and make portrait images that match this resolution
	scale: bitsy.scale,
	// a list of portrait files
	// the format is: 'id for portrait tag': 'file path'
	// these may be:
	// - local files (in which case you need to include them with your html when publishing)
	// - online urls (which are not guaranteed to work as they are network-dependent)
	// - base64-encoded images (the most reliable but unwieldy)
	portraits: {
		'avatar': '..../vividdreamsgamefolder/avatarforvividdreams.png',
	},
	autoReset: true, // if true, automatically resets the portrait to blank when dialog is exited
	dialogOnly: true, // if true, portrait is only shown when dialog is active
};

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw new Error('Couldn\'t find "' + searchRegex + '" in script tags');
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	if (
		!kitsy.queuedInjectScripts.some(function (script) {
			return searchRegex.toString() === script.searchRegex.toString() && replaceString === script.replaceString;
		})
	) {
		kitsy.queuedInjectScripts.push({
			searchRegex: searchRegex,
			replaceString: replaceString,
		});
	} else {
		console.warn('Ignored duplicate inject');
	}
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {},
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}

function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			}
			// run synchronously
			returnVal = functions[i++].apply(this, args);
			if (returnVal && returnVal.length) {
				args = returnVal;
			}
			return runBefore.apply(this, args);
		}

		return runBefore.apply(this, arguments);
	};
}

function reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
			if (match.substr(0, 1) === '\\') {
				return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}

function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject$1(
		/(var functionMap = new Map\(\);[^]*?)(this.HasFunction)/m,
		'$1\nfunctionMap.set("' + tag + '", ' + code + ');\n$2',
	);
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}





var state = {
	portraits: {},
	portrait: null,
};

// preload images into a cache
after('startExportedGame', function () {
	Object.keys(hackOptions.portraits).forEach(function (i) {
		state.portraits[i] = new Image();
		state.portraits[i].src = hackOptions.portraits[i];
	});
});

// hook up dialog tag
addDialogTag('portrait', function (environment, parameters, onReturn) {
	var newPortrait = parameters[0];
	var image = state.portraits[newPortrait];
	if (state.portrait === image) {
		onReturn(null);
		return;
	}
	state.portrait = image;
	onReturn(null);
});

// hook up drawing
var context;
after('drawRoom', function () {
	if ((hackOptions.dialogOnly && !bitsy.isDialogMode && !bitsy.isNarrating) || !state.portrait) {
		return;
	}
	if (!context) {
		context = bitsy.canvas.getContext('2d');
		context.imageSmoothingEnabled = false;
	}
	try {
		context.drawImage(state.portrait, 0, 0, bitsy.width * hackOptions.scale, bitsy.height * hackOptions.scale, 0, 0, bitsy.width * bitsy.scale, bitsy.height * bitsy.scale);
	} catch (error) {
		// log and ignore errors
		// so broken images don't break the game
		console.error('Portrait error', error);
	}
});

after('onExitDialog', function () {
	if (hackOptions.autoReset) {
		state.portrait = '';
	}
});

exports.hackOptions = hackOptions;
exports.state = state;

Object.defineProperty(exports, '__esModule', { value: true });

}(this.hacks.character_portraits = this.hacks.character_portraits || {}, window));

</script>

<script>
	/**
⏳
@file permanent items
@summary prevent some items from being picked up
@license MIT
@version 15.4.2
@requires 7.0
@author Sean S. LeBlanc

@description
Prevents certain items from being picked up, but allows them to be walked over and triggers their dialog.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Update the `itemIsPermanent` function below to match your needs
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions = {
	itemIsPermanent: function (item) {
		// return item.name && item.name == 'tea'; // specific permanent item
		// return ['tea', 'flower', 'hat'].indexOf(item.name) !== -1; // specific permanent item list
		// return item.name && item.name.indexOf('PERMANENT') !== -1; // permanent item flag in name
		return true; // all items are permanent
	},
};

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw new Error('Couldn\'t find "' + searchRegex + '" in script tags');
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {},
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}

function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			}
			// run synchronously
			returnVal = functions[i++].apply(this, args);
			if (returnVal && returnVal.length) {
				args = returnVal;
			}
			return runBefore.apply(this, args);
		}

		return runBefore.apply(this, arguments);
	};
}

function reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}





var room;
var oldItems;
before('movePlayer', function () {
	room = bitsy.room[bitsy.curRoom];
	oldItems = room.items.slice();
});
before('startItemDialog', function (itemId, dialogCallback) {
	// something changed
	if (!hackOptions.itemIsPermanent(bitsy.item[itemId])) {
		return undefined;
	}
	room = bitsy.room[bitsy.curRoom];
	oldItems = room.items.slice();
	return [itemId, function () {
		var newItems = room.items;
		if (newItems.length === oldItems.length) {
			return; // nothing changed
		}

		// check for changes
		for (var i = 0; i < oldItems.length; ++i) {
			if (!newItems[i]
				|| oldItems[i].x !== newItems[i].x
				|| oldItems[i].y !== newItems[i].y
				|| oldItems[i].id !== newItems[i].id
			) {
				// something changed
				if (hackOptions.itemIsPermanent(bitsy.item[oldItems[i].id])) {
					// put that back!
					newItems.splice(i, 0, oldItems[i]);
				} else {
					// add an empty entry for now to keep the arrays aligned
					newItems.splice(i, 0, null);
				}
			}
		}
		// clear out those empty entries
		room.items = newItems.filter(function (item) {
			return !!item;
		});

		// run the actual callback
		if (dialogCallback) {
			dialogCallback();
		}
	}];
});

exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

}(this.hacks.permanent_items = this.hacks.permanent_items || {}, window));

</script>

<script>
	/**
💕
@file follower
@summary make sprites follow the player
@license MIT
@version 15.4.2
@requires 7.0
@author Sean S. LeBlanc

@description
Make sprites follow the player.
Followers can optionally collide with the player,
and can be changed at runtime with dialog commands.

Usage:
	(follower "followerNameOrId")
	(followerNow "followerNameOrId")
	(followerCollision "true/false")
	(followerDelay "frames")
	(followerDelayNow "frames")
	(followerSync)
	(followerSyncNow)

Examples:
	(follower "a") - the sprite with the id "a" starts/stops following
	(follower "my follower") - the sprite with the name "my follower" starts/stops following
	(followerCollision "true") - enables follower collision
	(followerCollision "false") - disables follower collision
	(followerDelay "0") - sets follower to move immediately after player
	(followerDelay "200") - sets follower to move at normal speed
	(followerDelay "1000") - sets follower to move once per second
	(followerSync) - moves the follower on top of the player

Known issues:
- Followers will warp to the player on their first movement.
  This can be avoided by placing them next to or on the same tile as the player.
- When collision is enabled, it's possible for the player to get stuck
  between walls and their followers. Make sure to avoid single-tile width
  spaces when using this (or design with that restriction in mind!)

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Edit hackOptions below to set up initial followers
3. Use dialog commands as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions = {
	allowFollowerCollision: true, // if true, the player can walk into followers and talk to them (possible to get stuck this way)
	followers: ['j'], // ids or names of sprites to be followers; use [] to start without a follower
	delay: 200, // delay between each follower step (0 is immediate, 400 is twice as slow as normal)
	stack: false, // if true, followers stack on top of each other; otherwise, they will form a chain
};

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw new Error('Couldn\'t find "' + searchRegex + '" in script tags');
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/*
Helper for getting image by name or id

Args:
	name: id or name of image to return
	 map: map of images (e.g. `sprite`, `tile`, `item`)

Returns: the image in the given map with the given name/id
 */
function getImage(name, map) {
	var id = Object.prototype.hasOwnProperty.call(map, name) ? name : Object.keys(map).find(function (e) {
		return map[e].name === name;
	});
	return map[id];
}

/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	if (
		!kitsy.queuedInjectScripts.some(function (script) {
			return searchRegex.toString() === script.searchRegex.toString() && replaceString === script.replaceString;
		})
	) {
		kitsy.queuedInjectScripts.push({
			searchRegex: searchRegex,
			replaceString: replaceString,
		});
	} else {
		console.warn('Ignored duplicate inject');
	}
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {},
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}

function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var functionNameSegments = functionName.split('.');
	var obj = bitsy;
	while (functionNameSegments.length > 1) {
		obj = obj[functionNameSegments.shift()];
	}
	var lastSegment = functionNameSegments[0];
	var superFn = obj[lastSegment];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	obj[lastSegment] = function () {
		var returnVal;
		var args = [].slice.call(arguments);
		var i = 0;

		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return returnVal;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				return functions[i++].apply(this, args.concat(runBefore.bind(this)));
			}
			// run synchronously
			returnVal = functions[i++].apply(this, args);
			if (returnVal && returnVal.length) {
				args = returnVal;
			}
			return runBefore.apply(this, args);
		}

		return runBefore.apply(this, arguments);
	};
}

function reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
			if (match.substr(0, 1) === '\\') {
				return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}

function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject$1(
		/(var functionMap = new Map\(\);[^]*?)(this.HasFunction)/m,
		'$1\nfunctionMap.set("' + tag + '", ' + code + ');\n$2',
	);
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
	injectDialogTag(tag, 'function(e, p, o){ kitsy.deferredDialogFunctions["' + tag + '"].push({e:e,p:p}); o(null); }');
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
	addDialogTag(tag + 'Now', function (environment, parameters, onReturn) {
		fn(environment, parameters);
		onReturn(null);
	});
	addDeferredDialogTag(tag, fn);
}





var followers = [];
var paths = {};

function setFollower(followerName) {
	var follower = followerName && getImage(followerName, bitsy.sprite);
	if (!follower) {
		throw new Error('Failed to find sprite with id/name "' + followerName + '"');
	}
	var idx = followers.indexOf(follower);
	if (idx >= 0) {
		followers.splice(idx, 1);
	} else {
		followers.push(follower);
	}
	paths[follower.id] = paths[follower.id] || [];
	takeStep();
}

var walking = false;

function takeStep() {
	if (walking) {
		return;
	}
	walking = true;
	setTimeout(() => {
		let takeAnother = false;
		followers.forEach(function (follower) {
			var path = paths[follower.id];
			var point = path.shift();
			if (point) {
				follower.x = point.x;
				follower.y = point.y;
				follower.room = point.room;
			}
			walking = false;
			if (path.length) {
				takeAnother = true;
			}
		});
		if (takeAnother) {
			takeStep();
		}
	}, hackOptions.delay);
}

after('startExportedGame', function () {
	hackOptions.followers.forEach(setFollower);

	// remove + add player to sprite list to force rendering them on top of followers
	var p = bitsy.sprite[bitsy.playerId];
	delete bitsy.sprite[bitsy.playerId];
	bitsy.sprite[bitsy.playerId] = p;
});

let px;
let py;
before('update', function () {
	px = bitsy.player().x;
	py = bitsy.player().y;
});
let movedFollower = false;
after('update', function () {
	// only walk if player moved
	if (px === bitsy.player().x && py === bitsy.player().y) {
		return;
	}
	// skip walking if already moved due to exits
	if (movedFollower) {
		movedFollower = false;
		return;
	}

	if (!followers.length) {
		takeStep();
		walking = false;
		return;
	}

	// start at the player's current position (they have already moved)
	var step = {
		x: bitsy.player().x,
		y: bitsy.player().y,
		room: bitsy.player().room,
	};
	// adjust follower to be one step back
	switch (bitsy.curPlayerDirection) {
	case bitsy.Direction.Up:
		step.y += 1;
		break;
	case bitsy.Direction.Down:
		step.y -= 1;
		break;
	case bitsy.Direction.Left:
		step.x += 1;
		break;
	case bitsy.Direction.Right:
		step.x -= 1;
		break;
	}
	followers.forEach(function (follower, idx) {
		if (idx === 0 || hackOptions.stack) {
			paths[follower.id].push(step);
		} else {
			var prevFollower = followers[idx - 1];
			var prev = paths[prevFollower.id];
			paths[follower.id].push(prev[prev.length - 2] || {
				x: prevFollower.x,
				y: prevFollower.y,
				room: prevFollower.room,
			});
		}
	});
	takeStep();
});

// make followers walk "through" exits
before('movePlayerThroughExit', function (exit) {
	if (followers.length) {
		movedFollower = true;
		followers.forEach(function (follower) {
			paths[follower.id].push({
				x: exit.dest.x,
				y: exit.dest.y,
				room: exit.dest.room,
			});
		});
		takeStep();
	}
});

function filterFollowing(id) {
	return followers.some(function (follower) {
		return follower.id === id;
	}) ? null : id;
}

var originalGetSpriteLeft;
var originalGetSpriteRight;
var originalGetSpriteUp;
var originalGetSpriteDown;
before('movePlayer', function () {
	originalGetSpriteLeft = bitsy.getSpriteLeft;
	originalGetSpriteRight = bitsy.getSpriteRight;
	originalGetSpriteUp = bitsy.getSpriteUp;
	originalGetSpriteDown = bitsy.getSpriteDown;

	// filter follower out of collisions
	bitsy.getSpriteLeft = function () {
		if (!hackOptions.allowFollowerCollision) {
			return filterFollowing(originalGetSpriteLeft());
		}
		return originalGetSpriteLeft();
	};
	bitsy.getSpriteRight = function () {
		if (!hackOptions.allowFollowerCollision) {
			return filterFollowing(originalGetSpriteRight());
		}
		return originalGetSpriteRight();
	};
	bitsy.getSpriteUp = function () {
		if (!hackOptions.allowFollowerCollision) {
			return filterFollowing(originalGetSpriteUp());
		}
		return originalGetSpriteUp();
	};
	bitsy.getSpriteDown = function () {
		if (!hackOptions.allowFollowerCollision) {
			return filterFollowing(originalGetSpriteDown());
		}
		return originalGetSpriteDown();
	};
});

after('movePlayer', function () {
	bitsy.getSpriteLeft = originalGetSpriteLeft;
	bitsy.getSpriteRight = originalGetSpriteRight;
	bitsy.getSpriteUp = originalGetSpriteUp;
	bitsy.getSpriteDown = originalGetSpriteDown;
});

addDualDialogTag('follower', function (environment, parameters) {
	setFollower(parameters[0]);
});
addDialogTag('followerCollision', function (environment, parameters) {
	hackOptions.allowFollowerCollision = parameters[0] !== 'false';
});
addDualDialogTag('followerDelay', function (environment, parameters) {
	hackOptions.delay = parseInt(parameters[0], 10);
});
addDualDialogTag('followerSync', function () {
	var player = bitsy.player();
	followers.forEach(function (follower) {
		follower.room = player.room;
		follower.x = player.x;
		follower.y = player.y;
		paths[follower.id].length = 0;
	});
});

before('moveSprites', function () {
	bitsy.moveCounter -= bitsy.deltaTime; // cancel out default movement delay
	bitsy.moveCounter += bitsy.deltaTime * (200 / hackOptions.delay); // apply movement delay from options
});

exports.followers = followers;
exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

}(this.hacks.follower = this.hacks.follower || {}, window));

</script>


</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
<!-- GAME CANVAS -->
<canvas id='game'></canvas>
</body>

<img src="..../vividdreamsgamefolder/avatarforvividdreams.png" >

</html>